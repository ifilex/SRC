  JMP Main ;Skip over TSR Code to Main Program


;==============================================================================
;NOTE: This program is written for and compiled with Eric Isaacson's A86
;      assembly language compiler, using Options +P0 -F (8086 CPU and
;      no FPU).
;==============================================================================


;In DOCs:

;If setting up to handle system with no real keyboard (like Dell Desktop),
;  MUST start with a batch file that includes USBUHCI{L}, USBKEYB, and,
;  if appropriate, USBHUB.  If not done with a batch file, keyboard stops
;  working once USBUHCI{L} loads, so you can't use keyboard to load USBKEYB
;  to make the keyboard work again.
;Works with Win 3.0 in Real & Standard Mode, 3.1 in Standard Mode,
;  Win95 in Safe Mode (all using Method 1).
;  In Windows 3.1 Enhanced Mode, USB Controller is shut down as soon as
;    Windows starts (taking over IRQ's??)
;No way to "Disable" entire program, only individual devices.
;  Must Uninstall and then Reinstall/Reinitialize.
;Pause & Break are not Typematic'd
;If installing DOS KEYB program, do it before installing USBKEYB.  We
;  manipulate INT 09h to make sure it works correctly with us.
;FreeDOS KEYB program is not the same as the DOS program.  Does some
;  things better than DOS KEYB does, but does not fix issues that
;  help USBKEYB work better (does not rewrite INT 09h code).
;DOS KEYB program may need SETVER, if you're using a version of DOS
;  that didn't come with KEYB.
;There are also some other after-market keyboard drivers.
;Configuring USB Keyboard from USB Keyboard can cause all kinds of grief -
;  should always have a real keyboard as a backup!
;Program issuing Extended 16h Functions must handle "hanging" press codes
;  appropriately on device disconnects/program uninstalls/hardware errors/etc.
;Have added support for second Report ID (System Keys), but have not tested
;  it since we don't have a keyboard to test it with!
;Warn about disabling the keyboard you're actually using.
;  Not possible for USBKEYB to know if there's a "real" keyboard installed
;    or not, so assumes you have an alternate way to enter keystrokes.
;  Not having a mouse usually isn't a big deal, but not having a keyboard
;    is a VERY big deal.  Should ALWAYS have a real keyboard as a backup.
;  USBKEYB does not have an option to disable the "real" keyboard (unlike
;    USBMOUSE).
;  Need to round-robin our keystroke indexes?
;CPU must be at least an 80286.  No 286-specific code, but need
;  INT 70h.
;There are certain cases where keys may not be correct.  E.g., if pressing
;  Ctrl on one keyboard and Pause/Break on another keyboard, if the foreground
;  program doesn't use the BIOS data area to keep track of "Shift" key presses,
;  you may get a Pause instead of a Break.  The normal keyboard BIOS expects
;  there to only be one keyboard, and things like Pause/Break decisions and
;  Fake-Shift decisions (for Grey keys) are normally handled at a hardware
;  level (inside the single keyboard).  USBKEYB allows you to have more
;  than one keyboard, but in order to function properly, the keyboards
;  must "communicate" with each other to some degree (through the BIOS).
;KeyPad sometimes beeps with Method 3, depending on conflicting states
;  of NumLocks.
;USB Mouse/Keyboard Splitter:
;  Has problems with firmware!!
;    Pause Key, several special keys don't do anything at all.
;    Sends initial key, then releases key, then holds key down.
;      Does not just hold key down like it's supposed to.
;  Does not always work right away on bootup.
;Methods 1 & 2 are flaky on Sony Laptop, Method 2 eventually locks up
;  the computer
;If RealKeyboard = No, doesn't allow Disables.  Doesn't warn or beep or
;  consider it an error, just doesn't do it.
;Many "real" keyboards do funky things, so may have problems with certain
;  keys or key combinations.  This is especially true with Laptops.
;HUGE Delays in responding CapsLock/NumLock on DeskTop, both with USBKEYB
;  and SCANCODE.  CLOCK stops -- problem seems to be in Dell USB BIOS,
;  not with us, but don't know for sure..


COMMENT 

  We do not use any 286-specific code, but still require an 80286 CPU
    for this program to operate.  We use INT 70h (the CMOS Timer) to
    perform some functions, which does not exist on pre-80286 computers.

  Since this program is USB-related, and all current implentations of
    USB hardware require a PCI Bus, and a PCI Bus requires at least an
    80386 CPU, any computer that this program is installed and working on
    will have at least an 80386 CPU.  In spite of the CPU requirements
    for the hardware, though, we still leave the code 8088-compatible.
    This makes it easier for someone to "export" the code to another
    program if they want.

END COMMENT ;

COMMENT ======================================================================

  On the Keyboard (and also on the Mouse), there is a Set HID Idle Request.
    This is SUPPOSED to set the Initial Delay of the Device, and the Initial
    Delay is supposed to go into effect AFTER the initial keystroke is
    reported.  On the Keyboard and Mice I've tested, It goes into effect
    BEFORE the first keystroke is reported.  If you set it like you're
    supposed to (according to the USB recommendations), it is virtually
    useless.  USB recommends setting the Idle Rate to 500ms by default.  That
    simply doesn't work.

  In this Driver, we set the HID Idle Rate, and also the keyboard poll rate,
    to 10 ms.  We will need to keep track of the keyboard delay and repeat
    timing in our software, since the hardware won't do it correctly like
    it should.  Needless to say, that makes our software more complicated
    than it would need to be if the Hardware worked like it was supposed to.

  God, I love this stuff.

END COMMENT ===============================================================;

COMMENT ======================================================================

  On installation, we make a call to INT 16h, function 0306h (Get Typematic
    Rate).  According to Ralf Brown's Interrupt List, this is supposed to
    work on all modern computers, but it doesn't work on mine.  Without this
    function, there is no sure way to determine the current Typematic rate.
    If the function does not work on the computer, we simply set things at
    the same defaults the computer normally uses.  If the function works,
    we set our rate to match the current rate.

  In the documentation, we will need to talk about this, and inform the user
    about the MODE CON command.  After this program is installed, we accept
    changes to the Typematic rates which will go into effect if and when
    a USB Keyboard gets installed.

END COMMENT ===============================================================;


;ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
;EQUATE/STRUCTURE/MACRO DEFINITIONS
;‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹

;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;EQUATES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;==============================================================================
;TSR Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Size of our TSR Stack
  ;----------------------------------------------------------------------------
  StackSize EQU 256

  ;----------------------------------------------------------------------------
  ;Special Interrupt 2Fh (TSR Multiplex) Function Numbers we monitor/use
  ;----------------------------------------------------------------------------
  MuxInstallChk  EQU 0 ;Handle # Install Check
  MuxGetProgName EQU 1 ;Get Program Name
  MuxGetProgVer  EQU 2 ;Get Program Version
  MuxGetAuthor   EQU 3 ;Get Program Author


;==============================================================================
;Miscellaneous
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Special Codes
  ;----------------------------------------------------------------------------
  No  EQU  0 ;Miscellaneous Yes/No tests
  Yes EQU -1 ;      "        "  "    "


;==============================================================================
;CPU Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Bit masks in the CPU Flags Register
  ;----------------------------------------------------------------------------
  CarryFlag  EQU 0001h ;Carry Flag
  ParityFlag EQU 0004h ;Parity Flag
  AuxFlag    EQU 0010h ;Auxiliary Flag
  ZeroFlag   EQU 0040h ;Zero Flag
  SignFlag   EQU 0080h ;Sign Flag
  TrapFlag   EQU 0100h ;Trap Flag
  IntFlag    EQU 0200h ;Interrupt Flag
  DirFlag    EQU 0400h ;Direction Flag
  OFFlag     EQU 0800h ;Overflow Flag

  ;----------------------------------------------------------------------------
  ;Special CPU OpCodes we need to concern ourselves with
  ;----------------------------------------------------------------------------
  OpCodeINTxx   EQU 0CDh ;CPU OpCode for INT XX
  OpCodeLOOPNZ  EQU 0E0h ;CPU OpCode for LOOPNZ
  OpCodeLOOPZ   EQU 0E1h ;CPU OpCode for LOOPZ
  OpCodeLOOP    EQU 0E2h ;CPU OpCode for LOOP
  OpCodeINALxx  EQU 0E4h ;CPU OpCode for IN AL,xx
  OpCodeINAXxx  EQU 0E5h ;CPU OpCode for IN AX,xx
  OpCodeOUTxxAL EQU 0E6h ;CPU OpCode for OUT xx,AL
  OpCodeOUTxxAX EQU 0E7h ;CPU OpCode for OUT xx,AX
  OpCodeINALDX  EQU 0ECh ;CPU OpCode for IN AL,DX
  OpCodeINAXDX  EQU 0EDh ;CPU OpCode for IN AX,DX
  OpCodeOUTDXAL EQU 0EEh ;CPU OpCode for OUT DX,AL
  OpCodeOUTDXAX EQU 0EFh ;CPU OpCode for OUT DX,AL

  OpCodeInt1Min EQU OpCodeINTxx ;Minimum OpCode we care about in INT 1


;==============================================================================
;CONsole/Screen Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Special ASCII Characters
  ;----------------------------------------------------------------------------
  Tab       EQU  9 ;Tab
  LF        EQU 10 ;Line Feed
  FormFeed  EQU 12 ;FormFeed
  CR        EQU 13 ;Carriage Return
  EOF       EQU 26 ;End-of-File
  Quote2    EQU 34 ;Double quote
  Quote1    EQU 39 ;Single quote
  BackSlash EQU 92 ;BackSlash (\)

  ;----------------------------------------------------------------------------
  ;Special Keys that can be pressed during Pause routine
  ;----------------------------------------------------------------------------
  CtrlC  EQU  3 ;Control-C Keystroke
  Escape EQU 27 ;Escape Keystroke


;==============================================================================
;DOS Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;;Minimum DOS Version required to use this program
  ;----------------------------------------------------------------------------
  MinDOSVer EQU 0300h

  ;----------------------------------------------------------------------------
  ;DOS Memory Allocation Strategies
  ;----------------------------------------------------------------------------
  StrategyLowFirst     EQU 00h ;First Fit, Low Memory Only
  StrategyLowBest      EQU 01h ;Best Fit, Low Memory Only
  StrategyLowLast      EQU 02h ;Last Fit, Low Memory Only
  ;For DOS 3&4, anything >2 is Last Fit Low Memory
  ;Below are for DOS 5+ Only
  StrategyHighFirst    EQU 40h ;First Fit, High Memory Only
  StrategyHighBest     EQU 41h ;Best Fit, High Memory Only
  StrategyHighLast     EQU 42h ;Last Fit, High Memory Only
  StrategyHighLowFirst EQU 80h ;First Fit, Try High Memory then Low Memory
  StrategyHighLowBest  EQU 81h ;Best Fit, Try High Memory then Low Memory
  StrategyHighLowLast  EQU 82h ;Last Fit, Try High Memory then Low Memory

  ;----------------------------------------------------------------------------
  ;UMB Link States
  ;----------------------------------------------------------------------------
  UMBLinkNo  EQU 00h ;UMB's are not part of DOS Memory Chain
  UMBLinkYes EQU 01h ;UMB's are in DOS Memory Chain (DOS=HIGH,UMB in CONFIG.SYS)

  ;----------------------------------------------------------------------------
  ;Sizes of various DOS data structures
  ;----------------------------------------------------------------------------
  FCBSize     EQU  44 ;Size of DOS File Control Block
  CmdTailMax  EQU 128 ;Maximum size of a DOS Command Tail
  MaxPathSize EQU  64 ;Maximum Size of a DOS Path/FileName String

  ;----------------------------------------------------------------------------
  ;Special "hard-coded" DOS Device Handles.
  ;These Handles are permanently hard-coded in DOS, and are always open.
  ;There is no need to issue Find, Open, or Close calls to these
  ;  devices - you can just use them at will.
  ;----------------------------------------------------------------------------
  StdInHandle  EQU 0 ;Standard Input Device Handle
  StdOutHandle EQU 1 ;Standard Output Device Handle
  StdErrHandle EQU 2 ;Standard Error Device Handle
  StdAuxHandle EQU 3 ;Standard Auxiliary Device Handle (COM1 by default)
  StdPrnHandle EQU 4 ;Standard Printer Device Handle (LPT1 by default)

  ;----------------------------------------------------------------------------
  ;Codes returned by INT 21h, Function 4400h (Get Device Information)
  ;----------------------------------------------------------------------------
  ;If bit 7 is Set (is a Device):
  DvcInfoIsStdIn    EQU 0001h ;STDIN
  DvcInfoIsStdOut   EQU 0002h ;STDOUT
  DvcInfoIsNUL      EQU 0004h ;NUL
  DvcInfoIsClock    EQU 0008h ;CLOCK$
  DvcInfoInt29h     EQU 0010h ;Uses Int 29h (Special Device)
  DvcInfoBinary     EQU 0020h ;Binary (Raw) Mode
  DvcInfoEOF        EQU 0040h ;EOF on Input
  DvcInfoIsDevice   EQU 0080h ;Is a Device (not a File)
  DvcInfoKEYB       EQU 0100h ;Unknown (set by DOS 6.2x KEYB program)
  DvcInfoOpenClose  EQU 0800h ;Supports Open/Close calls
  DvcInfoOutputBusy EQU 2000h ;Supports Output until Busy
  DvcInfoIOCTL      EQU 4000h ;Can process IOCTL requests (INT 21h, Func 4402h)

  ;If bit 7 is Clear (is a File):
  DvcInfoDriveMask    EQU 003Fh ;Drive number (0 = A:)
  DvcInfoNotWritten   EQU 0040h ;File has not been written (Dirty Buffer?)
  ;Bit 7 = Clear!
  DvcInfoInt24h       EQU 0100h ;Generate Int 24h on Errors (DOS 4 only)
  DvcInfoNotRemovable EQU 0800h ;Media Not Removable
  DvcInfoNoDateTime   EQU 4000h ;Don't set File Date/Time on Closing (DOS 3.0+)
  DvcInfoRemote       EQU 8000h ;File is Remote (DOS 3.0+)


;==============================================================================
;PIC-Related (for handling IRQ's)
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Programmable Interrupt Controller (PIC) I/O Addresses
  ;----------------------------------------------------------------------------
  PIC1Addr EQU  20h ;Address of PIC #1 (IRQ's 0-7)
  PIC2Addr EQU 0A0h ;Address of PIC #2 (IRQ's 8-15)

  ;----------------------------------------------------------------------------
  ;PIC Output Control Word 2
  ;----------------------------------------------------------------------------
  ;Bits 0-2 = IRQ Selection
  OCW2IRQNumMask     EQU 00000111xb ;IRQ Number that specific EOI applies to
  ;Bits 3-4 = OCW Selection
  OCW2SelectOCW2     EQU 00000000xb ;Select OCW2
  ;Bits 5-7 = Operation to Perform
  OCW2RotateClear    EQU 00000000xb ;Rotate in Auto-EOI mode (Clear)
  OCW2NonSpecificEOI EQU 00100000xb ;Non-specific EOI (20h)
  OCW2NoOp           EQU 01000000xb ;No Operation
  OCW2SpecificEOI    EQU 01100000xb ;Specific EOI
  OCW2RotateSet      EQU 10000000xb ;Rotate in Auto-EOI mode (Set)
  OCW2RotateNonSpec  EQU 10100000xb ;Rotate on Non-specific EOI
  OCW2SetPriority    EQU 11000000xb ;Set Priority
  OCW2RotateSpecific EQU 11100000xb ;Rotate on Specific EOI

  ;----------------------------------------------------------------------------
  ;PIC Output Control Word 3
  ;----------------------------------------------------------------------------
  ;Bits 0-1 = Interrupt Register Operations
  OCW3ReadNoOp0   EQU 00000000xb ;Read Register NoOp
  OCW3ReadNoOp1   EQU 00000001xb ;Read Register NoOp
  OCW3ReadIRR     EQU 00000010xb ;Read Interrupt Request Register
  OCW3ReadISR     EQU 00000011xb ;Read Interrupt In-service Register
  ;Bit 2 = Poll Command
  OCW3PollCommand EQU 00000100xb ;Poll Command
  ;Bits 3-4 = OCW Selection
  OCW3SelectOCW3  EQU 00001000xb ;Select OCW3
  ;Bits 5-6 = Special Mask Operations
  OCW3SpMaskNoOp0 EQU 00000000xb ;Special Mask NoOp
  OCW3SpMaskNoOp1 EQU 00100000xb ;Special Mask NoOp
  OCW3SpMaskReset EQU 01000000xb ;Reset Special Mask
  OCW3SpMaskSet   EQU 01100000xb ;Set Special Mask
  ;Bit 7 = Reserved (0)


;==============================================================================
;CMOS-Related (for handling IRQ 8 / INT 70h)
;==============================================================================
  ;NMIDisable    EQU  80h ;1 = Disable NMI (add to CMOSPortx when reading Port)
  CMOSPortA     EQU  0Ah ;CMOS RTC Status Byte A Address (Read-Write)
    ;Bit   7 = Time Update Cycle in Progress, Data Outputs Undefined (Read-Only)
    ;    6-4 = 22 Stage Divider
    ;          010 = Default = 32768 Hz Time Base
    ;    3-0 = Rate selection for Periodic Interrupt
    ;          0011 = 122 Ês Period (8192 Hz Minimum)
    ;          0110 = 976.562 ms Period (1024 Hz Default)
    ;          1111 = 500 ms Period (2 Hz Maximum)
    Period0002  EQU  2Fh ;Byte to send for    2 Interrupts/Second
    Period0004  EQU  2Eh ;Byte to send for    4 Interrupts/Second
    Period0008  EQU  2Dh ;Byte to send for    8 Interrupts/Second
    Period0016  EQU  2Ch ;Byte to send for   16 Interrupts/Second
    Period0032  EQU  2Bh ;Byte to send for   32 Interrupts/Second
    Period0064  EQU  2Ah ;Byte to send for   64 Interrupts/Second
    Period0128  EQU  29h ;Byte to send for  128 Interrupts/Second
    Period0256  EQU  28h ;Byte to send for  256 Interrupts/Second
    Period0512  EQU  27h ;Byte to send for  512 Interrupts/Second
    Period1024  EQU  26h ;Byte to send for 1024 Interrupts/Second (Default)
    Period2048  EQU  25h ;Byte to send for 2048 Interrupts/Second
    Period4096  EQU  24h ;Byte to send for 4096 Interrupts/Second
    Period8192  EQU  23h ;Byte to send for 8192 Interrupts/Second
  CMOSPortB     EQU  0Bh ;CMOS RTC Status Byte A Address (Read-Write)
    ;Bit 7 = Enable Clock Setting by Freezing Updates
    ;    6 = Enable Periodic Interrupt
    ;    5 = Enable Alarm Interrupt
    ;    4 = Enable Update-Ended Interrupt
    ;    3 = Enable Square-Wave Output
    ;    2 = Data Mode: 0 = BCD, 1 = Binary
    ;    1 = Hour Mode: 0 = 12-Hour Mode, 1 = 24-Hour Mode
    ;    0 = Daylight Savings Enable
    PeriodicInt EQU  40h ;Bit Mask for RTC Periodic Interrupt
    ;IntMasks    EQU 0F1h ;Bit Mask for all Interrupt Enables
  CMOSPortC     EQU  0Ch ;CMOS RTC Status Byte C Address (Read-Only)
    ;Bit   7 = Interrupt Request Flag
    ;          1 when any or all of bits 6-4 are 1 and appropriate bits in
    ;            Port B are Enabled.  Generates IRQ 8 (Int 70h) when triggered.
    ;      6 = Periodic Interrupt Flag
    ;      5 = Alarm Interrupt Flag
    ;      4 = Update-Ended Interrupt Flag
    ;    3-0 = Unused
  CMOSPortD     EQU  0Dh ;CMOS RTC Status Byte D Address (Read-Only)
    ;Bit   7 = Battery Good (0 = Battery Dead or Disconnected)
    ;    6-0 = Unused


;==============================================================================
;Keyboard Related
;==============================================================================

COMMENT 

  Number of entries in various Tables

  The first one is the Raw Data returned by the USB Keyboard
    A regular keyboard returns the status of the Shift Keys in byte 0,
      and byte 1 is reserved (unused).  "Real" Keystrokes are in bytes
      2->7.

  The second one is the Table we use to keep track of continuously-pressed keys
    (Delays, Repeat Rates, etc.) so that we know when to send repeating
     keystrokes, and when a key is finally released.

  The third one stores the USB Codes after they have been converted to
    Scan Codes, and are the Codes that are actually "typed" into the
    Computer.  It needs to be big enough to temporarily store all keystrokes
    from our USB keyboards, as well as any keystrokes that are processed
    through the INT 16h Extended Functions we provide.
    It is a circular buffer, and keystrokes will get shifted out of the
    buffer fairly quickly once they are there, so it doesn't need to be huge.

  The last two are the user-defined USB-to-ScanCode definitions, one for
    "regular" keys and one for "system" keys.  These are big enough to
    remap virtually the entire keyboard if necessary.  I don't know how
    foreign keyboards work (say, from European countries), so I don't know
    how much this will get used.  If it ends up being needed for foreign
    keyboards, we may want to include several sample definition files with
    the program, at least for the "common" European keyboards.

END COMMENT ;

;  MaxKeybDataSize EQU   8 ;Maximum number of Raw bytes returned by USB Keyboard
  MaxKeybDataSize EQU  16 ;Maximum number of Raw bytes returned by USB Keyboard
  NumUSBKeys      EQU (MaxKeybDataSize+6) ;Number of Keys we can keep track of
                          ;First byte of keyboard data is the "Shift" Keys,
                          ;  which equates to as many as 8 "real" keys
                          ;Second byte of keyboard data is reserved, and
                          ;  never used for anything.
                          ;Therefore, adding six to the size of the keyboard
                          ;  data allows us to handle every possible keystroke
                          ;  combination there is.
  ;BufferSize      EQU  64 ;Size of Scan Code Buffer
  BufferSize      EQU  96 ;Size of Scan Code Buffer
  UserTblEntries  EQU 100 ;Number of entries in User-defined USB to Scancode
                          ;  Translation Table
  UserSysEntries  EQU  16 ;Number of entries in User-defined System to Scancode
                          ;  Translation Table

  ;----------------------------------------------------------------------------
  ;Port 64h (Keyboard Controller) Bit Masks
  ;----------------------------------------------------------------------------
  P64OutBuffFull   EQU 01h ;Output Buffer Full (Port 60 has data for system)
  P64InBuffFull    EQU 02h ;Input Buffer Full (Port 60/64 has data for Kbd)
  P64SelfTestOK    EQU 04h ;Self-Test OK
  P64DataIsCommand EQU 08h ;Data is Command (Port 64h), not Data (Port 60h)
  P64KbdInhibit    EQU 10h ;Keyboard Locked/Inhibited
  P64TxTimeout     EQU 20h ;Transmit Timeout
  P64RxTimeout     EQU 40h ;Receive Timeout
  P64ParityError   EQU 80h ;Parity Error

  ;----------------------------------------------------------------------------
  ;Values to write to Port 64h, followed by reading/writing the KCCB
  ;  (Keyboard Controller Command Byte) from Port 60h.
  ;----------------------------------------------------------------------------
  KCCBRead  EQU 20h ;Tells Controller to place KCCB in Port 60h to Read
  KCCBWrite EQU 60h ;Tells Controller to read KCCB byte from Port 60h

  ;----------------------------------------------------------------------------
  ;Default Delay and Repeat Rate Values
  ;The "Codes" are the values set and returned by the BIOS Functions (Int 16h)
  ;The "Factors" are the actual Countdown Timers we use inside the Program
  ;The Keyboard Interrupt Rate is 100Hz, so the Factors multiplied by 10
  ;  will give milliseconds
  ;----------------------------------------------------------------------------
  DefDelayCode    EQU 01h ;Default = 500ms
  DefRepeatCode   EQU 0Ch ;Default = 10cps
  DefDelayFactor  EQU 50  ;Default Delay factor = 500ms
  DefRepeatFactor EQU 10  ;Default Repeat Rate  = 100ms (10 keystrokes/second)


;==============================================================================
;Keyboard BIOS Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Keyboard Data Stored at 0040:0017h
  ;----------------------------------------------------------------------------
  BIOS17RShiftP    EQU 01h ;Right Shift Pressed
  BIOS17LShiftP    EQU 02h ;Left Shift Pressed
  BIOS17EitherCtlP EQU 04h ;Either Control Pressed
  BIOS17EitherAltP EQU 08h ;Either Alt Pressed
  BIOS17ScrLockA   EQU 10h ;Scroll Lock Active
  BIOS17NumLockA   EQU 20h ;Num Lock Active
  BIOS17CapLockA   EQU 40h ;Caps Lock Active
  BIOS17InsertA    EQU 80h ;Insert Active

  BIOS17ShiftKeysMask EQU BIOS17RShiftP+BIOS17LShiftP+BIOS17EitherCtlP+BIOS17EitherAltP

  ;----------------------------------------------------------------------------
  ;Keyboard Data Stored at 0040:0018h
  ;----------------------------------------------------------------------------
  BIOS18LeftCtlP EQU 01h ;Left Control Pressed
  BIOS18LeftAltP EQU 02h ;Left Alt Pressed
  BIOS18SysReqP  EQU 04h ;Sys Req Pressed
  BIOS18PauseA   EQU 08h ;Pause State Active
  BIOS18ScrLockP EQU 10h ;Scroll Lock Pressed
  BIOS18NumLockP EQU 20h ;Num Lock Pressed
  BIOS18CapLockP EQU 40h ;Caps Lock Pressed
  BIOS18InsertP  EQU 80h ;Insert Pressed

  ;----------------------------------------------------------------------------
  ;Keyboard Data Stored at 0040:0096h
  ;----------------------------------------------------------------------------
  BIOS96E1LastTime   EQU 01h ;Last Code Read was E1h (225 - Pause)
  BIOS96E0LastTime   EQU 02h ;Last Code Read was E0h (224 - Extended Keys)
  BIOS96RightCtlP    EQU 04h ;Right Control Pressed
  BIOS96RightAltP    EQU 08h ;Right Alt Pressed
  BIOS96EnhancedKB   EQU 10h ;Enhanced Keyboard Installed
  BIOS96ForceNumLk   EQU 20h ;Force NumLock if Read-ID and Enhanced Keyboard
  BIOS961of2LastTime EQU 40h ;Last Code Read was first of two ID Codes (Pause)
  BIOS96ReadIDInProg EQU 80h ;Read-ID in progress

  ;----------------------------------------------------------------------------
  ;Keyboard Data Stored at 0040:0097h
  ;----------------------------------------------------------------------------
  BIOS97ScrLockLED EQU 01h ;Scroll Lock LED
  BIOS97NumLockLED EQU 02h ;Num Lock LED
  BIOS97CapLockLED EQU 04h ;Caps Lock LED
  BIOS97Reserved0  EQU 08h ;Reserved (0)
  BIOS97AckRcvd    EQU 10h ;ACK Received from Keyboard
  BIOS97ResendRcvd EQU 20h ;RESEND Received from Keyboard
  BIOS97LEDUpdate  EQU 40h ;LED Update in Progress
  BIOS97TxError    EQU 80h ;Keyboard Transmit Error Flag


;==============================================================================
;USB Keyboard Shift Masks
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Masks for Shift-Key bits in USB Shift Status Byte (KeybData[0])
  ;----------------------------------------------------------------------------
  USBLeftCtrlMask    EQU 01h
  USBRightCtrlMask   EQU 10h
  USBEitherCtrlMask  EQU USBLeftCtrlMask+USBRightCtrlMask
  USBLeftShiftMask   EQU 02h
  USBRightShiftMask  EQU 20h
  USBEitherShiftMask EQU USBLeftShiftMask+USBRightShiftMask
  USBLeftAltMask     EQU 04h
  USBRightAltMask    EQU 40h
  USBEitherAltMask   EQU USBLeftAltMask+USBRightAltMask
  USBLeftWinMask     EQU 08h
  USBRightWinMask    EQU 80h
  USBEitherWinMask   EQU USBLeftWinMask+USBRightWinMask
  USBAnyShiftsMask   EQU -1

  ;----------------------------------------------------------------------------
  ;Masks for Report Byte sent to Keyboard to control LEDs
  ;----------------------------------------------------------------------------
  LEDNumLockMask    EQU 01h ;Mask to turn on NumLock LED
  LEDCapsLockMask   EQU 02h ;Mask to turn on CapsLock LED
  LEDScrollLockMask EQU 04h ;Mask to turn on ScrollLock LED
  LEDComposeMask    EQU 08h ;Mask to turn on Compose LED
  LEDKanaMask       EQU 10h ;Mask to turn on Kana LED

  ;----------------------------------------------------------------------------
  ;Scan Codes for Legacy Keyboards
  ;----------------------------------------------------------------------------
  ScanCodeEscape      EQU   1 ;Escape
  ScanCode1           EQU   2 ;1!
  ScanCode2           EQU   3 ;2@
  ScanCode3           EQU   4 ;3#
  ScanCode4           EQU   5 ;4$
  ScanCode5           EQU   6 ;5%
  ScanCode6           EQU   7 ;6^
  ScanCode7           EQU   8 ;7&
  ScanCode8           EQU   9 ;8*
  ScanCode9           EQU  10 ;9(
  ScanCode0           EQU  11 ;0)
  ScanCodeMinus       EQU  12 ;-_
  ScanCodeEquals      EQU  13 ;=+
  ScanCodeBackSpace   EQU  14 ;BackSpace
  ScanCodeTab         EQU  15 ;Tab
  ScanCodeQ           EQU  16 ;Qq
  ScanCodeW           EQU  17 ;Ww
  ScanCodeE           EQU  18 ;Ee
  ScanCodeR           EQU  19 ;Rr
  ScanCodeT           EQU  20 ;Tt
  ScanCodeY           EQU  21 ;Yy
  ScanCodeU           EQU  22 ;Uu
  ScanCodeI           EQU  23 ;Ii
  ScanCodeO           EQU  24 ;Oo
  ScanCodeP           EQU  25 ;Pp
  ScanCodeLBracket    EQU  26 ;[{
  ScanCodeRBracket    EQU  27 ;]}
  ScanCodeEnter       EQU  28 ;Enter
  ScanCodeControl     EQU  29 ;(Left) Control
  ScanCodeA           EQU  30 ;Aa
  ScanCodeS           EQU  31 ;Ss
  ScanCodeD           EQU  32 ;Dd
  ScanCodeF           EQU  33 ;Ff
  ScanCodeG           EQU  34 ;Gg
  ScanCodeH           EQU  35 ;Hh
  ScanCodeJ           EQU  36 ;Jj
  ScanCodeK           EQU  37 ;Kk
  ScanCodeL           EQU  38 ;Ll
  ScanCodeSemiColon   EQU  39 ;;:
  ScanCodeQuote       EQU  40 ;'"
  ScanCodeTilde       EQU  41 ;`~
  ScanCodeLShift      EQU  42 ;Left Shift
  ScanCodeBackSlash   EQU  43 ;\|
  ScanCodeZ           EQU  44 ;Zz
  ScanCodeX           EQU  45 ;Xx
  ScanCodeC           EQU  46 ;Cc
  ScanCodeV           EQU  47 ;Vv
  ScanCodeB           EQU  48 ;Bb
  ScanCodeN           EQU  49 ;Nn
  ScanCodeM           EQU  50 ;Mm
  ScanCodeComma       EQU  51 ;,<
  ScanCodePeriod      EQU  52 ;.>
  ScanCodeSlash       EQU  53 ;/?
  ScanCodeRShift      EQU  54 ;Right Shift
  ScanCodeGreyStar    EQU  55 ;KeyPad * (also PrtScr)
  ScanCodeAlt         EQU  56 ;(Left) Alt
  ScanCodeSpace       EQU  57 ;Space Bar
  ScanCodeCapsLock    EQU  58 ;Caps Lock
  ScanCodeF1          EQU  59 ;F1
  ScanCodeF2          EQU  60 ;F2
  ScanCodeF3          EQU  61 ;F3
  ScanCodeF4          EQU  62 ;F4
  ScanCodeF5          EQU  63 ;F5
  ScanCodeF6          EQU  64 ;F6
  ScanCodeF7          EQU  65 ;F7
  ScanCodeF8          EQU  66 ;F8
  ScanCodeF9          EQU  67 ;F9
  ScanCodeF10         EQU  68 ;F10
  ScanCodeNumLock     EQU  69 ;Numbers Lock
  ScanCodeScrollLock  EQU  70 ;Scroll Lock
  ScanCodeHome        EQU  71 ;Home
  ScanCodeUp          EQU  72 ;Up Arrow
  ScanCodePageUp      EQU  73 ;Page Up
  ScanCodeGreyMinus   EQU  74 ;KeyPad -
  ScanCodeLeft        EQU  75 ;Left Arrow
  ScanCodeGrey5       EQU  76 ;Grey 5
  ScanCodeRight       EQU  77 ;Right Arrow
  ScanCodeGreyPlus    EQU  78 ;KeyPad +
  ScanCodeEnd         EQU  79 ;End
  ScanCodeDown        EQU  80 ;Down Arrow
  ScanCodePageDown    EQU  81 ;Page Down
  ScanCodeInsert      EQU  82 ;Insert
  ScanCodeDelete      EQU  83 ;Delete
  ScanCodeSysReq      EQU  84 ;SysReq
  ScanCodeKey102      EQU  86 ;Non-US \| (102nd Key on 102-Key Keyboard)
  ScanCodeF11         EQU  87 ;F11
  ScanCodeF12         EQU  88 ;F12
;Scancodes below this line are all prefixed by 224
  ScanCodeLWindows    EQU  91 ;Left Windows (Left GUI)
  ScanCodeRWindows    EQU  92 ;Right Windows (Right GUI)
  ScanCodeMouseMenu   EQU  93 ;Mouse Menu (Application)
;Scancodes below this line are fairly common on Microsoft Multimedia Keyboards
;  They are all prefixed by 224
  ScanCodeMessenger   EQU   5 ;Messenger or Files
  ScanCodeRedo        EQU   7 ;Redo (maybe on F3)
  ScanCodeUndo        EQU   8 ;Undo (maybe on F2)
  ScanCodeAppLeft     EQU   9 ;Application Left
  ScanCodePaste       EQU  10 ;Paste
  ScanCodeScrollUp    EQU  11 ;Scroll Up Normal
  ScanCodePrevTrack   EQU  16 ;Previous Track
  ScanCodeScrollUpF1  EQU  17 ;Scroll Up Fast
  ScanCodeScrollUpF2  EQU  18 ;Scroll Up Faster
  ScanCodeWord        EQU  19 ;Word
  ScanCodeExcel       EQU  20 ;Excel
  ScanCodeCalendar    EQU  21 ;Calendar
  ScanCodeLogOff      EQU  22 ;Log Off
  ScanCodeCut         EQU  23 ;Cut
  ScanCodeCopy        EQU  24 ;Copy
  ScanCodeNextTrack   EQU  25 ;Next Track
  ScanCodeAppRight    EQU  30 ;Application Right
  ScanCodeScrollUpF3  EQU  31 ;Scroll Up Fastest
  ScanCodeMute        EQU  32 ;Mute
  ScanCodeCalculator  EQU  33 ;Calculator
  ScanCodePlayPause   EQU  34 ;Play/Pause
  ScanCodeSpell       EQU  35 ;Spell (on F10)
  ScanCodeStopMedia   EQU  36 ;Stop Media
  ScanCodeVolumeDown  EQU  46 ;Volume Down
  ScanCodeVolumeUp    EQU  48 ;Volume Up
  ScanCodeWebHome     EQU  50 ;Web/Home
  ScanCodeHelp        EQU  59 ;Help (on F1)
  ScanCodeMusicOffic  EQU  60 ;My Music or Office Home (on F2)
  ScanCodeTaskPane    EQU  61 ;Task Pane (on F3)
  ScanCodeNew         EQU  62 ;New (on F4)
  ScanCodeOpen        EQU  63 ;Open (on F5)
  ScanCodeClose       EQU  64 ;Close (on F6)
  ScanCodeReply       EQU  65 ;Reply (on F7)
  ScanCodeMailFwd     EQU  66 ;Fwd (on F8) E-Mail
  ScanCodeSend        EQU  67 ;Send (on F9)
  ScanCodeSave        EQU  87 ;Save (on F11)
  ScanCodePrint       EQU  88 ;Print (on F12)
  ScanCodePower       EQU  94 ;Power
  ScanCodeSleep       EQU  95 ;Sleep
  ScanCodeWakeup      EQU  99 ;Wake Up
  ScanCodeMyPictures  EQU 100 ;My Pictures
  ScanCodeSearch      EQU 101 ;Search
  ScanCodeFavorites   EQU 102 ;Favorites
  ScanCodeRefresh     EQU 103 ;Refresh
  ScanCodeStopInet    EQU 104 ;Stop Internet
  ScanCodeForward     EQU 105 ;Forward
  ScanCodeBack        EQU 106 ;Back
  ScanCodeMyComputer  EQU 107 ;My Computer
  ScanCodeMail        EQU 108 ;Mail
  ScanCodeMedia       EQU 109 ;Media
;Scancodes below this line are also on Microsoft Keyboards,
;  but are "illegal" because they are > 128!
;  They are all prefixed by 224
  ScanCodeScrollDn    EQU 139 ;Scroll Down Normal (illegal)
  ScanCodeScrollDnF1  EQU 145 ;Scroll Down Fast (illegal)
  ScanCodeScrollDnF2  EQU 146 ;Scroll Down Faster (illegal)
  ScanCodeScrollDnF3  EQU 159 ;Scroll Down Fastest (illegal)


;==============================================================================
;INT 16h Extended Functions Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Value in DX during the Install Check Function Calls
  ;----------------------------------------------------------------------------
  InstallCheckDX EQU 1B1Bh

  ;----------------------------------------------------------------------------
  ;Version number of the API this program uses, in BCD
  ;  (returned in DX after an Install Check Function)
  ;----------------------------------------------------------------------------
  Int16APIVer EQU 0005h

  ;----------------------------------------------------------------------------
  ;Error Codes (returned in AX for "bad" calls)
  ;----------------------------------------------------------------------------
  I16ErrNone        EQU 0 ;No Error
  I16ErrBadFunction EQU 1 ;Bad Function number (in AL)
  I16ErrBadCode     EQU 2 ;Bad Code (in DL/DX)
  I16ErrRlsNoPress  EQU 3 ;Send Release with no Press
  I16ErrDblPress    EQU 4 ;Double Press (key already being pressed)
  I16ErrBufferFull  EQU 5 ;Buffer is Full (too many pending keystrokes already)

  ;----------------------------------------------------------------------------
  ;Code Flags used internally to differentiate between different types of calls
  ;----------------------------------------------------------------------------
  CodeFlagUSBCode  EQU 00h ;Is USB Key Code
  CodeFlagSysCode  EQU 01h ;Is System Key Code
  CodeFlagScanCode EQU 02h ;Is Scan Code
  CodeFlagPress    EQU 10h ;Is Press
  CodeFlagRePress  EQU 20h ;Is Press or RePress (Internal)
  CodeFlagRelease  EQU 40h ;Is Release
  CodeFlagPressRls EQU 80h ;Is Press/Release


;==============================================================================
;USB Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Maximum number of Devices we can control
  ;----------------------------------------------------------------------------
  MaxDevices EQU 4

  ;----------------------------------------------------------------------------
  ;Maximum number of entries in Bad (incompatible) Device Table
  ;----------------------------------------------------------------------------
  MaxBadDevices EQU 8

  ;----------------------------------------------------------------------------
  ;General
  ;----------------------------------------------------------------------------
  Int14RequestSize EQU 64 ;Size of Int 14 USB Request Data Structure

  ;----------------------------------------------------------------------------
  ;Maximum Descriptor Sizes
  ;----------------------------------------------------------------------------
  MaxDescriptorSize EQU 512 ;Max size of Device/Config/HID Descriptor
  MaxReportSize     EQU 600 ;Max size of Report Descriptor

  ;----------------------------------------------------------------------------
  ;USB Descriptor Types
  ;----------------------------------------------------------------------------
  DescrTypeDevice    EQU 01h ;Device
  DescrTypeConfig    EQU 02h ;Configuration
  DescrTypeString    EQU 03h ;String
  DescrTypeInterface EQU 04h ;Interface
  DescrTypeEndPoint  EQU 05h ;EndPoint
  DescrTypeDvcQual   EQU 06h ;Device Qualifier
  DescrTypeOtherSpd  EQU 07h ;Other Speed Configuration
  DescrTypeIntfPower EQU 08h ;Interface Power
  DescrTypeOnTheGo   EQU 09h ;On-the-Go
  DescrTypeDebug     EQU 0Ah ;Debug
  DescrTypeIntfAssoc EQU 0Bh ;Interface Association
  ;Types 12 - 17 (0Ch - 11h) are added for Wireless USB
  DescrTypeWSecurity EQU 0Ch ;Wireless USB Security
  DescrTypeWKey      EQU 0Dh ;Wireless USB Key
  DescrTypeWEncrType EQU 0Eh ;Wireless USB Encryption Type
  DescrTypeWBOS      EQU 0Fh ;Wireless USB Binary-device Object Store
  DescrTypeWDvcCap   EQU 10h ;Wireless USB Device Capability
  DescrTypeWEndPtCmp EQU 11h ;Wireless USB Endpoint Companion

  ;HID Class-Specific Descriptor Types
  DescrTypeHID         EQU 21h ;Human Interface Device
  DescrTypeHIDReport   EQU 22h ;Report (from HID)
  DescrTypeHIDPhysical EQU 23h ;Physical Descriptor (from HID)

  ;----------------------------------------------------------------------------
  ;Values in SRRequest for HID Devices
  ;----------------------------------------------------------------------------
  HIDRQGetReport   EQU  1 ;Get Report
  HIDRQGetIdle     EQU  2 ;Get Idle Factor
  HIDRQGetProtocol EQU  3 ;Get Protocol Type
  HIDRQSetReport   EQU  9 ;Set Report
  HIDRQSetIdle     EQU 10 ;Set Idle Factor
  HIDRQSetProtocol EQU 11 ;Set Protocol Type

  ;----------------------------------------------------------------------------
  ;Data for GetReport/SetReport
  ;----------------------------------------------------------------------------
  HIDReportTypeNone    EQU 0 ;None
  HIDReportTypeInput   EQU 1 ;Input
  HIDReportTypeOutput  EQU 2 ;Output
  HIDReportTypeFeature EQU 3 ;Feature

  ;----------------------------------------------------------------------------
  ;Data for GetProtocol/SetProtocol
  ;----------------------------------------------------------------------------
  HIDProtocolBoot   EQU 0 ;Boot Protocol
  HIDProtocolReport EQU 1 ;Report Protocol

  ;----------------------------------------------------------------------------
  ;USB-Defined Device and Interface Classes, SubClasses, and Protocols
  ;----------------------------------------------------------------------------
  DvcClassNone        EQU  0 ;Device Class = None
  DvcSubClassNone     EQU  0 ;Device SubClass = None
  DvcProtocolNone     EQU  0 ;Device Protocol = None
  IntfClassHID        EQU  3 ;Interface Class = HID (Human Interface Device)
  IntfSubClassNone    EQU  0 ;Interface SubClass = None
  IntfSubClassAny     EQU -1 ;Interface SubClass = Any
  IntfSubClassHIDBoot EQU  1 ;Interface SubClass = Boot
  IntfProtocolNone    EQU  0 ;Interface SubClass = None
  IntfProtocolAny     EQU -1 ;Interface SubClass = Any
  IntfProtocolHIDKeyb EQU  1 ;Interface Protocol = Keyboard

  ;----------------------------------------------------------------------------
  ;Possible Error Codes to return to calling program on completion of TD
  ;----------------------------------------------------------------------------
  TDStsOK             EQU 0000h ;ACK Received (TD completed OK / no errors)
  TDStsNAKReceived    EQU 0001h ;NAK Received
  TDStsStalled        EQU 0002h ;TD is Stalled
  TDStsTimeout        EQU 0004h ;TD has timed out (Bulk/Control)
  TDStsOverDue        EQU 0008h ;TD is OverDue (Int/Isoch)
  TDStsShortPacket    EQU 0010h ;TD Short Packet Detected
  TDStsBabbleDetected EQU 0020h ;Babble Detected
  TDStsCRCTOReceived  EQU 0040h ;CRC/TimeOut Error Received
  TDStsBitStuffError  EQU 0080h ;Rx Data contained > 6 ones in a row
  TDStsDataBuffErr    EQU 0100h ;Data Buffer Error
  TDStsControlSetup   EQU 1000h ;Error actually occurred during Control Setup
  TDStsDvcRemoved     EQU 2000h ;Device removed while TD was in progress
  TDStsLargeCallErr   EQU 8000h ;Error during Large Call

  ;----------------------------------------------------------------------------
  ;Statuses sent by Host to USB Device Owners
  ;----------------------------------------------------------------------------
  ;Device Connect/Disconnect
  OwnerCallNewDvc   EQU 0001h ;A new Matching Device has been attached
  OwnerCallDvcDisc  EQU 0002h ;Registered Device has been disconnected
  OwnerCallDvc0Disc EQU 0003h ;Matching Unregistered Device Disconnected
  OwnerCallDontLook EQU 0007h ;Stop Looking for New Devices for ~5 seconds
  ;Device Enable/Disable/Reset/Suspend/Resume/Power
  OwnerCallDvcEnable   EQU 0008h ;Device Enabled
  OwnerCallDvcDisable  EQU 0009h ;Device Disabled
  OwnerCallDvcReset    EQU 000Ah ;Device Resetting
  OwnerCallDvcSuspend  EQU 000Bh ;Device Suspended
  OwnerCallDvcResume   EQU 000Ch ;Device Resumed
  OwnerCallDvcPwrOn    EQU 000Dh ;Device Power On
  OwnerCallDvcPwrOff   EQU 000Eh ;Device Power Off
  OwnerCallDvcPwrReset EQU 000Fh ;Device Power Reset
  ;Host Connect/Disconnect/Error
  OwnerCallNewHost     EQU 0011h ;A new Host Driver has been Installed
  OwnerCallHostDisc    EQU 0012h ;An existing Host Driver has been Uninstalled
  OwnerCallHostHWErr   EQU 0017h ;Host System/Processor Error (Host will Reset)
  ;Host Run/Stop/Reset/Suspend/Resume
  OwnerCallHostRun     EQU 0018h ;Host Running
  OwnerCallHostStop    EQU 0019h ;Host Stopped
  OwnerCallHostReset   EQU 001Ah ;Host Reset
  OwnerCallHostSuspend EQU 001Bh ;Host Suspended
  OwnerCallHostResume  EQU 001Ch ;Host Resumed
  OwnerCallHostDebug   EQU 001Dh ;Host in Debug Mode
  OwnerCallHostSST     EQU 001Eh ;Host Single-Stepped
  ;Timing Changes
  OwnerCallTimingChg   EQU 0021h ;Timing Change on Host
  ;Upstream Device Changes
  OwnerCallDvcDiscUS     EQU (OwnerCallDvcDisc OR 0080h)     ;Dvc Disc Upstream
  OwnerCallDvcEnableUS   EQU (OwnerCallDvcEnable OR 0080h)   ;Dvc Enable Upstream
  OwnerCallDvcDisableUS  EQU (OwnerCallDvcDisable OR 0080h)  ;Dvc Disable Upstream
  OwnerCallDvcResetUS    EQU (OwnerCallDvcReset OR 0080h)    ;Dvc Reset Upstream
  OwnerCallDvcSuspendUS  EQU (OwnerCallDvcSuspend OR 0080h)  ;Dvc Suspend Upstream
  OwnerCallDvcResumeUS   EQU (OwnerCallDvcResume OR 0080h)   ;Dvc Resume Upstream
  OwnerCallDvcPwrOnUS    EQU (OwnerCallDvcPwrOn OR 0080h)    ;Dvc PwrOn Upstream
  OwnerCallDvcPwrOffUS   EQU (OwnerCallDvcPwrOff OR 0080h)   ;Dvc PwrOff Upstream
  OwnerCallDvcPwrResetUS EQU (OwnerCallDvcPwrReset OR 0080h) ;Dvc PwrReset Upstream


;==============================================================================
;USB Report Descriptor Related
;  HID Reports Start with a 1-byte Tag, followed by 0 or more bytes of Data
;  Bits 0-1 are actual size (0-3 bytes of data following the Tag)
;  Bits 2-3 are Tag Type: 0h = Main, 4h = Global, 8h = Local, Ch = Reserved
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Miscellaneous
  ;----------------------------------------------------------------------------
  RptTagLongData EQU 00FCh ;Long Data Item (more than 3 bytes)
                           ;Lower 2 bits are always 10h (Size of 2)
                           ;Next byte is Actual Data Size (0-255)
                           ;Next Byte is Tag (Description)
                           ;Followed by up to 255 bytes of "real" data

  ;----------------------------------------------------------------------------
  ;Main
  ;----------------------------------------------------------------------------
  RptTagInput              EQU   80h ;Input
  RPtTagOutput             EQU   90h ;Output
  RptTagFeature            EQU  0B0h ;Feature
    ;These apply to Input, Output, and Feature
    RptMainIOFConstant     EQU   01h ;Constant
     RptMainIOFData        EQU   00h ; Data
    RptMainIOFVariable     EQU   02h ;Variable
     RptMainIOFArray       EQU   00h ; Array
    RptMainIOFRelative     EQU   04h ;Relative
     RptMainIOFAbsolute    EQU   00h ; Absolute
    RptMainIOFWrap         EQU   08h ;Wrap
     RptMainIOFNoWrap      EQU   00h ; No Wrap
    RptMainIOFNonLinear    EQU   10h ;Non-Linear
     RptMainIOFLinear      EQU   00h ; Linear
    RptMainIOFNoPrefer     EQU   20h ;No Preferred State
     RptMainIOFPrefer      EQU   00h ; Preferred State
    RptMainIOFNull         EQU   40h ;Null State
     RptMainIOFNoNull      EQU   00h ; No Null State
    RptMainIOFVolatile     EQU   80h ;Volatile
     RptMainIOFNonVolatile EQU   00h ; Non-Volatile
    RptMainIOFBuffered     EQU  100h ;Buffered Bytes
     RptMainIOFBitField    EQU  000h ; Bit-Field

  RptTagCollection         EQU  0A0h ;Collection
    RptMainColPhysical     EQU   00h ;Physical (Group of Axes)
    RptMainColApplication  EQU   01h ;Application (Mouse/Keyboard)
    RptMainColLogical      EQU   02h ;Logical (interrelated Data)

  RptTagEndCollection      EQU  0C0h ;End Collection

  ;----------------------------------------------------------------------------
  ;Global
  ;----------------------------------------------------------------------------
  RptTagUsagePage          EQU   04h ;Usage Page
    RptGlbUPGenericDeskTop EQU   01h ;Generic Desktop
      RptGDPointer         EQU   01h ;Pointing Device
      RptGDMouse           EQU   02h ;Mouse
      ;03h = Reserved
      RptGDJoystick        EQU   04h ;Joystick
      RptGDGamePad         EQU   05h ;GamePad
      RptGDKeyboard        EQU   06h ;Keyboard
      RptGDKeyPad          EQU   07h ;KeyPad
      RptGDMultiAxisCtl    EQU   08h ;Multi-Axis Controller
       ;09h - 2Fh = Reserved
      RptGDXAxis           EQU   30h ;X-axis
      RptGDYAxis           EQU   31h ;Y-axis
      RptGDZAxis           EQU   32h ;Z-axis
      RptGDRotateX         EQU   33h ;Rotation around X-axis
      RptGDRotateY         EQU   34h ;Rotation around Y-axis
      RptGDRotateZ         EQU   35h ;Rotation around Z-axis
      RptGDSlider          EQU   36h ;Slider
      RptGDDial            EQU   37h ;Dial
      RptGDWheel           EQU   38h ;Wheel
      RptGDHatSwitch       EQU   39h ;Hat-Switch
      RptGDCountedBuff     EQU   3Ah ;Counted Buffer
      RptGDByteCount       EQU   3Bh ;Byte Count
      RptGDMotionWakeup    EQU   3Ch ;Wakeup on Motion
      RptGDStart           EQU   3Dh ;Start
      RptGDSelect          EQU   3Eh ;Select
      ;3Fh Reserved
      RptGDVectorX         EQU   40h ;X-Axis Vector
      RptGDVectorY         EQU   41h ;Y-Axis Vector
      RptGDVectorZ         EQU   42h ;Z-Axis Vector
      RptGDVectorBRX       EQU   43h ;X-Axis Vector, Relative to the Body
      RptGDVectorBRY       EQU   44h ;Y-Axis Vector, Relative to the Body
      RptGDVectorBRZ       EQU   45h ;Z-Axis Vector, Relative to the Body
      RptGDVectorNoD       EQU   46h ;Non-Directional Vector (e.g., Tempurature)
      ;47h = ??
      RptGDResMult         EQU   48h ;Resolution Multiplier
      ;49h-7Fh = Reserved
      RptGDSysCtl          EQU   80h ;System Control
      RptGDSysPowerDown    EQU   81h ;System Power Down
      RptGDSysSleep        EQU   82h ;System Sleep
      RptGDSysWakeUp       EQU   83h ;System Wake Up
      RptGDSysMenuContext  EQU   84h ;System Menu Context
      RptGDSysMenuMain     EQU   85h ;System Menu Main
      RptGDSysMenuApp      EQU   86h ;System Menu Application
      RptGDSysMenuHelp     EQU   87h ;System Menu Help
      RptGDSysMenuExit     EQU   88h ;System Menu Exit
      RptGDSysMenuSelect   EQU   89h ;System Menu Select
      RptGDSysMenuRight    EQU   8Ah ;System Menu Right
      RptGDSysMenuLeft     EQU   8Bh ;System Menu Left
      RptGDSysMenuUp       EQU   8Ch ;System Menu Up
      RptGDSysMenuDown     EQU   8Dh ;System Menu Down
      RptGDSysColdStart    EQU   8Eh ;System Cold Restart
      RptGDSysWarmStart    EQU   8Fh ;System Warm Restart
      RptGDDPadUp          EQU   90h ;D-Pad Up
      RptGDDPadDown        EQU   91h ;D-Pad Down
      RptGDDPadRight       EQU   92h ;D-Pad Right
      RptGDDPadLeft        EQU   93h ;D-Pad Left
      ;94h - 9Fh = Reserved
      RptGDSysDock         EQU  0A0h ;System Dock
      RptGDSysUndock       EQU  0A1h ;System Undock
      RptGDSysSetup        EQU  0A2h ;System Setup
      RptGDSysBreak        EQU  0A3h ;System Break
      RptGDSysDbgBrk       EQU  0A4h ;System Debugger Break
      RptGDSysAppBrk       EQU  0A5h ;Application Break
      RptGDSysAppDbgBrk    EQU  0A6h ;Application Debugger Break
      RptGDSysMute         EQU  0A7h ;System Speaker Mute
      RptGDSysHibernate    EQU  0A8h ;System Hibernate
      ;A9h - AFh = Reserved
      RptGDSysDispInvt     EQU  0B0h ;System Display Invert
      RptGDSysDispInt      EQU  0B1h ;System Display Internal
      RptGDSysDispExt      EQU  0B2h ;System Display External
      RptGDSysDispBoth     EQU  0B3h ;System Display Both
      RptGDSysDispDual     EQU  0B4h ;System Display Dual
      RptGDSysDispTgl      EQU  0B5h ;System Display Toggle Internal/External
      RptGDSysDispSwap     EQU  0B6h ;System Display Swap Primary/Secondary
      RptGDSysDispAuto     EQU  0B7h ;System Display LCD Autoscale
      ;B8h - FFFFh = Reserved

    RptGlbUPSimulationCtl  EQU   02h ;Simulation Controls
    RptGlbUPVRCtl          EQU   03h ;Virtual Reality? Controls
    RptGlbUPSportCtl       EQU   04h ;Sport Controls
    RptGlbUPGameCtl        EQU   05h ;Game Controls
    ;06h = ?
    RptGlbUPKeyboard       EQU   07h ;Keyboard/Keypad (Usage Type = Selector)
      RptKbdErrorRollOver  EQU   01h ;Roll Over Error
      RptKbdErrorPOSTFail  EQU   02h ;Power On Self Test Failure
      RptKbdErrorUndefined EQU   03h ;Undefined Error
      RptKbdA              EQU   04h ;Aa
      RptKbdB              EQU   05h ;Bb
      RptKbdC              EQU   06h ;Cc
      RptKbdD              EQU   07h ;Dd
      RptKbdE              EQU   08h ;Ee
      RptKbdF              EQU   09h ;Ff
      RptKbdG              EQU   0Ah ;Gg
      RptKbdH              EQU   0Bh ;Hh
      RptKbdI              EQU   0Ch ;Ii
      RptKbdJ              EQU   0Dh ;Jj
      RptKbdK              EQU   0Eh ;Kk
      RptKbdL              EQU   0Fh ;Ll
      RptKbdM              EQU   10h ;Mm
      RptKbdN              EQU   11h ;Nn
      RptKbdO              EQU   12h ;Oo
      RptKbdP              EQU   13h ;Pp
      RptKbdQ              EQU   14h ;Qq
      RptKbdR              EQU   15h ;Rr
      RptKbdS              EQU   16h ;Ss
      RptKbdT              EQU   17h ;Tt
      RptKbdU              EQU   18h ;Uu
      RptKbdV              EQU   19h ;Vv
      RptKbdW              EQU   1Ah ;Ww
      RptKbdX              EQU   1Bh ;Xx
      RptKbdY              EQU   1Ch ;Yy
      RptKbdZ              EQU   1Dh ;Zz
      RptKbd1              EQU   1Eh ;1!
      RptKbd2              EQU   1Fh ;2@
      RptKbd3              EQU   20h ;3#
      RptKbd4              EQU   21h ;4$
      RptKbd5              EQU   22h ;5%
      RptKbd6              EQU   23h ;6^
      RptKbd7              EQU   24h ;7&
      RptKbd8              EQU   25h ;8*
      RptKbd9              EQU   26h ;9(
      RptKbd0              EQU   27h ;0)
      RptKbdEnter          EQU   28h ;Enter
      RptKbdEscape         EQU   29h ;Escape
      RptKbdBackSpace      EQU   2Ah ;BackSpace
      RptKbdTab            EQU   2Bh ;Tab/backTab
      RptKbdSpace          EQU   2Ch ;Space
      RptKbdMinus          EQU   2Dh ;-_
      RptKbdEquals         EQU   2Eh ;=+
      RptKbdLBracket       EQU   2Fh ;[{
      RptKbdRBracket       EQU   30h ;]}
      RptKbdBackSlash      EQU   31h ;\|
      RptKbdNonUSPound     EQU   32h ;Non-US #~
      RptKbdSemiColon      EQU   33h ;;:
      RptKbdQuote          EQU   34h ;'"
      RptKbdTilde          EQU   35h ;`~
      RptKbdComma          EQU   36h ;,<
      RptKbdPeriod         EQU   37h ;.>
      RptKbdSlash          EQU   38h ;/?
      RptKbdCapsLock       EQU   39h ;Caps Lock
      RptKbdF1             EQU   3Ah ;F1
      RptKbdF2             EQU   3Bh ;F2
      RptKbdF3             EQU   3Ch ;F3
      RptKbdF4             EQU   3Dh ;F4
      RptKbdF5             EQU   3Eh ;F5
      RptKbdF6             EQU   3Fh ;F6
      RptKbdF7             EQU   40h ;F7
      RptKbdF8             EQU   41h ;F8
      RptKbdF9             EQU   42h ;F9
      RptKbdF10            EQU   43h ;F10
      RptKbdF11            EQU   44h ;F11
      RptKbdF12            EQU   45h ;F12
      RptKbdPrintScreen    EQU   46h ;Print Screen/SysReq
      RptKbdScrollLock     EQU   47h ;Scroll Lock
      RptKbdPause          EQU   48h ;Pause/Break
      RptKbdGreyInsert     EQU   49h ;Grey Insert
      RptKbdGreyHome       EQU   4Ah ;Grey Home
      RptKbdGreyPageUp     EQU   4Bh ;Grey Page Up
      RptKbdGreyDelete     EQU   4Ch ;Grey Delete
      RptKbdGreyEnd        EQU   4Dh ;Grey End
      RptKbdGreyPageDown   EQU   4Eh ;Grey Page Down
      RptKbdGreyRight      EQU   4Fh ;Grey Right
      RptKbdGreyLeft       EQU   50h ;Grey Left
      RptKbdGreyDown       EQU   51h ;Grey Down
      RptKbdGreyUp         EQU   52h ;Grey Up
      RptKbdNumLock        EQU   53h ;Num Lock & Clear?
      RptKbdGreySlash      EQU   54h ;KeyPad /
      RptKbdGreyStar       EQU   55h ;KeyPad *
      RptKbdGreyMinus      EQU   56h ;KeyPad -
      RptKbdGreyPlus       EQU   57h ;KeyPad +
      RptKbdGreyEnter      EQU   58h ;KeyPad Enter
      RptKbdEnd            EQU   59h ;End & 1
      RptKbdDown           EQU   5Ah ;Down & 2
      RptKbdPageDown       EQU   5Bh ;PgDn & 3
      RptKbdLeft           EQU   5Ch ;Left & 4
      RptKbdGrey5          EQU   5Dh ;NumPad 5
      RptKbdRight          EQU   5Eh ;Right &6
      RptKbdHome           EQU   5Fh ;Home & 7
      RptKbdUp             EQU   60h ;Up & 8
      RptKbdPageUp         EQU   61h ;PgUp & 9
      RptKbdInsert         EQU   62h ;Ins & 0
      RptKbdDelete         EQU   63h ;Del & .
      RptKbdKey102         EQU   64h ;Non-US \| (102nd Key on 102-key Keyb)
      RptKbdMouseMenu      EQU   65h ;Mouse Menu (called "Application" in USB)
      RptKbdPower          EQU   66h ;Power
      RptKbdGreyEquals     EQU   67h ;KeyPad =
      RptKbdF13            EQU   68h ;F13
      RptKbdF14            EQU   69h ;F14
      RptKbdF15            EQU   6Ah ;F15
      RptKbdF16            EQU   6Bh ;F16
      RptKbdF17            EQU   6Ch ;F17
      RptKbdF18            EQU   6Dh ;F18
      RptKbdF19            EQU   6Eh ;F19
      RptKbdF20            EQU   6Fh ;F20
      RptKbdF21            EQU   70h ;F21
      RptKbdF22            EQU   71h ;F22
      RptKbdF23            EQU   72h ;F23
      RptKbdF24            EQU   73h ;F24
      RptKbdExecute        EQU   74h ;Execute
      RptKbdHelp           EQU   75h ;Help
      RptKbdMenu           EQU   76h ;Menu
      RptKbdSelect         EQU   77h ;Select
      RptKbdStopMedia      EQU   78h ;Stop Media
      RptKbdAgain          EQU   79h ;Again
      RptKbdUndo           EQU   7Ah ;Undo
      RptKbdCut            EQU   7Bh ;Cut
      RptKbdCopy           EQU   7Ch ;Copy
      RptKbdPaste          EQU   7Dh ;Paste
      RptKbdFind           EQU   7Eh ;Find
      RptKbdMute           EQU   7Fh ;Mute
      RptKbdVolumeUp       EQU   80h ;Volume Up
      RptKbdVolumeDown     EQU   81h ;Volume Down
      RptKbdLockingCapsLk  EQU   82h ;Locking Caps Lock
      RptKbdLockingNumLk   EQU   83h ;Locking Num Lock
      RptKbdLockingScrlLk  EQU   84h ;Locking Scroll Lock
      RptKbdGreyComma      EQU   85h ;KeyPad ,
      RptKbdGreyEquals2    EQU   86h ;KeyPad =
      RptKbdIntl1          EQU   87h ;International Keyboard 1
      RptKbdIntl2          EQU   88h ;International Keyboard 2
      RptKbdIntl3          EQU   89h ;International Keyboard 3
      RptKbdIntl4          EQU   8Ah ;International Keyboard 4
      RptKbdIntl5          EQU   8Bh ;International Keyboard 5
      RptKbdIntl6          EQU   8Ch ;International Keyboard 6
      RptKbdIntl7          EQU   8Dh ;International Keyboard 7
      RptKbdIntl8          EQU   8Eh ;International Keyboard 8
      RptKbdIntl9          EQU   8Fh ;International Keyboard 9
      RptKbdLang1          EQU   90h ;Language? 1
      RptKbdLang2          EQU   91h ;Language? 2
      RptKbdLang3          EQU   92h ;Language? 3
      RptKbdLang4          EQU   93h ;Language? 4
      RptKbdLang5          EQU   94h ;Language? 5
      RptKbdLang6          EQU   95h ;Language? 6
      RptKbdLang7          EQU   96h ;Language? 7
      RptKbdLang8          EQU   97h ;Language? 8
      RptKbdLang9          EQU   98h ;Language? 9
      RptKbdAltErase       EQU   99h ;Alternate Erase
      RptKbdSysRqAttention EQU   9Ah ;System Request/Attention
      RptKbdCancel         EQU   9Bh ;Cancel
      RptKbdClear          EQU   9Ch ;Clear
      RptKbdPrior          EQU   9Dh ;Prior
      RptKbdReturn         EQU   9Eh ;Return
      RptKbdSeparator      EQU   9Fh ;Separator
      RptKbdOut            EQU  0A0h ;Out
      RptKbdOper           EQU  0A1h ;Oper
      RptKbdClearAgain     EQU  0A2h ;Clear/Again
      RptKbdCRSelProps     EQU  0A3h ;CrSel/Props
      RptKbdExSel          EQU  0A4h ;ExSel
      RptKbdKP00           EQU  0B0h ;Keypad 00
      RptKbd000            EQU  0B1h ;Keypad 000
      RptKbdKPThousSep     EQU  0B2h ;Keypad Thousands Separator
      RptKbdKPDecSep       EQU  0B3h ;Keypad Decimal Separator
      RptKbdKPCurrUnit     EQU  0B4h ;Keypad Currency Unit
      RptKbdKPCurrSubUnit  EQU  0B5h ;Keypad Currency Sub-unit
      RptKbdKPLParen       EQU  0B6h ;Keypad (
      RptKbdKPRParen       EQU  0B7h ;Keypad )
      RptKbdKPLCBrkt       EQU  0B8h ;Keypad {
      RptKbdKPRCBrkt       EQU  0B9h ;Keypad }
      RptKbdKPTab          EQU  0BAh ;Keypad Tab
      RptKbdKPBkSp         EQU  0BBh ;Keypad Backspace
      RptKbdKPA            EQU  0BCh ;Keypad A
      RptKbdKPB            EQU  0BDh ;Keypad B
      RptKbdKPC            EQU  0BEh ;Keypad C
      RptKbdKPD            EQU  0BFh ;Keypad D
      RptKbdKPE            EQU  0C0h ;Keypad E
      RptKbdKPF            EQU  0C1h ;Keypad F
      RptKbdKPXor          EQU  0C2h ;Keypad XOR
      RptKbdKPExponent     EQU  0C3h ;Keypad ^
      RptKbdKPPercent      EQU  0C4h ;Keypad %
      RptKbdKPLArrow       EQU  0C5h ;Keypad <
      RptKbdKPRArrow       EQU  0C6h ;Keypad >
      RptKbdKPAnd          EQU  0C7h ;Keypad &
      RptKbdKPAndAnd       EQU  0C8h ;Keypad &&
      RptKbdKPOr           EQU  0C9h ;Keypad |
      RptKbdKPOrOr         EQU  0CAh ;Keypad ||
      RptKbdKPColon        EQU  0CBh ;Keypad :
      RptKbdKPPound        EQU  0CCh ;Keypad #
      RptKbdKPSpace        EQU  0CDh ;Keypad Space
      RptKbdKPAt           EQU  0CEh ;Keypad @
      RptKbdKPExclaim      EQU  0CFh ;Keypad !
      RptKbdKPMemStore     EQU  0D0h ;Keypad Memory Store
      RptKbdKPMemRecall    EQU  0D1h ;Keypad Memory Recall
      RptKbdKPMemClear     EQU  0D2h ;Keypad Memory Clear
      RptKbdKPMemAdd       EQU  0D3h ;Keypad Memory Add
      RptKbdKPMemSub       EQU  0D4h ;Keypad Memory Subtract
      RptKbdKPMemMul       EQU  0D5h ;Keypad Memory Multiply
      RptKbdKPMemDiv       EQU  0D6h ;Keypad Memory Divide
      RptKbdKPNegate       EQU  0D7h ;Keypad +/-
      RptKbdKPClear        EQU  0D8h ;Keypad Clear
      RptKbdKPClearEntry   EQU  0D9h ;Keypad Clear Entry
      RptKbdKPBinary       EQU  0DAh ;Keypad Binary
      RptKbdKPOctal        EQU  0DBh ;Keypad Octal
      RptKbdKPDecimal      EQU  0DCh ;Keypad Decimal
      RptKbdKPHex          EQU  0DDh ;Keypad Hexadecimal
      RptKbdLControl       EQU  0E0h ;Left Control
      RptKbdLShift         EQU  0E1h ;Left Shift
      RptKbdLAlt           EQU  0E2h ;Left Alt
      RptKbdLWindows       EQU  0E3h ;Left Windows (Left GUI)
      RptKbdRControl       EQU  0E4h ;Right Control
      RptKbdRShift         EQU  0E5h ;Right Shift
      RptKbdRAlt           EQU  0E6h ;Right Alt
      RptKbdRWindows       EQU  0E7h ;Right Windows (Right GUI)

    RptGlbUPLED            EQU   08h ;LEDs (Light Emitting Diodes)
      RptLEDNumLock        EQU   01h ;Num Lock
      RptLEDCapsLock       EQU   02h ;Caps Lock
      RptLEDScrollLock     EQU   03h ;Scroll Lock

    RptGlbUPButton         EQU   09h ;Buttons
    RptGlbUPOrdinal        EQU   0Ah ;Ordinal
    RptGlbUPConsumerDvc    EQU   0Ch ;Consumer Devices

  RptTagLogicalMin         EQU   14h ;Logical Minumum
  RptTagLogicalMax         EQU   24h ;Logical Maximum
  RptTagPhysicalMin        EQU   34h ;Physical Minimum
  RptTagPhysicalMax        EQU   44h ;Physical Maximum
  RptTagUnitExponent       EQU   54h ;Unit Exponent (base 10)
  RptTagUnit               EQU   64h ;Units

  RptTagReportSize         EQU   74h ;Size of Report Field in (bits)
  RptTagReportID           EQU   84h ;Report ID
  RptTagReportCount        EQU   94h ;Report Count
  RptTagPush               EQU  0A4h ;Push Global State Table onto the Stack
  RptTagPop                EQU  0B4h ;Pop Global State Table from the Stack

  ;----------------------------------------------------------------------------
  ;Local
  ;----------------------------------------------------------------------------
  RptTagUsage              EQU   08h ;Usage
  RptTagUsageMin           EQU   18h ;Usage Minimum
  RptTagUsageMax           EQU   28h ;Usage Maximum
  RptTagDesignatorIndex    EQU   38h ;Designator Index (Body Part)
  RptTagDesignatorMin      EQU   48h ;Designator Minimum
  RptTagDesignatorMax      EQU   58h ;Designator Maximum
  RptTagStringIndex        EQU   78h ;String Index
  RptTagStringMin          EQU   88h ;String Minimum
  RptTagStringMax          EQU   98h ;String Maximum
  RptTagDelimiter          EQU  0A8h ;1 = Open Set, 2 = Close Set


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;STRUCTURES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;==============================================================================
;TSR Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;This is a Structure to use at the beginning of Interrupt Routines in
  ;  TSR's.  Using this header, along with the appropriate code,
  ;  will allow the installation and removal of TSR's (actually,
  ;  the redirected interrupt vectors of a TSR) in any order.
  ;Note that the real Interrupt code MUST IMMEDIATELY follow this Header!!
  ;----------------------------------------------------------------------------
  IntHdr STRUC
    HdwreRst  DB      0CBh ;Hardware Reset Routine (CBh = RETF)
    CodeJmp   DW    010EBh ;Jump to real Interrupt Handler (JMP ENDS)
    OldVector DD        ?  ;Old interrupt Vector
    Signature DW    0424Bh ;Signature for this type of Interrupt routine
    EOIFlag   DB        0  ;=80h if we issue End-of-Interrupt, else 0
    HdwreJmp  DW    0F4EBh ;Jump to Hardware Reset Routine (JMP HdwreRst)
    FutureUse DB 7 DUP (0) ;Reserved for future use
   ENDS
  IntOfst EQU OFFSET CodeJmp ;Offset from beginning of our Structure


;==============================================================================
;DOS Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Program Segment Prefix
  ;----------------------------------------------------------------------------
  PSPStruc      STRUC
    PSPDOSExit     DW       20CDh ;Int 20h Call
    PSPNextSegment DW          ?  ;Segment of First Byte of Memory beyond Program
    PSPCPMCall5    DB   6 DUP (?) ;CPM Far Call 5
    PSPInt22Addr   DD          ?  ;Stored Int 22h Handler
    PSPInt23Addr   DD          ?  ;Stored Int 23h (Ctrl-Break) Handler
    PSPInt24Addr   DD          ?  ;Stored Int 23h (Critical Error) Handler
    PSPParentPSP   DW          ?  ;Segment of Parent PSP
    PSPJFT         DB  20 DUP (?) ;Job File Table (20 File Handles)
    PSPEnvirSeg    DW          ?  ;Environment Segment for PSP
    PSPSSSPOnEntry DD          ?  ;Processes SS:SP on Entry to last Int 21h Call
    PSPJFTSize     DW          ?  ;Number of entries in JFT (default = 20)
    PSPJFTPointer  DD          ?  ;Pointer to JFT (Default = PSP:0018h)
    PSPPreviousPSP DD          ?  ;Pointer to previous PSP (Default = FFFF:FFFF)
    PSPFiller1     DB  18 DUP (?) ;Misc stuff used by SHARE, Windows, etc.
                                  ;Memory Below here available to TSR!
    PSPFiller2     DB   2 DUP (?) ;Unused in DOS <= 6.00
    PSPInt21       DW       21CDh ;Int 21h Call
    PSPRETF        DB        0CBh ;RETF Call
    PSPFiller3     DB   9 DUP (?) ;Can be used to make Extended FCB from FCB1
    PSPFCB1        DB  16 DUP (?) ;First File Control Block
    PSPFCB2        DB  16 DUP (?) ;Second File Control Block
    PSPFiller4     DB   4 DUP (?) ;Unused
    PSPCmdLineLen  DB          ?  ;Command Line Length & DTA
    PSPCmdLine     DB 127 DUP (?) ;Command Line String
   ENDS
  PSPStrucSize EQU (TYPE PSPStruc) ;Should be 256 bytes

  ;----------------------------------------------------------------------------
  ;Memory Control Block
  ;----------------------------------------------------------------------------
  MCBStruc STRUC
    MCBID              DB        ?  ;Memory Control Block ID
      MCBIDValid      EQU       'M' ;Memory Block is Valid
      MCBIDLastInList EQU       'Z' ;Memory Block is Last in List
    MCBOwnerID         DW        ?  ;PSP Segment of Owner
                                    ;   0 = Owns Self (Free)
                                    ;   6 = DR-DOS XMS UMB
                                    ;   7 = DR-DOS Excluded Upper Memory (Hole)
                                    ;   8 = Belongs to DOS
                                    ;FFFx = 386Max
    MCBSize            DW        ?  ;Size in Paragraphs
    MCBFiller          DB 3 DUP (?) ;Filler
    MCBOwnerName       DB 8 DUP (?) ;Owner Name
   ENDS
  MCBStrucSize EQU (TYPE MCBStruc) ;Should be 16 bytes

  ;----------------------------------------------------------------------------
  ;Structure needed to Initialize DOS EXEC Function
  ;----------------------------------------------------------------------------
  ParamBlockStruc STRUC
    PBEnvirSegment   DW ? ;Environment Segment to use (0 = Copy Callers Segment)
    PBCmdTailPtr     DD ? ;Pointer to Command Tail
    PBFCB1Offset     DD ? ;Pointer to File Control Block #1
    PBFCB2Offset     DD ? ;Pointer to File Control Block #2
    PBSSSPOnReturn   DD ? ;Holds Childs Initial SS:SP on Return (if AL = 01)
    PBCSIPOnReturn   DD ? ;Holds Entry Point (CS:IP) on Return (if AL = 01)
   ENDS
  ParamBlockSize EQU (TYPE ParamBlockStruc) ;Size of EXEC Parameter Block

  ;----------------------------------------------------------------------------
  ;DTA (Disk Transfer Area) after Find First Matching File (INT 21h, Func 4Eh)
  ;The first several bytes of the DTA are DOS version specific, and
  ;  we don't care about that data anyway.  We only care about the data
  ;  that is documented and the same across all versions of DOS.
  ;----------------------------------------------------------------------------
  FindFirstStruc   STRUC            ;Find First Matching File
    FFVerSpecific     DB 21 DUP (0) ;DOS Version-specific Data
    FFAttribs         DB         ?  ;File Attributes
      FAttrReadOnly  EQU        01h ;Read-Only
      FAttrHidden    EQU        02h ;Hidden
      FAttrSystem    EQU        04h ;System
      FAttrVolume    EQU        08h ;Volume Label
      ;Bit 3 = Execute-only (Novell Netware)
      FAttrDirectory EQU        10h ;Directory
      FAttrArchive   EQU        20h ;Archive
      FAttrUnused    EQU        40h ;Unused
                                    ;DOS 3+ returns this bit set if file
                                    ;  is actually a character device
                                    ;DOS Window underneath Windows XP doesn't
      ;Bit 7 = Delete Pending (OpenDOS, NovellDOS)
      ;      = Shareable (Novell Netware)
   FFTime            DW         ?  ;File Creation Time
    FFDate            DW         ?  ;File Creation Date
    FFSize            DD         ?  ;File Size
    FFName            DB 13 DUP (?) ;ASCIIZ File Name & Extension
   ENDS

   FAttrToUse EQU FAttrHidden+FAttrSystem
     ;Attributes to use in DOS's Find First Matching File Function
     ;DOS ignores the Read-Only and and Archive bits, so they don't matter


;==============================================================================
;USB/Keyboard-Related
;==============================================================================

  ;------------------------------------------------------------------------------
  ;This Structure keeps track of individual keystrokes as they are pressed
  ;  and released, allowing us to control the Delay and Repeat rates
  ;  in software, rather than reprogramming the USB Keyboard.
  ;Among other things, this keeps track of the Delay and Repeat Rate
  ;  countdown timers.
  ;This will actually be a Sub-table inside the Table for each Keyboard.
  ;------------------------------------------------------------------------------
  USBKeyStruc      STRUC
    UKKeyCode         DB  ?  ;USB KeyCode (0 if empty table entry)
    UKFlags           DB  ?  ;Yes/No Flags
      UKFlagNewPress EQU 01h ;New Keystroke Press
      UKFlagPressed  EQU 02h ;Key is pressed again this time
                             ;  (need this to know when a key is released)
      UKFlagRelease  EQU 04h ;Need to Press and then immediately Release
      UKFlagSysCode  EQU 10h ;Key is a USB System Code, not a regular USB Code
      UKFlagScanCode EQU 20h ;Key is a ScanCode, not a USB Code
    UKTimer           DB  ?  ;Countdown timer for Delays between Repeats
                             ;  (Delay between first and second keystrokes)
    UKFiller          DB  ?  ;To align data at even addresses
   ENDS
  USBKeyStrucSize EQU (TYPE USBKeyStruc)

  ;----------------------------------------------------------------------------
  ;This structure keeps track of each of the several individual USB Devices
  ;----------------------------------------------------------------------------
  DeviceInfoStruc    STRUC
    DIFlags             DB         ?  ;Misc Yes/No Flags
      DIFlagInUse      EQU        01h ;This entry currently being used?
      DIFlagDisabled   EQU        02h ;This individual Device is Disabled
      DIFlagDisconnect EQU        04h ;Device in process of Disconnecting
    DIHostIndex         DB         ?  ;Host Index this Device is on
    DIDvcAddress        DB         ?  ;Device Address of Device
    DIEndPoint          DB         ?  ;End Point Number
    DIInterfaceNum      DB         ?  ;Interface number of Device (usually 0)
    DISysReportID       DB         ?  ;System Keys Report ID
    DISysLastTime       DB         ?  ;System Keys Data last time
    DILockStatusLT      DB         ?  ;LED Status last time through
    DIRegHandle         DW         ?  ;Handle Number of Owner Registry
    DIIntHandle         DW         ?  ;Handle number of Periodic Interrupt
   ;Report ID (probably not needed for a Keyboard, but allow for it anyway)
    DIReportID          DB         ?  ;Report ID (if needed)
    DIReportIDData      DB         ?  ;Report ID from Data (if provided)
                                      ;  MUST IMMEDIATELY precede DIRawData!!!
   ;Raw data
    DIRawData           DB MaxKeybDataSize DUP (0) ;Raw Device Data
   ;Sub-table to keep track of Individual Raw keys, Delays, and Repeats
    DIKeyCodes          DB (NumUSBKeys*USBKeyStrucSize) DUP (0)
    DIStsData           DB MaxKeybDataSize DUP (0) ;Raw Device Data for Status
   ENDS
  DeviceInfoStrucSize  EQU (TYPE DeviceInfoStruc)

  ;----------------------------------------------------------------------------
  ;This structure keeps track of Bad (incompatible) Devices
  ;----------------------------------------------------------------------------
  BadDeviceStruc   STRUC
    BDFlags           DB  ?  ;Misc Yes/No Flags
      BDFlagInUse    EQU 01h ;This entry currently being used?
    BDInterfaceNum    DB  ?  ;Interface Number of Bad Device
    BDHostIndex       DB  ?  ;Host Index of Bad Device
    BDDvcAddress      DB  ?  ;Device Address of Bad Device
    BDNewDeviceStage  DB  ?  ;Bad Device Stage First Time
    BDNewDeviceError  DW  ?  ;Bad Device Error Code First Time
   ENDS
  BadDeviceStrucSize EQU (TYPE BadDeviceStruc)

  ;----------------------------------------------------------------------------
  ;This is the format for a request sent to Int 14h to Send/Receive Data
  ;It contains the type of request, etc.
  ;----------------------------------------------------------------------------
  Int14RequestStruc         STRUC      ;Structure for an Int 14 Request
    I14RRequestType            DB   ?  ;Type of Request
      I14RRTHostClass         EQU  00h ;Host/System/OS Class
        I14RRTGetHostSWInfo   EQU  01h ;Get Host Software Info
        I14RRTGetHostHWInfo   EQU  02h ;Get Host Hardware Info
        I14RRTGetHostVendInfo EQU  03h ;Get Host Vendor Info
        I14RRTGetHostStatus   EQU  04h ;Get Current Host Status
        I14RRTHostRun         EQU  08h ;Start/Run/Resume Host
        I14RRTHostStop        EQU  09h ;Stop Host
        I14RRTHostReset       EQU  0Ah ;Reset Host
        I14RRTHostSuspend     EQU  0Bh ;Global Suspend Host
        I14RRTHostResume      EQU  0Ch ;Force Global Resume on Host
      I14RRTTimingClass       EQU  10h ;Frame Timing Class
        I14RRTRegTmgOwner     EQU  11h ;Register as Timing Owner
        I14RRTUnRegTmgOwner   EQU  12h ;UnRegister as Timing Owner
        I14RRTIncTiming       EQU  13h ;Increment (Slow Down) Frame Timing
        I14RRTDecTiming       EQU  14h ;Decrement (Speed Up) Frame Timing
        I14RRTChangeTiming    EQU  15h ;Change Frame Timing (by Large Amount)
      I14RRTHubClass          EQU  20h ;Hub Class
        I14RRTGetDvcHubInfo   EQU  21h ;Get Hub Info for Device
        I14RRTNewDvcConn      EQU  24h ;Hub has Detected new Device
        I14RRTDvcDisc         EQU  25h ;Device has been Disconnected
        I14RRTSendHubChar     EQU  27h ;Send Hub Characteristics to Host
        I14RRTEnableHubPort   EQU  28h ;Enable Device given Hub & Port
        I14RRTDisableHubPort  EQU  29h ;Disable Device given Hub & Port
        I14RRTResetHubPort    EQU  2Ah ;Reset Device given Hub & Port
        I14RRTSuspendHubPort  EQU  2Bh ;Suspend Device given Hub & Port
        I14RRTResumeHubPort   EQU  2Ch ;Resume Device given Hub & Port
        I14RRTPwrOnHubPort    EQU  2Dh ;Power On Device given Hub & Port
        I14RRTPwrOffHubPort   EQU  2Eh ;Power Off Device given Hub & Port
        I14RRTPwrResetHubPort EQU  2Fh ;Power Reset Device given Hub & Port
      I14RRTTPowerClass       EQU  30h ;Power Class
        I14RRTGetDvcPowerInfo EQU  31h ;Get Power Info for Device
        I14RRTGetHubPowerDraw EQU  32h ;Get Power Draw for Hub
        I14RRTPwrOnDevice     EQU  3Dh ;Power On Device given Dvc Addr
        I14RRTPwrOffDevice    EQU  3Eh ;Power Off Device given Dvc Addr
        I14RRTPwrResetDevice  EQU  3Fh ;Power Reset Device given Dvc Addr
      I14RRTDeviceClass       EQU  40h ;Device Class
        I14RRTGetDvcClassInfo EQU  41h ;Get Device Class Info
        I14RRTGetDvcVendInfo  EQU  42h ;Get Device Vendor Info
        I14RRTGetDvcStatus    EQU  43h ;Get Device Status
        I14RRTEnableDevice    EQU  48h ;Enable/Resume Device given Dvc Addr
        I14RRTDisableDevice   EQU  49h ;Disable Device given Dvc Addr
        I14RRTResetDevice     EQU  4Ah ;Reset Device given Dvc Addr
        I14RRTSuspendDevice   EQU  4Bh ;Suspend Device given Dvc Addr
        I14RRTResumeDevice    EQU  4Ch ;Resume Device given Dvc Addr
      I14RRTConfigClass       EQU  50h ;Configuration Class
        I14RRTConfigingIntf   EQU  51h ;Driver is Configuring an Interface
        I14RRTConfigIntfDone  EQU  52h ;Interface Configuration is Complete
        I14RRTSetNewConfig    EQU  58h ;Set/Change Device Config Value
      I14RRTInterfaceClass    EQU  60h ;Interface Class
        I14RRTFindRegIntf     EQU  62h ;Look for Registered Interface
        I14RRTFindUnRegIntf   EQU  63h ;Look for Unregistered Interface
        I14RRTRegIntfOwner    EQU  64h ;Register as Interface Owner
        I14RRTUnRegIntfOwner  EQU  65h ;Unregister as Interface Owner
        I14RRTIntfDontLook    EQU  68h ;Existing Interface Owner Don't Look
      I14RRTAltIntfClass      EQU  70h ;Alternate Interface Class
        I14RRTGetAltIntfInfo  EQU  71h ;Get Alternate Interface Info
      I14RRTEndPointClass     EQU  80h ;End Point Class
        I14RRTGetDataX        EQU  81h ;Get Current DataX Value
        I14RRTIncDataX        EQU  88h ;Increment/Toggle DataX Value
      I14RRTPacketClass       EQU  90h ;Packet Class
        I14RRTDoIsoch         EQU  94h ;Schedule Isochronous Transaction
        I14RRTDoInterruptPer  EQU  95h ;Schedule Periodic Interrupt
        I14RRTDoControl       EQU  96h ;Schedule Control/Setup Request
        I14RRTDoBulk          EQU  97h ;Schedule Bulk Transaction
        I14RRTDoInterrupt1T   EQU  98h ;Schedule One-Time Interrupt
        I14RRTCloseHandle     EQU  9Ch ;Close/Remove Scheduled Transaction
        I14RRTChangeIntPer    EQU  9Dh ;Change Periodicity of Interrupt
        I14RRTGetTransStatus  EQU  9Fh ;Get Status of Packet Transaction
      I14RRTMiscClass         EQU 0A0h ;Miscellaneous Class
        I14RRTLargeCallDone   EQU 0A1h ;Large (Complicated) Call Complete
        I14RRTBeepSpeaker     EQU 0AFh ;Beep the Speaker
      I14RRTInterHostClass    EQU 0E0h ;Inter-Host Communication Class
      I14RRTInternalClass     EQU 0F0h ;Host Internal/Troubleshooting Class
    I14RFlags                  DB   ?  ;Bit-level flags
      I14RFlagIn              EQU  01h ;In Direction
      I14RFlagLowSpeed        EQU  02h ;Low-Speed Device
      I14RFlagHiSpeed         EQU  04h ;High-Speed Device
      I14RFlagNoRetries       EQU  10h ;No Auto Retries for Control
      I14RFlagShortPktOK      EQU  20h ;No Retries for Short Packets
      I14RFlagSpecificFrame   EQU  40h ;Use Specific Frame Number
      I14RFlagAddrIsPhys      EQU  80h ;Data Address is Physical
    I14RHostIndex              DB   ?  ;Host Index
    I14RDeviceAddress          DB   ?  ;USB Device Address
      I14RHubAddress          EQU (OFFSET I14RDeviceAddress)
    I14REndPoint               DB   ?  ;EndPoint or Port or Alt Interface
      I14RHubPort             EQU (OFFSET I14REndPoint)
      I14RAltInterface        EQU (OFFSET I14REndPoint)
    I14RConfigValue            DB   ?  ;Configuration Value
      I14RCloseID             EQU (OFFSET I14RConfigValue)
      I14RDataX               EQU (OFFSET I14RConfigValue)
    I14RInterfaceNum           DB   ?  ;Interface Number
    I14RSearchIndex            DB   ?  ;Search Index
    I14RVendorID               DW   ?  ;Vendor ID
    I14RProductID              DW   ?  ;Product ID
    I14RDvcClass               DB   ?  ;Device Class
    I14RDvcSubClass            DB   ?  ;Device SubClass
    I14RDvcProtocol            DB   ?  ;Device Protocol
    I14RIntfClass              DB   ?  ;Interface Class
    I14RIntfSubClass           DB   ?  ;Interface SubClass
    I14RIntfProtocol           DB   ?  ;Interface Protocol
    I14RRequestHandle          DW   ?  ;Request Handle Number
    I14RPeriodicity            DW   ?  ;Interrupt Periodicity/Duration
      I14RBeepFrequency       EQU (OFFSET I14RPeriodicity)
    I14RTimeout                DW   ?  ;Transaction Time Out Value
    I14RDataAddress            DD   ?  ;Data Address
    I14RDataSize               DW   ?  ;Size of Data (Bytes)
    I14RCallBackAddr           DD   ?  ;Call Back Address (CS:IP format)
      I14RLargeCallRtnCode    EQU (OFFSET I14RCallBackAddr)
    I14RUserPktID              DW   ?  ;User Packet ID
    I14RSetupReqData           DQ   ?  ;Setup Request Data (8 bytes)
    I14RFrameTiming            DW   ?  ;Frame Timing Value (def = 12000)
      I14RFrameIndex          EQU (OFFSET I14RFrameTiming)
                                       ;Starting Frame of Isoch Schedule
    I14RIsochSchedAddr         DD   ?  ;Address of Isoch Schedule
    I14RFiller  DB (Int14RequestSize-$) DUP (0)

   ENDS

  ;----------------------------------------------------------------------------
  ;Device Request is a structure containing data required by a USB Setup Packet
  ;----------------------------------------------------------------------------
  SetupRequest           STRUC     ;Structure for a Standard Setup Pkt
    SRRequestType           DB  ?  ;Request Type
      SRRTOut              EQU 00h ;0=Out (Host to Device)
      SRRTIn               EQU 80h ;1=In (Device to Host)
      SRRTTypeMask         EQU 60h ;Mask for Type
        SRRTTypeStandard   EQU 00h ;Type 0 = Standard
        SRRTTypeClass      EQU 20h ;Type 1 = Class
        SRRTTypeVendor     EQU 40h ;Type 2 = Vendor
                                   ;Type 3 = Reserved
      SRRTRecipientMask    EQU 1Fh ;Mask for Recipient Type
        SRRTRecipDevice    EQU 00h ;Recipient Type 0 = Device
        SRRTRecipInterface EQU 01h ;Recipient Type 1 = Interface
        SRRTRecipEndPoint  EQU 02h ;Recipient Type 2 = EndPoint
        SRRTRecipOther     EQU 03h ;Recipient Type 3 = Other
                                   ;Types 4-31 = Reserved
    SRRequest               DB  ?  ;Specific Request
      SRRQGetStatus        EQU  0  ;Request  0 = Get Status
      SRRQClearFeature     EQU  1  ;Request  1 = Clear Feature
      SRRQGetState         EQU  2  ;Request  2 = Get State
      SRRQSetFeature       EQU  3  ;Request  3 = Set Feature
                                   ;Request  4 = Reserved
      SRRQSetAddress       EQU  5  ;Request  5 = Set Address
      SRRQGetDescriptor    EQU  6  ;Request  6 = Get Descriptor
      SRRQSetDescriptor    EQU  7  ;Request  7 = Set Descriptor
      SRRQGetConfig        EQU  8  ;Request  8 = Get Configuration
      SRRQSetConfig        EQU  9  ;Request  9 = Set Configuration
      SRRQGetAltInterface  EQU 10  ;Request 10 = Get Alternate Interface
      SRRQSetAltInterface  EQU 11  ;Request 11 = Set Alternate Interface
      SRRQSynchFrame       EQU 12  ;Request 12 = Synch Frame
    SRValue                 DW  ?  ;Value depends on Request Type
    SRIndex                 DW  ?  ;Index depends on Request Type
      ;If EndPoint,  Bits 3:0 = EndPoint Number
      ;              Bit    7 = 1 if IN EndPoint, 0 if OUT EndPoint
      ;              All other bits are 0
      ;If Interface, Bits 7:0 = Interface Number (low word)
      ;              All other bits are 0 (high word)
    SRLength                DW  ?  ;Length of Data (if there is Data)

   ENDS
  SetupRequestSize EQU TYPE (SetupRequest)

  ;----------------------------------------------------------------------------
  ;Format of data returned by a Get Device Descriptor
  ;----------------------------------------------------------------------------
  DeviceDescriptor   STRUC    ;Structure for a Device Descriptor
    DDLength            DB  ? ;Size of Descriptor in bytes
    DDDescrType         DB DescrTypeDevice
    DDUSBRelease        DW  ? ;USB Compliance  bcd (0210h=v2.10)
    DDDvcClass          DB  ? ;Device Class (defined by USB-IF)
    DDDvcSubClass       DB  ? ;Device SubClass (defined by USB-IF)
    DDDvcProtocol       DB  ? ;Device Protocol (defined by USB-IF)
    DDMaxPktSize        DB  ? ;Max Packet Size for EndPoint 0
                              ;  MUST be 8, 16, 32, or 64
    DDVendorID          DW  ? ;Vendor ID (defined by USB-IF)
    DDProductID         DW  ? ;Product ID (defined by manufacturer)
    DDDeviceRelease     DW  ? ;Device Release Number (bcd)
    DDManufacturerIndx  DB  ? ;Index of Manufacturer String
    DDProductIndx       DB  ? ;Index of Product String
    DDSerialNumberIndx  DB  ? ;Index of Serial Number String
    DDNumConfigs        DB  ? ;Number of possible Configurations
   ENDS
  DeviceDescriptorSize EQU TYPE (DeviceDescriptor)

  ;----------------------------------------------------------------------------
  ;Format of data returned by a Get Configuration Descriptor
  ;----------------------------------------------------------------------------
  ConfigDescriptor     STRUC     ;Structure for a Config Descriptor
    CDLength              DB  ?  ;Size of Descriptor in bytes
    CDDescrType           DB DescrTypeConfig
    CDTotalLength         DW  ?  ;Total length of data returned for
                                 ;  this configuration (ALL data)
    CDNumInterfaces       DB  ?  ;Number of Interfaces in this Config
    CDConfigValue         DB  ?  ;Value to use in SetRequest to
                                 ;  set this configuration
    CDConfigurationIndx   DB  ?  ;Index of Configuration String
    CDAttributes          DB  ?  ;Configuration Attributes
      CDAttrBit7         EQU 80h ;Bit 7 must be set to 1
      CDAttrSelfPowered  EQU 40h ;Self Powered
      CDAttrRemoteWakeup EQU 20h ;Remote Wakeup Supported
      CDAttrBatteryPower EQU 10h ;Battery Powered
      ;Bits 3:0 = Reserved (0)
    CDMaxBusPower         DB  ?  ;Maximum Power Consumption FROM BUS
                                 ;  in 2mA units (*2 to get mA)
   ENDS
  ConfigDescriptorSize EQU TYPE (ConfigDescriptor)

  ;----------------------------------------------------------------------------
  ;Format of data returned by a Get Interface Descriptor
  ;----------------------------------------------------------------------------
  InterfaceDescriptor   STRUC     ;Structure for an Interface Descr
    IDLength               DB  ?  ;Size of Descriptor in bytes
    IDDescrType            DB DescrTypeInterface
    IDInterfaceNumber      DB  ?  ;Interface Number (0-based Index)
    IDAlternateSetting     DB  ?  ;Value used to select this alternate
                                  ;  setting for the Interface Number
    IDNumEndPoints         DB  ?  ;Number of Interfaces, excl 0
    IDInterfaceClass       DB  ?  ;Interface Class (defined by USB-IF)
    IDInterfaceSubClass    DB  ?  ;Interface SubClass (def by USB-IF)
    IDInterfaceProtocol    DB  ?  ;Interface Protocol (def by USB-IF)
    IDInterfaceIndx        DB  ?  ;Index of Interface String
   ENDS
  InterfaceDescriptorSize EQU TYPE (InterfaceDescriptor)

  ;----------------------------------------------------------------------------
  ;Format of data returned by a Get EndPoint Descriptor
  ;----------------------------------------------------------------------------
  EndPointDescriptor    STRUC     ;Structure for an EndPoint Descr
    EDLength               DB  ?  ;Size of Descriptor in bytes
    EDDescrType            DB DescrTypeEndPoint
    EDEndPointNumber       DB  ?  ;EndPoint Number
      EDDirectionIn       EQU 80h ;Direction = In (Ignored in Control EP's)
      ;Bits 6:4 = Reserved (0)
      EDNumberMask        EQU 0Fh ;EndPoint Number (0-15)
    EDAttributes           DB  ?  ;EndPoint attributes
      ;Bits 7:6 = Reserved (0)
      EDUsageTypeMask     EQU 30h ;Bits 5:4 = Usage Type
      EDUsageTypeSft      EQU  4  ;Bits to Shift by
        EDAttrImplicitFB  EQU 20h ;2 = Implicit Feedback Data EndPoint
        EDAttrFeedback    EQU 10h ;1 = Feedback EndPoint
        EDAttrData        EQU 00h ;0 = Data EndPoint
      EDSynchTypeMask     EQU 0Ch ;Bits 3:2 = Synchronization Type
      EDSynchTypeSft      EQU  2  ;Bits to Shift By
        EDAttrSynch       EQU 0Ch ;3 = Synchronous
        EDAttrAdaptive    EQU 08h ;2 = Adaptive
        EDAttrAsynch      EQU 04h ;1 = Asynchronous
      EDAttrTransTypeMask EQU 03h ;Bits 1:0 = Transfer Type
        EDAttrInterrupt   EQU 03h ;3 = Interrupt
        EDAttrBulk        EQU 02h ;2 = Bulk
        EDAttrIsoch       EQU 01h ;1 = Isochronous
        EDAttrControl     EQU 00h ;0 = Control
    EDMaxPktSize           DW  ?  ;Max Packet Size EndPoint can handle
    EDPollInterval         DB  ?  ;Polling Interval for Data Transfers
    ;The following two bytes only appear in some Isochronous Applications
    EDRefreshRate          DB  ?  ;Refresh Rate (1-9, power of 2 mS)
    EDSynchEndPoint        DB  ?  ;Synchronization EndPoint
   ENDS
  EndPointDescriptorSize EQU TYPE (EndPointDescriptor)

  ;----------------------------------------------------------------------------
  ;Format of data returned by an HID (Human Interface Device) Descriptor
  ;----------------------------------------------------------------------------
  HIDDescriptor       STRUC     ;Structure for an HID Descriptor
    HIDDLength           DB ?   ;Size of Descriptor in bytes
    HIDDDescrType        DB DescrTypeHID
    HIDDClassRelease     DW ?   ;HID Class Release Spec (BCD)
    HIDDCountryCode      DB ?   ;Country Code
                                ;0 = None/NA, 21h = US
    HIDDNumClasses       DB ?   ;Number of Class Descriptors
    HIDDDescriptorType   DB ?   ;Type of Class Descriptor
                                ;DescrTypeHIDReport (22h) or
                                ;DescrTypeHIDPhysical (23h)
    HIDDDescriptorLength DW ?   ;Length of Class Descriptor
     ;Repeat Type and Length for each Class Descriptor
   ENDS
  HIDDescriptorSize EQU 9

  ;----------------------------------------------------------------------------
  ;Country Codes for HID Descriptor (HIDDCountryCode)
  ;----------------------------------------------------------------------------
  HIDDCountryNone EQU 00h ;None/Not Supported/Doesn't Matter
  HIDDCountryUS   EQU 21h


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;MACROS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

  JUMP MACRO     ;Do a NEAR (SHORT) JMP instead of a Local JMP
    JMP SHORT #1
   #EM


;ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
;TSR DATA
;‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹

;==============================================================================
;TSR Related
;==============================================================================

  ;------------------------------------------------------------------------------
  ;INT2F Data (this needs to be the first data at the top of the file)
  ;If the user does a "TYPE USBKEYB.COM" at the command line, this will
  ;  just show the program name and version, instead of sending all kinds of
  ;  annoying happy faces and BELs to the screen the way most programs do.
  ;This is also the same data that is used to test if the program is
  ;  already installed in memory.
  ;------------------------------------------------------------------------------
  NoType1:     DB               CR  ;To handle TYPE from command line
  ProgName:    DB        'USBKEYB ' ;Program Name
  ProgNameLen EQU       $-ProgName  ;Length of name
  ProgVerTxt:  DB           ' 0.09' ;Program version in ASCII
  Author:      DB '  Bret Johnson' ;Authors name
  AuthorLen   EQU         $-Author  ;Length of Author
  NoType2:     DB              EOF  ;To handle TYPE from command line
  ProgVer      DW             0009h ;Program version as a word
  HandleNum    DB              0C0h ;TSR multiplex handle number

  ;------------------------------------------------------------------------------
  ;Miscellaneous Yes/No TSR Flags
  ;------------------------------------------------------------------------------
  TSRFlags          DB 00h ;Miscellaneous Yes/No Flags #1
    NoBeep         EQU 01h ;Don't Beep the speaker
    DisableAll     EQU 02h ;Disable All Keyboards (used while showing RawData)
    Uninstalled    EQU 04h ;Program has been uninstalled
    EOIIssued      EQU 08h ;End-of-Interrupt (OUT 20h,20h) occured
    NoHandleReboot EQU 10h ;Don't handle Ctrl-Alt-Del Reboot Requests
    NoHandleLocks  EQU 20h ;Don't handle Lock Keys (Cap/Num/Scroll)
    NoHandlePause  EQU 40h ;Don't handle Pause Key
    NoRealKeyb     EQU 80h ;Real keyboard does not exist

  TSRFlags2         DB 00h ;Miscellaneous Yes/No Flags #2
    Int14ReqInUse  EQU 01h ;Int 14 Request currently being used
    DoLoopTest     EQU 02h ;Do Loop Test in Method 3 code
    Int08InUse     EQU 04h ;Int 08h already in use
    Int70InUse     EQU 08h ;Int 70h already in use
    NoBeep1Time    EQU 10h ;No Beep this One Time


;==============================================================================
;Stack Related
;==============================================================================
  StackInUse DB 0 ;Counter to keep track of "setup stack" calls
  OldSS      DW ? ;Original Stack Segment
  OldSP      DW ? ;Original Stack Pointer
  TempBX     DW ? ;Temporary Storage for BX while setting up Stack
  TempFlags  DW ? ;Temporary Storage for Flags while setting up Stack


;==============================================================================
;INT 70h (System Delay) Related
;==============================================================================
  OldA1 DB ? ;Original Port A1h Contents (PIC2 IRQ Mask)


;==============================================================================
;Keyboard Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Storage for Reboot Code, to handle Ctrl-Alt-Del keystrokes effectively
  ;----------------------------------------------------------------------------
  RebootIP DW ? ;Ctrl-Alt-Del reboot Instruction Pointer
  RebootCS DW ? ;Ctrl-Alt-Del reboot Code Segment

  ;----------------------------------------------------------------------------
  ;Method to use to "type" a Scan Code
  ;0 = Not Configured yet, 1-3 = valid Methods
  ;----------------------------------------------------------------------------
  Method DB 0

  ;----------------------------------------------------------------------------
  ;Flags to keep track of which "Special" Scan Code(s) were sent on Key Press
  ;----------------------------------------------------------------------------
  KeySentFlags        DB  ?
    KeySentSftPrtScr EQU 01h ;Sent a Shift-PrintScreen
    KeySentPrtScr    EQU 02h ;Sent a PrintScreen (User typed <Shift>)
    KeySentSysReq    EQU 04h ;Sent a SysReq
    KeySentPause     EQU 08h ;Sent a Pause (along with a Pause Release)
    KeySentBreak     EQU 10h ;Sent a Break (along with a Break Release)

  ;----------------------------------------------------------------------------
  ;Data needed to "type" a Scan Code using Method 3
  ;----------------------------------------------------------------------------
  EVEN 2
  Int01Vect    DD  ? ;Old Interrupt 01 (SST) Vector
  IntXXFlags   DW  ? ;For Interrupt Stack Calls
  IntXXVect    DD  ? ;For Interrupt Stack Calls
  DoNextTime   DB No ;Fake a scan code again next time?
  ScanCode     DB  ? ;Scan Code to use to fake INT 09
  Int01Counter DB  0 ;Counter for recursive calls to Int01
  InstrCounter DW  0 ;Instruction Counter for Int 01h (for OUT 20h,20h)

  ;----------------------------------------------------------------------------
  ;Circular Buffer to store Scan Codes we need to type
  ;Converting USB Key Codes to "normal" Scan Codes is a rather complicated
  ;  process, and is not a one-to-one proposition (a single USB Key Code
  ;  can equate to several Scan Codes).
  ;Also, more than one key can be pressed at a time.
  ;Our process involves filling this buffer with Scan Codes as we process the
  ;  USB Key Codes, and then "typing" the contents of the buffer after we're
  ;  done.
  ;This is a circular buffer, which is safer than a linear buffer
  ;  (it is "protected" from us trying to fill it with too much data)
  ;----------------------------------------------------------------------------
  Buffer:      DB BufferSize DUP (?)  ;Buffer for Scan Codes
  BufferHead   DW Buffer+1            ;Pointer to Buffer Head
  BufferTail   DW Buffer              ;Pointer to Buffer Tail
  BufferCount  DB 0                   ;Number of codes currently in buffer
  BufferEnd   EQU Buffer+BufferSize-1 ;End of buffer

  ;----------------------------------------------------------------------------
  ;Countdown Timer Values for Keyboard Delays and Repeats
  ;These variables simply store the currently used values, they are not
  ;  the actual countdown timers themselves.  Each individual key is kept
  ;  track of with its own individual timer.
  ;All keyboards will use the same values, so we ony need one copy of them.
  ;NOTE: Logically, Delay would be stored first in memory (before Repeat),
  ;         since it happens first in the timing of things.
  ;      Because the BIOS Functions reverse this (the BIOS calls want the
  ;        Repeat Code in BL and the Delay Code in BH), we store them in
  ;        memory backwards from what logic would dictate.  This allows
  ;        our code to be a little bit smaller and faster (we can transfer
  ;        both bytes to/from the BIOS calls as a single word, rather
  ;        than transfering it as two bytes).
  ;      Don't get confused because this is backwards from what you expect!
  ;----------------------------------------------------------------------------
  RepeatCode   DB DefRepeatCode   ;BIOS Code For Repeat Rate
  DelayCode    DB DefDelayCode    ;BIOS Code Initial Delay
  RepeatFactor DB DefRepeatFactor ;Initial Countdown Timer for Repeat Rate
  DelayFactor  DB DefDelayFactor  ;Initial Countdown Timer for Initial Delay

  ;----------------------------------------------------------------------------
  ;Report Byte sent to keyboard to Control LEDs
  ;----------------------------------------------------------------------------
  LEDStatus DB 0 ;LED Status Report byte to send to Keyboard(s)

  ;----------------------------------------------------------------------------
  ;Table of "Special" Scan Codes that we need to do a Loop Test for
  ;  while using Method 3 (certain Keyboard BIOS's are VERY slow if we don't
  ;  do the Special Test.
  ;Some keyboard BIOSes incorporate a HUGE Delay while processing
  ;  "Shift" and "Lock" keystrokes (I have no idea what the Delay is for).
  ;When "typing" with Method 3, the length of the Delay is multiplied many
  ;  times, and can end up being several seconds (FAR too long to be useful,
  ;  and perhaps even dangerously long).
  ;The Delay method the BIOSes use is a simple CPU LOOP code with CX (the
  ;  LOOP Counter) being really big.  If the Method 3 Code is trying to "type"
  ;  one of the Scan Codes in this Table, and it comes across a LOOP when
  ;  CX is really big, it modifies CX so that Delay becomes relatively small.
  ;There's no reason a Keyboard BIOS routine would perform a really long LOOP
  ;  unless it is trying to Delay, so "bypassing" the LOOP shouldn't cause
  ;  any "important" code to get screwed up.
  ;----------------------------------------------------------------------------
  LoopTestCodes:
    DB ScanCodeControl    ;29 Control
    DB ScanCodeLShift     ;42 Left Shift
    DB ScanCodeRShift     ;54 Right Shift
    DB ScanCodeAlt        ;56 Alt
    DB ScanCodeCapsLock   ;58 CapsLock
    DB ScanCodeNumLock    ;69 NumLock
    DB ScanCodeScrollLock ;70 ScrollLock
    DB 0                  ;End of Table

  ;----------------------------------------------------------------------------
  ;User-defined Tables to Convert USB & System Codes to Scan Codes
  ;First byte of each entry is the USB/System Code, next byte is the
  ;  "real" Scan Code(s).  We allow single ScanCodes, 224-prefixed codes,
  ;  and 225 (for Pause).  If the second byte (the "real" Scan Code has bit
  ;  7 set, we prefix it with a 224.
  ;----------------------------------------------------------------------------
  EVEN 2
  UserUSBTable: DB (UserTblEntries*2) DUP 0
                DW 0 ;End of Table
  UserSysTable: DB (UserSysEntries*2) DUP 0
                DW 0 ;End of Table

  ;----------------------------------------------------------------------------
  ;Table to keep track of External System/USB Keys
  ;  (Sent through INT 16h Extended Functions)
  ;----------------------------------------------------------------------------
  EVEN 2
  ExternalTable:
    DB (NumUSBKeys*USBKeyStrucSize) DUP (0)

  ;----------------------------------------------------------------------------
  ;Table to Convert USB Scan Codes to Single Scan Codes
  ;This table is probably only valid for a US Keyboard!!
  ;----------------------------------------------------------------------------
  EVEN 2
  ConversionTbl1:
    DB RptKbdA,            ScanCodeA              ;Aa
    DB RptKbdB,            ScanCodeB              ;Bb
    DB RptKbdC,            ScanCodeC              ;Cc
    DB RptKbdD,            ScanCodeD              ;Dd
    DB RptKbdE,            ScanCodeE              ;Ee
    DB RptKbdF,            ScanCodeF              ;Ff
    DB RptKbdG,            ScanCodeG              ;Gg
    DB RptKbdH,            ScanCodeH              ;Hh
    DB RptKbdI,            ScanCodeI              ;Ii
    DB RptKbdJ,            ScanCodeJ              ;Jj
    DB RptKbdK,            ScanCodeK              ;Kk
    DB RptKbdL,            ScanCodeL              ;Ll
    DB RptKbdM,            ScanCodeM              ;Mm
    DB RptKbdN,            ScanCodeN              ;Nn
    DB RptKbdO,            ScanCodeO              ;Oo
    DB RptKbdP,            ScanCodeP              ;Pp
    DB RptKbdQ,            ScanCodeQ              ;Qq
    DB RptKbdR,            ScanCodeR              ;Rr
    DB RptKbdS,            ScanCodeS              ;Ss
    DB RptKbdT,            ScanCodeT              ;Tt
    DB RptKbdU,            ScanCodeU              ;Uu
    DB RptKbdV,            ScanCodeV              ;Vv
    DB RptKbdW,            ScanCodeW              ;Ww
    DB RptKbdX,            ScanCodeX              ;Xx
    DB RptKbdY,            ScanCodeY              ;Yy
    DB RptKbdZ,            ScanCodeZ              ;Zz
    DB RptKbd1,            ScanCode1              ;1!
    DB RptKbd2,            ScanCode2              ;2@
    DB RptKbd3,            ScanCode3              ;3#
    DB RptKbd4,            ScanCode4              ;4$
    DB RptKbd5,            ScanCode5              ;5%
    DB RptKbd6,            ScanCode6              ;6^
    DB RptKbd7,            ScanCode7              ;7&
    DB RptKbd8,            ScanCode8              ;8*
    DB RptKbd9,            ScanCode9              ;9(
    DB RptKbd0,            ScanCode0              ;0)
    DB RptKbdEnter,        ScanCodeEnter          ;Enter
    DB RptKbdEscape,       ScanCodeEscape         ;Escape
    DB RptKbdBackSpace,    ScanCodeBackSpace      ;BackSpace
    DB RptKbdTab,          ScanCodeTab            ;Tab/backTab
    DB RptKbdSpace,        ScanCodeSpace          ;Space
    DB RptKbdMinus,        ScanCodeMinus          ;-_
    DB RptKbdEquals,       ScanCodeEquals         ;=+
    DB RptKbdLBracket,     ScanCodeLBracket       ;[{
    DB RptKbdRBracket,     ScanCodeRBracket       ;]}
    DB RptKbdBackSlash,    ScanCodeBackSlash      ;\|
    DB RptKbdSemiColon,    ScanCodeSemiColon      ;;:
    DB RptKbdQuote,        ScanCodeQuote          ;'"
    DB RptKbdTilde,        ScanCodeTilde          ;`~
    DB RptKbdComma,        ScanCodeComma          ;,<
    DB RptKbdPeriod,       ScanCodePeriod         ;.>
    DB RptKbdSlash,        ScanCodeSlash          ;/?
    DB RptKbdCapsLock,     ScanCodeCapsLock       ;Caps Lock
    DB RptKbdF1,           ScanCodeF1             ;F1
    DB RptKbdF2,           ScanCodeF2             ;F2
    DB RptKbdF3,           ScanCodeF3             ;F3
    DB RptKbdF4,           ScanCodeF4             ;F4
    DB RptKbdF5,           ScanCodeF5             ;F5
    DB RptKbdF6,           ScanCodeF6             ;F6
    DB RptKbdF7,           ScanCodeF7             ;F7
    DB RptKbdF8,           ScanCodeF8             ;F8
    DB RptKbdF9,           ScanCodeF9             ;F9
    DB RptKbdF10,          ScanCodeF10            ;F10
    DB RptKbdF11,          ScanCodeF11            ;F11
    DB RptKbdF12,          ScanCodeF12            ;F12
    DB RptKbdScrollLock,   ScanCodeScrollLock     ;Scroll Lock
    DB RptKbdNumLock,      ScanCodeNumLock        ;Numbers Lock
    DB RptKbdGreyStar,     ScanCodeGreyStar       ;KeyPad *
    DB RptKbdGreyMinus,    ScanCodeGreyMinus      ;KeyPad -
    DB RptKbdGreyPlus,     ScanCodeGreyPlus       ;KeyPad +
    DB RptKbdEnd,          ScanCodeEnd            ;End & 1
    DB RptKbdDown,         ScanCodeDown           ;Down & 2
    DB RptKbdPageDown,     ScanCodePageDown       ;PgDn & 3
    DB RptKbdLeft,         ScanCodeLeft           ;Left & 4
    DB RptKbdGrey5,        ScanCodeGrey5          ;NumPad 5
    DB RptKbdRight,        ScanCodeRight          ;Right &6
    DB RptKbdHome,         ScanCodeHome           ;Home & 7
    DB RptKbdUp,           ScanCodeUp             ;Up & 8
    DB RptKbdPageUp,       ScanCodePageUp         ;PgUp & 9
    DB RptKbdInsert,       ScanCodeInsert         ;Ins & 0
    DB RptKbdDelete,       ScanCodeDelete         ;Del & .
    DB RptKbdKey102,       ScanCodeKey102         ;Non-US \| (102nd Key)
    DB RptKbdLControl,     ScanCodeControl        ;Left Control
    DB RptKbdLShift,       ScanCodeLShift         ;Left Shift
    DB RptKbdLAlt,         ScanCodeAlt            ;Left Alt
    DB RptKbdRShift,       ScanCodeRShift         ;Right Shift
  ;All Entries Below this line are "extended" keys (prefixed with 224)
    DB RptKbdGreyEnter,    ScanCodeEnter+80h      ;KeyPad Enter
    DB RptKbdRControl,     ScanCodeControl+80h    ;Right Control
    DB RptKbdGreySlash,    ScanCodeSlash+80h      ;KeyPad /
    DB RptKbdRAlt,         ScanCodeAlt+80h        ;Right Alt
  ;This section is Grey Movement Keys, which need special Shift-Key Handling
    DB RptKbdGreyHome,     ScanCodeHome+80h       ;Grey Home
    DB RptKbdGreyUp,       ScanCodeUp+80h         ;Grey Up Arrow
    DB RptKbdGreyPageUp,   ScanCodePageUp+80h     ;Grey Page Up
    DB RptKbdGreyLeft,     ScanCodeLeft+80h       ;Grey Left Arrow
    DB RptKbdGreyRight,    ScanCodeRight+80h      ;Grey Right Arrow
    DB RptKbdGreyEnd,      ScanCodeEnd+80h        ;Grey End
    DB RptKbdGreyDown,     ScanCodeDown+80h       ;Grey Down Arrow
    DB RptKbdGreyPageDown, ScanCodePageDown+80h   ;Grey Page Down
    DB RptKbdGreyInsert,   ScanCodeInsert+80h     ;Grey Insert
    DB RptKbdGreyDelete,   ScanCodeDelete+80h     ;Grey Delete
  ;This section is "Special" Keys, which require Special Handling
  ;  based on the Status of some of the "Shift" Keys
    DB RptKbdPrintScreen,  ScanCodeGreyStar+80h   ;PrintScreen
    DB RptKbdPrintScreen,  ScanCodeSysReq         ;  SysReq
    DB RptKbdPause,        225                    ;Pause
    DB RptKbdPause,        ScanCodeScrollLock+80h ;  Break
  ;This section ins the Windows 95/NT Keys
    DB RptKbdLWindows,     ScanCodeLWindows+80h   ;Left Windows (GUI)
    DB RptKbdRWindows,     ScanCodeRWindows+80h   ;Right Windows (GUI)
    DB RptKbdMouseMenu,    ScanCodeMouseMenu+80h  ;Mouse Menu
  ;Below this line are "standard" Microsoft Multimedia Keys
    DB RptKbdHelp,         ScanCodeHelp+80h       ;Help
    DB RptKbdStopMedia,    ScanCodeStopMedia+80h  ;Stop Media
    DB RptKbdCopy,         ScanCodeCopy+80h       ;Copy
    DB RptKbdCut,          ScanCodeCut+80h        ;Cut
    DB RptKbdPaste,        ScanCodePaste+80h      ;Paste
    DB RptKbdMute,         ScanCodeMute+80h       ;Mute
    DB RptKbdUndo,         ScanCodeUndo+80h       ;Undo
    DB RptKbdVolumeUp,     ScanCodeVolumeUp+80h   ;Volume+
    DB RptKbdVolumeDown,   ScanCodeVolumeDown+80h ;Volume-
    DW 0                                        ;End of Table

  ;----------------------------------------------------------------------------
  ;Table to Convert USB System Key Codes to Scan Codes
  ;I'm not sure what the contents of this Table should actually be,
  ;  other than Power/Sleep/WakeUp.
  ;----------------------------------------------------------------------------
  ConversionTblSys:
    DB RptGDSysPowerDown, ScanCodePower+80h  ;Power Down
    DB RptGDSysSleep,     ScanCodeSleep+80h  ;Sleep
    DB RptGDSysWakeUp,    ScanCodeWakeUp+80h ;WakeUp
    DW 0                                     ;End of Table

  ;----------------------------------------------------------------------------
  ;This are Scancode Keys on the NumPad,
  ;  which may need special Shift-Key handling.
  ;This Table should be valid for any Keyboard Language
  ;----------------------------------------------------------------------------
  ScanCodeTblGrey:
    DB ScanCodeHome+80h     ;Grey Home
    DB ScanCodeUp+80h       ;Grey Up Arrow
    DB ScanCodePageUp+80h   ;Grey Page Up
    DB ScanCodeLeft+80h     ;Grey Left Arrow
    DB ScanCodeRight+80h    ;Grey Right Arrow
    DB ScanCodeEnd+80h      ;Grey End
    DB ScanCodeDown+80h     ;Grey Down Arrow
    DB ScanCodePageDown+80h ;Grey Page Down
    DB ScanCodeInsert+80h   ;Grey Insert
    DB ScanCodeDelete+80h   ;Grey Delete
    DB 0                    ;End of Table


;==============================================================================
;INT 16h Extended Functions Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Code Offsets for INT 16h Extended Subfunctions
  ;  The byte value is in AL on the function call
  ;----------------------------------------------------------------------------
  Int16FunctionTbl:
    DB 10h                    ;Scancode Install Check
     DW DoScanCodeInstall
    DB 11h                    ;Send Scancode Press
     DW DoScanCodePress
    DB 12h                    ;Send Scancode Release
     DW DoScanCodeRelease
    DB 13h                    ;Send ScanCode Press/Release
     DW DoScanCodePressRls
   ;USB Code
    DB 20h                    ;USB Code Check
     DW DoUSBCodeInstall
    DB 21h                    ;Send USB Code Press
     DW DoUSBCodePress
    DB 22h                    ;Send USB Code Release
     DW DoUSBCodeRelease
    DB 23h                    ;Send USB Code Press/Release
     DW DoUSBCodePressRls
   ;USB System Code
    DB 30h                    ;USB System Code Check
     DW DoSysCodeInstall
    DB 31h                    ;Send USB System Code Press
     DW DoSysCodePress
    DB 32h                    ;Send USB System Code Release
     DW DoSysCodeRelease
    DB 33h                    ;Send USB System Code Press/Release
     DW DoSysCodePressRls
   ;End of Table
    DB -1                     ;End of Table
     DW -1


;==============================================================================
;USB Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Handle Number of New Device (Device 0) Registry
  ;----------------------------------------------------------------------------
  Reg0Handle DW ?

  ;----------------------------------------------------------------------------
  ;Host Index & Handle Number of User Table Interrupt
  ;----------------------------------------------------------------------------
  UserTblHost   DB -1 ;Host that active interrupt is on
  UserTblHandle DW -1 ;Handle number of periodic interrupt

  ;----------------------------------------------------------------------------
  ;Int08 Countdown Timers
  ;----------------------------------------------------------------------------
  Int08Counter    DB 5 ;Countdown Timer to periodically check for new Devices
                       ;Initial Delay is 5 timer ticks (about 1/4 second)
                       ;Delays after initial one will be about 1 second
                       ;Setting to 0 Disables the program
  DontLookCounter DW 0 ;Countdown Timer to not Look for new Devices

  ;----------------------------------------------------------------------------
  ;Calls that the USB Host Driver can send to us after we're "registered"
  ;Our code is called with this function code in AX
  ;----------------------------------------------------------------------------
  OwnerCallFunctionTbl:
   ;Device Connect/Disconnect
    DB OwnerCallNewDvc        ;New Device Connected
     DW DeviceAdded
    DB OwnerCallDvcDisc       ;Existing Device Disconnected
     DW DeviceDisconnected
    DB OwnerCallDvc0Disc      ;Unregistered Device Disconnected
     DW Device0Disconnected
    DB OwnerCallDontLook      ;Don't Look for New Interface Temporarily
     DW StartDontLook
   ;Device Enable/Disable/Reset/Suspend/Resume/PwrOn/PwrOff/PwrReset
    DB OwnerCallDvcEnable     ;Device Enabled
     DW DeviceEnabled
    DB OwnerCallDvcDisable    ;Device Disabled
     DW DeviceDisabled
    DB OwnerCallDvcReset      ;Device Reset
     DW DeviceReset
    DB OwnerCallDvcSuspend    ;Device Suspend
     DW DeviceSuspend
    DB OwnerCallDvcResume     ;Device Resume
     DW DeviceResume
    DB OwnerCallDvcPwrOn      ;Device Power On
     DW DevicePowerOn
    DB OwnerCallDvcPwrOff     ;Device Power Off
     DW DevicePowerOff
    DB OwnerCallDvcPwrReset   ;Device Power Reset
     DW DevicePowerReset
   ;Host Connect/Disconnect
    DB OwnerCallNewHost       ;New Host has been Added
     DW NewHostAdded
    DB OwnerCallHostDisc      ;Existing Host Disconnected
     DW HostDisconnected
    DB OwnerCallHostHWErr     ;Host System/Processor Error
     DW HostHWErr
   ;Host Run/Stop/Reset/Suspend/Resume/Debug/SingleStep
    DB OwnerCallHostRun       ;Host Running
     DW HostRun
    DB OwnerCallHostStop      ;Host Stopped
     DW HostStop
    DB OwnerCallHostReset     ;Host Reset
     DW HostReset
    DB OwnerCallHostSuspend   ;Host Suspended
     DW HostSuspend
    DB OwnerCallHostResume    ;Host Resumed
     DW HostResume
    DB OwnerCallHostDebug     ;Host in Debug Mode
     DW HostDebug
    DB OwnerCallHostSST       ;Host Single-Stepped
     DW HostSST
   ;Timing Changes
    DB OwnerCallTimingChg     ;Host Timing Changed
     DW TimingChange
   ;Upstream Device Changes
    DB OwnerCallDvcDiscUS     ;Device Disconnect Upstream
     DW DeviceDisconnectedUS
    DB OwnerCallDvcEnableUS   ;Device Enable Upstream
     DW DeviceEnabledUS
    DB OwnerCallDvcDisableUS  ;Device Disable Upstream
     DW DeviceDisabledUS
    DB OwnerCallDvcResetUS    ;Device Reset Upstream
     DW DeviceResetUS
    DB OwnerCallDvcSuspendUS  ;Device Suspend Upstream
     DW DeviceSuspendUS
    DB OwnerCallDvcResumeUS   ;Device Resume Upstream
     DW DeviceResumeUS
    DB OwnerCallDvcPwrOnUS    ;Device Power On Upstream
     DW DevicePowerOnUS
    DB OwnerCallDvcPwrOffUS   ;Device Power Off Upstream
     DW DevicePowerOffUS
    DB OwnerCallDvcPwrResetUS ;Device Power Reset Upstream
     DW DevicePowerResetUS
   ;End of Table
    DB -1                     ;End of Table
     DW -1

  ;----------------------------------------------------------------------------
  ;Table to keep track of individual Devices
  ;----------------------------------------------------------------------------
  EVEN 2
  DeviceInfoTable:
    DB (MaxDevices*DeviceInfoStrucSize) DUP (0)

  ;----------------------------------------------------------------------------
  ;Table to keep track of "bad" (incompatible) Devices.
  ;This table will keep track of Host Indexes and Address of incompatible
  ;  Devices that we find.
  ;If we don't keep track of them, we will get caught in an endless
  ;  loop of looking at the bad one every time we check (if it happens
  ;  to be the first one), and will never skip over it and be
  ;  able to find a "good" (compatible) Device.
  ;----------------------------------------------------------------------------
  EVEN 2
  BadDeviceTable:
    DB (MaxBadDevices*BadDeviceStrucSize) DUP (0)

  ;----------------------------------------------------------------------------
  ;Offset in InfoTable of Last Device we found (needed to print Descriptors)
  ;----------------------------------------------------------------------------
  LastDeviceFound DW DeviceInfoTable

  ;----------------------------------------------------------------------------
  ;Stage & Error Code where New Device search failed (for troubleshooting)
  ;For even stages < 200, the Error is a TD Status Error Code.
  ;  These are the ones generally caused by Devices that don't respond
  ;  like they're expected to.
  ;For odd stages < 200, the Error is an INT 14h Call Error Code.
  ;  These are generally cause by faulty code, and should not appear
  ;  in final, bug-less release of the program.
  ;For stages >= 200, the "Error" is not related to an INT 14h or TD at all.
  ;  These are other kinds of Errors, usually caused by a value in one
  ;    of the Descriptors that we don't undertand how to handle.  The
  ;    "Error Code" in these instances is usually meaningless.
  ;Categorizing the Error Codes like this allows us to easily write a more
  ;  complete and meaningful description of the Bad Device Error.  It is
  ;  still necessary to look at the source code to REALLY figure out what's
  ;  going on, but the information provided is better than just writing
  ;  the raw Error Code numbers.
  ;----------------------------------------------------------------------------
  NewDeviceStage DB ?
  NewDeviceError DW ?

  ;----------------------------------------------------------------------------
  ;Data Structures needed to issue Requests to the USB Host
  ;----------------------------------------------------------------------------
  EVEN 2
  Int14Request:
    DB Int14RequestSize DUP (0)
  Int14Request2:
    DB Int14RequestSize DUP (0)

  ;----------------------------------------------------------------------------
  ;Storage Area for Data returned by USB Descriptors and Reports
  ;----------------------------------------------------------------------------
  DvcDescrData:
    DB DeviceDescriptorSize DUP (?) ;Device Descriptor Data
  DescriptorData:
    DB MaxDescriptorSize    DUP (?) ;Actual Descriptor Data
  ReportData:
    DB MaxReportSize        DUP (?) ;Actual Report Data


;==============================================================================
;USB Keyboard/HID Class-Specific Control Requests
;==============================================================================
  EVEN 2

  ;----------------------------------------------------------------------------
  ;Get Report Descriptor
  ;----------------------------------------------------------------------------
  GetReportDescrReq:
    DB SRRTIn+SRRTTypeStandard+SRRTRecipInterface
    DB SRRQGetDescriptor
    DB ? ;Report ID
    DB DescrTypeHIDReport
    DB ? ;Interface Number
    DB 0
    DW ? ;Number of Bytes

  I14RGetReportDescrRptID EQU I14RSetupReqData.SRValue[0] ;Byte
  I14RGetReportDescrIntf  EQU I14RSetupReqData.SRIndex[0] ;Byte
  I14RGetReportDescrSize  EQU I14RSetupReqData.SRLength   ;Word

  ;----------------------------------------------------------------------------
  ;Set Idle Rate
  ;  Silences Report on Interrupt In EndPoint until new event or specified time
  ;  Recommended DEFAULT idle rate is 500ms for keyboards (delay before
  ;    first rpt) and infinity for joysticks and mice
  ;----------------------------------------------------------------------------
  SetHIDIdleReq:
    DB SRRTOut+SRRTTypeClass+SRRTRecipInterface
    DB HIDRQSetIdle
    DB ? ;Report ID (0 = AllReports)
    DB ? ;Duration in 4ms increments (+/- 10% + 2ms)
         ;0 = infinite (only report changes)
         ;If less than polling rate, polling rate is used
    DB ? ;Interface Number
    DB 0
    DW 0

  I14RSetHIDIdleRptID    EQU I14RSetupReqData.SRValue[0] ;Byte
  I14RSetHIDIdleDuration EQU I14RSetupReqData.SRValue[1] ;Byte
  I14RSetHIDIdleIntf     EQU I14RSetupReqData.SRIndex[0] ;Byte

;  ;----------------------------------------------------------------------------
;  ;Set Protocol
;  ;----------------------------------------------------------------------------
;  SetHIDProtocolReq:
;    DB SRRTOut+SRRTTypeClass+SRRTRecipInterface
;    DB HIDRQSetProtocol
;    DB HIDProtocolReport ;Protocol Type = Report (we do not use Boot Protocol)
;    DB 0
;    DB ? ;Interface Number
;    DB 0
;    DW 0
;
;  I14RSetHIDProtocolIntf EQU I14RSetupReqData.SRIndex[0] ;Byte

  ;----------------------------------------------------------------------------
  ;Set LED Report
  ;----------------------------------------------------------------------------
  SetLEDReq:
    DB SRRTOut+SRRTTypeClass+SRRTRecipInterface
    DB HIDRQSetReport
    DB 0 ;Report ID (always 0?)
    DB HIDReportTypeOutput ;Type = Output
    DB ? ;Interface Number
    DB 0
    DW 1 ;Size = 1 Byte

  I14RSetLEDRptID EQU I14RSetupReqData.SRValue[0] ;Byte
  I14RSetLEDIntf  EQU I14RSetupReqdata.SRIndex[0] ;Byte


;==============================================================================
;USB General-Purpose Control Requests
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Get Device Descriptor
  ;----------------------------------------------------------------------------
  GetDvcDescrReq:
    DB SRRTIn+SRRTTypeStandard+SRRTRecipDevice
    DB SRRQGetDescriptor
    DB 0
    DB DescrTypeDevice
    DW 0
    DW DeviceDescriptorSize

  ;----------------------------------------------------------------------------
  ;Get Configuration Descriptor
  ;----------------------------------------------------------------------------
  GetCfgDescrReq:
    DB SRRTIn+SRRTTypeStandard+SRRTRecipDevice
    DB SRRQGetDescriptor
    DB 0 ;Configuration Value to Get (always 0?)
    DB DescrTypeConfig
    DW 0
    DW ConfigDescriptorSize ;Size will change for a Complete Config

  I14RGetCfgDescrValue EQU I14RSetupReqData.SRValue[0] ;Byte
  I14RGetCfgDescrSize  EQU I14RSetupReqData.SRLength   ;Word

  ;----------------------------------------------------------------------------
  ;Set Alternate Interface
  ;----------------------------------------------------------------------------
  SetAltIntfReq:
    DB SRRTOut+SRRTTypeStandard+SRRTRecipInterface
    DB SRRQSetAltInterface
    DB ? ;Alternate Value to set Interface to
    DB 0
    DB ? ;Interface to Set
    DB 0
    DW 0

  I14RSetAltIntfAltIntf EQU I14RSetupReqData.SRValue[0] ;Byte
  I14RSetAltIntfIntf    EQU I14RSetupReqData.SRIndex[0] ;Byte


;ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
;TSR CODE
;‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹

;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO HANDLE INT 2Fh (TSR Multiplex)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HAVE INTERRUPT 2Fh RUN THIS PROGRAM EVERY TIME IT OCCURS
;Inputs:  CS = TSR Data Area
;         AH = Function (Handle) number, C0h-FFh
;         AL = Subfunction number
;         (If MuxGetProgName): DI = 0
;Outputs: (AL = MuxInstallChk):  AL = FFh if installed
;         (AL = MuxGetProgName): ES:[DI] = Pointer to ProgName
;         (AL = MuxGetProgVer):  AX = ProgVer (Program version number, AH=Major)
;         (AL = MuxGetAuthor):   ES:[DI] = Pointer to Author
;Changes:
;------------------------------------------------------------------------------
Int2FHdr:
  DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code

Int2F:
  STI                               ;Enable Interrupts
  CMP  AH,CS:HandleNum              ;Is this our handle?
  JE   Int2FInstall                 ;If so, jump to handle it
  CMP  W CS:Int2FHdr.OldVector[2],0 ;Is the Old Vector valid?
  JE   Int2FDone                    ;If not, handle it
  JMP  D CS:Int2FHdr.OldVector      ;If so, go to the next one in the chain
Int2FDone:                          ;Invalid vector before us
  IRET

Int2FInstall:
  CMP  AL,MuxInstallChk ;Is it Install Check?
  JNZ  Int2FProgName    ;If not, try the next possibility
  MOV  AL,-1            ;Mark the flag byte
  IRET

Int2FProgName:
  CMP  AL,MuxGetProgName ;Is it Get Program Name?
  JNE  Int2FProgVer      ;If not, try the next possibility
  OR   DI,DI             ;Does DI = 0?
  JNZ >N90               ;If not, it's not for us
  MOV  ES,CS             ;If so, point ES:[DI]
  MOV  DI,ProgName       ;  at ProgName
N90:                     ;Done
  IRET

Int2FProgVer:
  CMP  AL,MuxGetProgVer ;Is it Get Program Version?
  JNE  Int2FAuthor      ;If not, try the next one
  MOV  AX,CS:ProgVer    ;If so, do it
  IRET

Int2FAuthor:
  CMP  AL,MuxGetAuthor ;Is it Get Author?
  JNE >A90             ;If not, we're done
  MOV  ES,CS           ;If so, point ES:[DI]
  MOV  DI,Author       ;  at Author
A90:                   ;Done
  IRET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO LOOK FOR NEW USB DEVICES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;CHECK AND SEE IF THERE IS A NEW DEVICE CONNECTED, AND HANDLE IT IF IT IS
;Inputs:  DS = ES = Our Data Area
;         CLD already issued
;Outputs:
;Changes: Looks for new, unowned (unconfigured) Devices
;         If one is found, it is Configured and pointed at us
;NOTES:   When we first install this program into memory, we Registered with
;           the USB Drivers that we wanted to be informed as soon as a new
;           Device was attached.  We also poll the hosts periodically for a
;           new Device, just in case we somehow missed the Host informing us.
;         Whether this is in response to the Host telling us, or whether we
;           polled to find out, this section of code is called.
;         This section of code is actually a series of short pieces of code,
;           which are disjointed in time.  One section schedules a USB Request
;           with the Host Driver, and gives the Host Driver the address
;           of the NEXT section of code to perform when the Request is
;           completed.
;         Requests sent to a USB Host can take anywhere from a few
;           milliseconds to several hundred milliseconds to complete.
;         It is very bad for a TSR to just sit around waiting for something
;           to happen, especially when it can be a long time in coming.
;         This back-and-forth approach between the Host Driver and the Device
;           Driver makes the TSR run pretty efficiently.
;------------------------------------------------------------------------------
LookForNewDevice:
  CALL FindEmptyInfoBX               ;Look for an empty Info Table Entry (BX)
  JZ  >L901                          ;If none, just quit
  TEST TSRFlags2,Int14ReqInUse       ;Is the Request Structure already in use?
  JNZ >L901                          ;If so, just quit
  OR   TSRFlags2,Int14ReqInUse       ;If not, mark it as in use now
  MOV  SI,Int14Request               ;Point at our Int 14 Structure
  MOV  [SI].I14RRequestType,I14RRTFindUnRegIntf ;Request Type = Find Interface
  MOV  [SI].I14RHostIndex,-1         ;Any/All Hosts
  MOV  [SI].I14RSearchIndex,0        ;Start with Search Index 0
L10:                                 ;Loop to here to find Device
  CALL DoInt14CallCXDXSI             ;Do it (uses DS:SI, CH = Addr, CL = Host,
                                     ;  DL = Interface, DH = Alt Interface)
  JC  >L80                           ;If no device, we're done
  CALL TestBadDevice                 ;If one there, is it in our Bad List?
  JC  >L20                           ;If not, continue
  INC  [SI].I14RSearchIndex          ;If so, Increment the Search Index
  JMP  L10                           ;Keep looking
L20:                                 ;Found a possible Device!
  MOV  [SI].I14RRequestType,I14RRTConfigingIntf ;Request Type = Configing
  MOV  W [SI].I14RHostIndex,CX       ;Store Host Index & Device Address
  CALL DoInt14CallSaveAllSI          ;Do it
  JNC >L30                           ;If OK, continue
  MOV  Int08Counter,2                ;If not, Look again Soon
  JMP >L80                           ;Done for now
L901:                                ;To avoid JMP > 128
  JMP >L90
L30:                                 ;OK to Configure Interface
  MOV  NewDeviceStage,0              ;Stage
  MOV  NewDeviceError,0              ;  Zero
  CALL TestAltIntfKeyb               ;Is it possibly a Keyboard?
  JC  >L75                           ;If not, mark it as Bad
  MOV  NewDeviceStage,1              ;Update Stage
  OR   [BX].DIFlags,DIFlagInUse      ;Mark Info Table entry as in use
  MOV  W [BX].DIHostIndex,CX         ;Store Host Index & Device Address
  MOV  [BX].DIInterfaceNum,DL        ;Store Interface Number
  MOV  [SI].I14RUserPktID,BX         ;Set User Pkt ID to Info Table Offset
  MOV  [SI].I14RRequestType,I14RRTDoControl ;Request Type = Control
;  MOV  [SI].I14RInterfaceNum,DL      ;Store Interface Number
  MOV  [SI].I14REndPoint,0           ;EndPoint 0
  MOV  CX,SetAltIntfReq              ;Copy
  CALL CopySetupReqToInt14SI         ;  Request Pkt
  MOV  B [SI].I14RSetAltIntfIntf,DL          ;Store Interface in Request
  MOV  B [SI].I14RSetAltIntfAltIntf,DH       ;Store Alt Interface in Request
  MOV  W [SI].I14RCallBackAddr[0],AltIntfSet ;Go here when done
  OR   [SI].I14RFlags,I14RFlagNoRetries ;No retries
  CALL DoInt14CallAXSI               ;Do it
  JNC >L90                           ;If it worked, we're done
L70:                                 ;Error
  MOV  NewDeviceStage,2              ;Update Stage
L75:                                 ;Mark as Bad
  CALL FinishUpBadDevice             ;If not, mark it as bad
  JMP >L90                           ;Done
L80:                                 ;No New Devices
  AND  TSRFlags2,(NOT Int14ReqInUse) ;Mark the request as available
L90:                                 ;Done
  RET                                ;NOT RETF here!

;------------------------------------------------------------------------------
;Inputs: [BX] = Info Table Pointer
;NOTE: Some Devices will not accept a Set Alternate Interface Request,
;        so an error here does not necessarily indicate a bad Device!
;------------------------------------------------------------------------------
AltIntfSet:
  MOV  NewDeviceStage,10     ;Update Stage
  CALL ClearDescriptorData   ;Clear out the data buffer
  MOV  SI,Int14Request       ;Point at Int14 Request Structure
  AND  [SI].I14RFlags,(NOT I14RFlagNoRetries) ;Allow retries again
  MOV  CX,GetDvcDescrReq     ;Copy
  CALL CopySetupReqToInt14SI ;  Request Pkt
  MOV  W [SI].I14RDataAddress[0],DvcDescrData    ;Put data here
  MOV  W [SI].I14RCallBackAddr[0],GotDeviceDescr ;Go here when done
  CALL DoInt14CallAXSI       ;Do it
  JNC >I90                   ;If it worked, we're done
  MOV  NewDeviceStage,11     ;Update Stage
I70:                         ;Error
  CALL FinishUpBadDevice     ;Mark it as Bad
I90:                         ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Info Table Pointer
;------------------------------------------------------------------------------
GotDeviceDescr:
  MOV  NewDeviceStage,20     ;Update Stage
  JNZ >D70                   ;If Error, handle it
  MOV  SI,Int14Request       ;Point at Int14 Request Structure
  MOV  CX,GetCfgDescrReq     ;Copy
  CALL CopySetupReqToInt14SI ;  Request Pkt
  MOV  W [SI].I14RDataAddress[0],DescriptorData  ;Put data here
  MOV  W [SI].I14RCallBackAddr[0],GotConfigDescr ;Go here when done
  CALL DoInt14CallAXSI       ;Do it
  JNC >D90                   ;If it worked, we're done
  MOV  NewDeviceStage,21     ;Update Stage
D70:                         ;Error
  CALL FinishUpBadDevice     ;Mark it as Bad
D90:                         ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Info Table Pointer
;------------------------------------------------------------------------------
GotConfigDescr:
  MOV  NewDeviceStage,30        ;Update Stage
  JNZ >P70                      ;If Error, handle it
;  JNZ >O70                      ;If Error, handle it
;  MOV  SI,Int14Request          ;Point at Int14 Request Structure
;  MOV  CX,SetHIDProtocolReq     ;Copy
;  CALL CopySetupReqToInt14SI    ;  Request Pkt
;  MOV  AL,[SI].I14RInterfaceNum               ;Set
;  MOV  B [SI].I14RSetHIDProtocolIntf,AL       ;  Interface Number
;  MOV  W [SI].I14RCallBackAddr[0],ProtocolSet ;Go here when done
;  CALL DoInt14CallAXSI          ;Do it
;  JNC >O90                      ;If it worked, we're done
;  MOV  NewDeviceStage,31        ;Update Stage
;O70:                            ;Error
;  CALL FinishUpBadDevice        ;Mark it as Bad
;O90:                            ;Done
;  RETF
;
;;------------------------------------------------------------------------------
;;Inputs: [BX] = Info Table Pointer
;;------------------------------------------------------------------------------
;ProtocolSet:
;  MOV  NewDeviceStage,40             ;Update Stage
;  JNZ >P70                           ;If Error, handle it
;  MOV  NewDeviceStage,41             ;Update Stage
  MOV  NewDeviceStage,31             ;Update Stage
  MOV  DI,DescriptorData             ;Point at Config Descriptor Data
  MOV  SI,Int14Request               ;Point at Int14 Request Structure
  MOV  AX,[DI].CDTotalLength         ;Get length of entire Descriptor
  CMP  AX,MaxDescriptorSize          ;Will it fit in our buffer?
  JAE >P70                           ;If not, Error
  MOV  CX,GetCfgDescrReq             ;Copy
  CALL CopySetupReqToInt14SI         ;  Request Pkt
  MOV  W [SI].I14RGetCfgDescrSize,AX ;Store the number of bytes
  MOV  W [SI].I14RCallBackAddr[0],GotCompleteConfig ;Go here when done
  CALL DoInt14CallAXSI               ;Do it
  JNC >P90                           ;If it worked, we're done
;  MOV  NewDeviceStage,42             ;Update Stage
  MOV  NewDeviceStage,32             ;Update Stage
P70:                                 ;Error
  CALL FinishUpBadDevice             ;Mark it as Bad
P90:                                 ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Info Table Pointer
;------------------------------------------------------------------------------
GotCompleteConfig:
  MOV  NewDeviceStage,50               ;Update Stage
  JNZ >C70                             ;If Error, handle it
  MOV  DI,DescriptorData               ;Point at Config Descriptor Data
  MOV  SI,Int14Request                 ;Point at Int14 Request Structure
  MOV  CX,SetHIDIdleReq                ;Copy
  CALL CopySetupReqToInt14SI           ;  Request Pkt
  MOV  AL,[SI].I14RInterfaceNum        ;Set
  MOV  B [SI].I14RSetHIDIdleIntf,AL    ;  Interface Number
  ;MOV  B [SI].I14RSetHIDIdleRptID,0    ;Report ID 0 (All Reports)
  MOV  B [SI].I14RSetHIDIdleDuration,1 ;Idle Duration = 6ms
  MOV  W [SI].I14RCallBackAddr[0],GetReportDescr ;Go here when done
  OR   [SI].I14RFlags,I14RFlagNoRetries ;No retries
  CALL DoInt14CallAXSI                 ;Do it
  JNC >C90                             ;If it worked, we're done
  MOV  NewDeviceStage,51               ;Update Stage
C70:                                   ;Error
  CALL FinishUpBadDevice               ;Mark it as Bad
C90:                                   ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Info Table Pointer
;NOTE: If Keyboards are anything like other Devices I've run across
;        (like mice), I expect at least some Devices will not accept a
;        Set HID Idle Duration Request, so an error here may not
;        necessarily indicate a Bad Device.
;      The program should probably still work OK even if the Keyboard's
;        Report Rate doesn't match our Interrupt polling rate, so it
;        should be OK.  We may find out different some day.
;------------------------------------------------------------------------------
GetReportDescr:
  MOV  NewDeviceStage,200                   ;Update Stage
  MOV  SI,Int14Request                      ;Point at Int14 Request Structure
  AND  [SI].I14RFlags,(NOT I14RFlagNoRetries) ;Allow retries again
  MOV  DI,DescriptorData                    ;Point at Config Data
  MOV  BL,[BX].DIInterfaceNum               ;Interface Number to look for
R10:                                        ;Loop to find Interface Descriptor
  MOV  AL,DescrTypeInterface                ;Look for an Interface
  CALL FindDescrType                        ;  Descriptor (rtns AX, DI)
  JC  >R70                                  ;If none found, Error
  CMP  [DI].IDInterfaceNumber,BL            ;Is it the Correct Interface?
  JE  >R20                                  ;If so, continue
  ADD  DI,AX                                ;If not, point at the next Descr
  JMP  R10                                  ;Keep looking
R20:                                        ;Found the Interface Descriptor
  MOV  NewDeviceStage,201                   ;Update Stage
  MOV  AL,DescrTypeHID                      ;Look for an HID
  CALL FindDescrType                        ;  Descriptor (rtns AX, DI)
  JC  >R70                                  ;If none found, Error
  MOV  NewDeviceStage,202                   ;Update Stage
  MOV  AX,[DI].HIDDDescriptorLength         ;Get Report Size
  CMP  AX,MaxReportSize                     ;Is it too big for our buffer?
  JAE >R70                                  ;If so, error
  MOV  CX,GetReportDescrReq                 ;Copy
  CALL CopySetupReqToInt14SI                ;  Request Pkt
  MOV  W [SI].I14RGetReportDescrSize,AX     ;Store number of bytes
  MOV  B [SI].I14RGetReportDescrIntf,BL     ;Store Interface Number
  ;MOV  B [SI].I14RGetReportDescrRptID,0     ;Report ID 0 (all reports)
  MOV  W [SI].I14RDataAddress[0],ReportData ;Where to put data
  MOV  W [SI].I14RCallBackAddr[0],SetupInts ;Go here when done
  CALL ClearReportData                      ;Clear out Report Data area
  MOV  NewDeviceStage,61                    ;Update Stage
  CALL DoInt14CallAXSI                      ;Do it
  JNC >R90                                  ;If it worked, we're done
R70:                                        ;Error
  CALL FinishUpBadDevice                    ;Mark it as Bad
R90:                                        ;Done
  RETF

;------------------------------------------------------------------------------
;Inputs: [BX] = Info Table Pointer
;------------------------------------------------------------------------------
SetupInts:
  MOV  NewDeviceStage,70                       ;Update Stage
  JNZ >I701                                    ;If error, mark it as bad
  MOV  NewDeviceStage,210                      ;Update Stage
  MOV  SI,Int14Request                         ;Point SI at Int14 Request
  CALL DecipherReportDescr                     ;Get Device Info from Report
  JC  >I701                                    ;If invalid, quit
  MOV  NewDeviceStage,211                      ;Update Stage
  CALL DecipherReportDescrSys                  ;If OK, look for System Keys
  MOV  DI,DescriptorData                       ;Point DI at Config Data
  MOV  CL,[BX].DIInterfaceNum                  ;Interface Number to look for
I10:                                           ;Loop to find Interface Descr
  MOV  AL,DescrTypeInterface                   ;Look for an Interface
  CALL FindDescrType                           ;  Descriptor (rtns AX, DI)
  JC  >I701                                    ;If none found, Error
  MOV  NewDeviceStage,212                      ;Update Stage
  CMP  [DI].IDInterfaceNumber,CL               ;Is it the Correct Interface?
  JE  >I20                                     ;If so, continue
  ADD  DI,AX                                   ;If not, point at the next Descr
  JMP  I10                                     ;Keep looking
I20:                                           ;Found the Interface Descriptor
  MOV  AL,DescrTypeEndPoint                    ;Look for an EndPoint
  CALL FindDescrType                           ;  Descriptor (rtns AX, DI)
  JC  >I701                                    ;If none found, Error
  MOV  NewDeviceStage,213                      ;Update Stage
  MOV  [SI].I14RRequestType,I14RRTDoInterruptPer ;Periodic Interrupt
  MOV  [SI].I14RFlags,I14RFlagIn               ;Assume Direction = In
  MOV  [SI].I14RPeriodicity,10                 ;Periodicity = 10 ms
  MOV  NewDeviceStage,214                      ;Update Stage
  MOV  AX,[DI].EDMaxPktSize                    ;Get Data Size
  CMP  AX,4                                    ;Is it too small?
  JB  >I70                                     ;If so, error
  CMP  AX,MaxKeybDataSize                      ;Is it too big?
  JBE >I30                                     ;If not, continue
I701:                                          ;To avoid JMP > 128
  JMP >I70
I30:                                           ;Data Size is OK
  MOV  [SI].I14RDataSize,AX                    ;If OK, store it
  MOV  NewDeviceStage,215                      ;Update Stage
  MOV  AL,[DI].EDEndPointNumber                ;Get EP Address & Direction
  TEST AL,EDDirectionIn                        ;Is it In (it better be!)
  JZ  >I70                                     ;If not, error
  MOV  NewDeviceStage,216                      ;Update Stage
  AND  AL,EDNumberMask                         ;Store the
  MOV  [SI].I14REndPoint,AL                    ;  EndPoint
  MOV  [BX].DIEndPoint,AL                      ;  Number
  LEA  AX,[BX].DIRawData                       ;Where to
  MOV  W [SI].I14RDataAddress[0],AX            ;  put data
  CMP  [BX].DIReportID,0                       ;Is there a Report ID?
  JE  >I40                                     ;If not, Data Address is OK
  DEC  W [SI].I14RDataAddress[0]               ;If so, Data will include ID
I40:                                           ;Data Address is OK
  MOV  W [SI].I14RCallBackAddr[0],DeviceChangeCode ;Code to call
  MOV  NewDeviceStage,73                       ;Update Stage
  CALL DoInt14CallAXCXSI                       ;Do it
  JC  >I70                                     ;If error, quit
  MOV  [BX].DIIntHandle,CX                     ;Save the Interrupt Handle
  MOV  LastDeviceFound,BX                      ;Mark this as the Last Device
  MOV  [SI].I14RRequestType,I14RRTRegIntfOwner ;Register as Owner
  MOV  W [SI].I14RCallBackAddr[0],DvcOwnerFarCall ;Owner Address
  CALL DoInt14CallAXCXSI                       ;Do it
  MOV  [BX].DIRegHandle,CX                     ;Store the Registry Handle
  JNC >I80                                     ;If it worked, we're done
  MOV  NewDeviceStage,75                       ;Update Stage
  MOV  AX,[BX].DIIntHandle                     ;If not,
  MOV  [SI].I14RRequestHandle,AX               ;  we need
  MOV  [SI].I14RRequestType,I14RRTCloseHandle  ;  to stop the
  CALL DoInt14CallAXSI                         ;  Periodic Interrupt
I70:                                           ;Error
  CALL FinishUpBadDevice                       ;Mark it as Bad
  JMP >I90                                     ;Done
I80:                                           ;Device is OK
  MOV  [BX].DILockStatusLT,-1                  ;Make sure we update the LEDs
  MOV  [SI].I14RRequestType,I14RRTConfigIntfDone ;Request = Done Configuring
  CALL DoInt14CallSaveAllSI                    ;Do it
  CMP  Int08Counter,0                          ;Disabled?
  JE  >I85                                     ;If so, quit
  MOV  Int08Counter,2                          ;Look for another Device soon
I85:                                           ;Done for now
  AND  TSRFlags2,(NOT Int14ReqInUse)           ;Mark the request as available
I90:                                           ;Done
  RETF


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT FUNCTIONS NEEDED BY LOOKFORNEWDEVICE PROCESS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;TEST AND SEE IF THE DEVICE COULD POSSIBLY BE A KEYBOARD
;Inputs:  DS = ES = TSR Data Area
;         [SI] = Int 14 Request to use
;                  Host Index & Device Address filled in
;         DL = Interface Number
;         DH = Alternate Interface Number
;Outputs: CF = Clear if OK (Device is, or could be, a Keyboard)
;            = Set if Not (cannot be a Keyboard)
;                TSRFlags2.NoBeep1Time Set
;Changes: [SI] filled in with Interface, Alt Interface, & Request Type
;NOTES: The only thing this tests is the Interface SubClass & Protocol
;------------------------------------------------------------------------------
TestAltIntfKeyb:
  PUSH BX,CX                    ;Save used registers
  MOV  [SI].I14RRequestType,I14RRTGetAltIntfInfo ;Request = Get Alt Intf Info
  MOV  [SI].I14RInterfaceNum,DL ;Store Interface
  MOV  [SI].I14RAltInterface,DH ;Store Alternate Interface
  CALL DoInt14CallBXCXSI        ;Issue the Request
  CMP  BH,IntfSubClassHIDBoot   ;Interface SubClass = None or Boot?
  JA  >F70                      ;If neither, Error
  JB  >F30                      ;If None, continue
F10:                            ;SubClass = Boot
  CMP  CL,IntfProtocolHIDKeyb   ;Is it a Keyboard?
  JE  >F80                      ;If so, continue
  JMP >F70                      ;If not, Error
F30:                            ;SubClass = None
  OR   CL,CL                    ;Protocol = None?
  JZ  >F80                      ;If so, continue
F70:                            ;Error
  OR   TSRFlags2,NoBeep1Time    ;Don't want to Beep
  STC                           ;Set return flag
  JMP >F90                      ;Done
F80:                            ;OK
  CLC                           ;Set return flag
F90:                            ;Done
  POP  CX,BX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FINISH UP A BAD DEVICE ENTRY
;Inputs:  BX = Info Table Offset
;         (Info Table Entry contains Device Data)
;         DS = ES = TSR Data Area
;         Int14Request (contains Host/Address/Interface Data)
;Outputs: Resets DeviceInfoTable Entry
;         Marks Int14Request as available (not in use any more)
;         Updates NewDeviceStage & NewDeviceError
;         Puts Device info in BadDevice Table
;         Issues Request to Beep the Speaker
;Changes: DI,SI
;------------------------------------------------------------------------------
FinishUpBadDevice:
  MOV  SI,Int14Request               ;Point at Int14 Request Structure
  MOV  NewDeviceError,AX             ;Store Error Code
  CALL ResetDvcEntryBX               ;Reset the Dvc Info Entry that we Reserved
  MOV  [SI].I14RRequestType,I14RRTGetDvcStatus ;Request = Get Dvc Status
                                               ;(Make sure Device is still
                                               ;  plugged in)
  CALL DoInt14CallSaveAllSI          ;Issue the Request
  JC  >B10                           ;If error (no Device), don't add to Bad Tbl
  CALL AddBadDevice                  ;Add it to Bad Table
B10:                                 ;Bad Device added to table, if appropriate
  TEST TSRFlags,NoBeep               ;Are we allowed to Beep the Speaker?
  JNZ >B20                           ;If not, skip down
  TEST TSRFlags2,NoBeep1Time         ;Are we allowed to Beep the Speaker?
  JNZ >B20                           ;If not, skip down
  MOV  [SI].I14RRequestType,I14RRTBeepSpeaker ;Want to beep the Speaker
  MOV  [SI].I14RHostIndex,-1         ;Any Host
  MOV  B [SI].I14RTimeout,3          ;Beep length = 3 DeciSeconds
  MOV  W [SI].I14RBeepFrequency,300  ;Frequency = 300Hz
  CALL DoInt14CallSaveAllSI          ;Do it
  MOV  B [SI].I14RTimeOut,0          ;Reset Timeout Value
B20:                                 ;Done Handling Beep
  AND  TSRFlags2,(NOT NoBeep1Time)   ;Mark as OK to Beep next time
  MOV  [SI].I14RRequestType,I14RRTConfigIntfDone ;Request = Done Configuring
  CALL DoInt14CallSaveAllSI          ;Do it
  CMP  Int08Counter,0                ;Disabled?
  JE  >B90                           ;If so, Done
  MOV  Int08Counter,2                ;Look for another Device soon
B90:                                 ;Done
  AND  TSRFlags2,(NOT Int14ReqInUse) ;Mark the request as available
  RET

;------------------------------------------------------------------------------
;CLEAR OUT THE OLD DATA FROM THE DESCRIPTOR DATA BUFFER
;Inputs:  ES = TSR Data Area
;         CLD already issued
;Outputs:
;Changes: DescriptorData becomes all zeroes
;------------------------------------------------------------------------------
ClearDescriptorData:
  PUSH AX,CX,DI        ;Save used registers
  MOV  DI,DvcDescrData ;Point at buffer
  MOV  CX,((DeviceDescriptorSize+MaxDescriptorSize)/2) ;Number of words to write
  XOR  AX,AX           ;Write zeroes
  REP  STOSW           ;Do it
  POP  DI,CX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CLEAR OUT THE OLD DATA FROM THE REPORT DATA BUFFER
;Inputs:  ES = TSR Data Area
;Outputs:
;Changes: ReportData becomes all zeroes
;------------------------------------------------------------------------------
ClearReportData:
  PUSH AX,CX,DI             ;Save used registers
  MOV  DI,ReportData        ;Point at buffer
  MOV  CX,(MaxReportSize/2) ;Number of words to write
  XOR  AX,AX                ;Write zeroes
  REP  STOSW                ;Do it
  POP  DI,CX,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND A PARTICULAR TYPE OF DESCRIPTOR IN THE COMPLETE CONFIGURATION DESCRIPTOR
;Inputs:  DS = ES = TSR Data Area
;         [DI] = Pointer to start/middle of Configuration Descriptor
;          AL  = Descriptor Type to find
;Outputs: CF = Set if OK (Descriptor Found)
;              [DI] points at beginning of Descriptor
;               AX = Descriptor Length
;            = Clear if Error (Descriptor not found)
;              AX, DI unchanged
;Changes:
;------------------------------------------------------------------------------
FindDescrType:
  PUSH BX,SI               ;Save used registers
  MOV  SI,DI               ;Point SI at the starting Pointer
  XOR  BH,BH               ;Initialize high byte of Size to 0
Y10:                       ;Loop here to find Descriptor
  MOV  BL,[SI].DDLength    ;Put the Length in BL
  OR   BL,BL               ;Valid Descriptor?
  JZ  >Y70                 ;If not, Error
  CMP  AL,[SI].DDDescrType ;The Descriptor we're looking for?
  JE  >Y80                 ;If so, we're done
  ADD  SI,BX               ;If not, point at next Descriptor
  CMP  SI,(DescriptorData+MaxDescriptorSize) ;Gone past the end of the buffer?
  JBE  Y10                 ;If not, keep looking
Y70:                       ;Error
  STC                      ;Set Error Flag
  JMP >Y90                 ;Done
Y80:                       ;OK
  MOV  DI,SI               ;Update Pointer
  MOV  AX,BX               ;Put length in AX
  CLC                      ;Set OK Flag
Y90:                       ;Done
  POP  SI,BX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY A REQUEST (CONTROL) STRUCTURE INTO THE INT14 STRUCTURE
;Inputs:  [CX] = Request Structure to Copy
;         ES = TSR Data Area (contains both Request & Int14 Request)
;         [DI] = Int14 Request Structure to copy it to
;      or [SI] = Int14 Request Structure to copy it to
;Outputs:
;Changes: Int14 Structure contains Request Structure Data
;------------------------------------------------------------------------------
CopySetupReqToInt14SI:
  PUSH DI                    ;Save used registers
  MOV  DI,SI                 ;Put pointer in DI
  CALL CopySetupReqToInt14DI ;Copy it
  POP  DI                    ;Restore used registers
  RET

CopySetupReqToInt14DI:
  PUSH CX,DI,SI,DS                ;Save used registers
  MOV  DS,ES                      ;Point DS at TSR Data Area
  ADD  DI,OFFSET I14RSetupReqData ;Point at correct part of structure
  MOV  SI,CX                      ;Point at structure to copy
  MOV  CX,(SetupRequestSize/2)    ;Number of words to copy
  REP  MOVSW                      ;Copy it
  POP  DS,SI,DI,CX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;DECIPHER THE REPORT DESCRIPTOR TO DETERMINE THE DEVICE CHARACTERISTICS
;Inputs:  ReportData
;         DS = ES = TSR Data Area
;         [DI] = Info Table Entry
;Outputs: CF = Clear if OK (found some valid Data)
;            = Set if Error (not a Valid Keyboard)
;Changes:
;NOTES: We will assume that the Keyboard and the Report Descriptor don't do
;         or have anything really weird.  We just assume that they do
;         basically the same thing with the Report Protocol that they do
;         with the Boot Protocol.
;       The only thing we actually check for is a "Shift Key" section, where
;         the Shift Keys are bit-mapped as a single byte.  We ignore
;         everything else about the keyboard (LEDs, the "real" keys on the
;         keyboard, or any extra stuff that the keyboard might have
;         (Consumer Keys, extra LED's, etc.).
;       We do check for a Report ID.
;       A keyboard with some Special "System" Keys (Shutdown, Sleep, WakeUp,
;         etc.) will hopefully have a Different Interface for that, and not
;         send things through the Keyboard Interface, and we won't have a
;         problem.
;       At some point in time, we may need to add things like Sleep and Wakeup
;         (APM/ACPI) functionality to this program, but for now we don't care.
;------------------------------------------------------------------------------
DecipherReportDescr:
  PUSH AX,BX,DI,SI                                ;Save used registers
  MOV  BX,DI                                      ;Point BX at Info Table Entry
  MOV  SI,ReportData                              ;Point at Data
  MOV  DI,(ReportData+MaxReportSize)              ;Point at end of data
  OR   TSRFlags2,NoBeep1Time                      ;Assume No Beeps
  MOV  AX,RptTagUsagePage+(RptGlbUPGenericDesktop SHL 8) ;Usage Page
  CALL TestReportTagByte                          ;  Generic Desktop?
  JC  >D70                                        ;If not, error
D10:                                              ;Loop to here to find Usage
  MOV  AL,RptTagUsage                             ;Look for
  CALL LookForReportTag                           ;  a Usage
  JC  >D70                                        ;If none found, quit
  CMP  AL,RptGDKeyboard                           ;Is it a Keyboard?
  JNE  D10                                        ;If not, keep looking
  AND  TSRFlags2,(NOT NoBeep1Time)                ;Allow Beeps Again
  MOV  AL,RptTagReportID                          ;Look for
  CALL LookForReportTag                           ;  a Report ID
  JC  >D20                                        ;If none, continue (ReportID = 0)
  MOV  [BX].DIReportID,AL                         ;If found, store it
D20:                                              ;Look for Shift Keys
  MOV  AL,RptTagUsagePage                         ;Look for a
  CALL LookForReportTag                           ;  Usage Page
  JC  >D70                                        ;If none, Error
  CMP  AL,RptGDKeyPad                             ;If so, is it a KeyPad?
  JNE  D20                                        ;If not, keep looking
  MOV  AX,RptTagUsageMin+(RptKbdLControl SHL 8)   ;Usage Minimum
  CALL TestReportTagByte                          ;  Left Control?
  JC  >D70                                        ;If not, error
;  MOV  AX,RptTagLogicalMin+(0 SHL 8)              ;Logical Minimum
;  CALL TestReportTagByte                          ;  0?
;  JC  >D70                                        ;If not, error
  MOV  AX,RptTagReportCount+(8 SHL 8)             ;Report Count
  CALL TestReportTagByte                          ;  8?
  JC  >D70                                        ;If not, error
  MOV  AX,RptTagInput+(RptMainIOFVariable SHL 8)  ;Input
  CALL TestReportTagByte                          ;  Variable Absolute?
  JC  >D70                                        ;If not, error
D30:                                              ;Look for BIOS Modifier Byte
  MOV  AX,RptTagInput+(RptMainIOFConstant SHL 8)  ;Input
  CALL TestReportTagByte                          ;  Constant Absolute?
;  JC  >D70                                        ;If not, error
  JNC >D80                                        ;If so, we';'re done
;D40:                                              ;Look for LEDs
  ;NOTE: On most keyboards I've seen, LEDs are listed after all the
  ;        keys, but on at least one they're listed before.
  ;      We'll just assume that the LEDs are there and are the correct ones.
  ;      That could cause us trouble on some keyboards, but I doubt it.
;  MOV  AX,RptTagUsagePage+(RptGlbUPLED SHL 8)     ;Usage Page
;  CALL TestReportTagByte                          ;  LED?
;  JC  >D70                                        ;If not, error
;  MOV  AX,RptTagUsageMin+(RptLEDNumLock SHL 8)    ;Usage Minimum
;  CALL TestReportTagByte                          ;  NumLock?
;  JC  >D70                                        ;If not, error
;  MOV  AX,RptTagOutput+(RptMainIOFVariable SHL 8) ;Output
;  CALL TestReportTagByte                          ;  Variable Absolute?
;  JC  >D70                                        ;If not, error
;D50:                                              ;Look for Regular Keys
;  MOV  AX,RptTagUsagePage+(RptGDKeyPad SHL 8)     ;Usage Page
;  CALL TestReportTagByte                          ;  KeyPad?
;  JC  >D70                                        ;If not, error
;  MOV  AX,RptTagUsageMin+(0 SHL 8)                ;Usage Minimum
;  CALL TestReportTagByte                          ;  0?
;  JC  >D70                                        ;If not, error
;  MOV  AX,RptTagInput+(0 SHL 8)                   ;Input
;  CALL TestReportTagByte                          ;  Data Array Absolute?
;  JNC  >D80                                       ;If so, Keyboard is OK!
D70:                                              ;Error
  STC                                             ;Set Error Flag
  JMP >D90                                        ;Done
D80:                                              ;OK
  CLC                                             ;Set OK Flag
D90:                                              ;Done
  POP  SI,DI,BX,AX                                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;DECIPHER THE REPORT DESCRIPTOR TO FIND THE SYSTEM KEYS (IF THEY ARE THERE)
;Inputs:  ReportData
;         DS = ES = TSR Data Area
;         [BX] = Info Table Entry (already contains Interface Number)
;         ReportData already deciphered for Regular Keyboard data
;Outputs: DISysReportID
;         Sets Idle Rate for System Keys Report ID to 10ms
;Changes: Int14Request
;NOTES: Since System Keys are considered as coming from a different kind
;         of Device than regular USB Keys, it may use Report IDs.
;       The second Report coming from the Keyboard may contain the
;         System Keys (Power/Sleep/WakeUp).  We will do a simple deciphering
;         of the Keyboard Report Decriptor, and if we find a System Control
;         Report ID, we will handle it.  At least for now, we will assume
;         all Reports will be in the same format.
;------------------------------------------------------------------------------
DecipherReportDescrSys:
  PUSH AX,CX,DI,SI                          ;Save used registers
  CMP  [BX].DIReportID,0                    ;Is there a second Report ID?
  JE  >Y90                                  ;If no, we're done
  MOV  SI,ReportData                        ;Point at Data
  MOV  DI,(ReportData+MaxReportSize)        ;Point at end of data
Y10:                                        ;Look for System Control here
  MOV  AL,RptTagUsage                       ;Look for
  CALL LookForReportTag                     ;  Usage
  JC  >Y90                                  ;If none, Quit
  CMP  AL,RptGDSysCtl                       ;Is it System Control?
  JNE  Y10                                  ;If not, keep looking
  MOV  AL,RptTagReportID                    ;Look for
  CALL LookForReportTag                     ;  a Report ID
  JC  >Y90                                  ;If none, Quit
  MOV  [BX].DISysReportID,AL                ;If found, store it
Y40:                                        ;Set Idle Rate for Keys
  MOV  SI,Int14Request                      ;Point at Request Structure
  MOV  [SI].I14RRequestType,I14RRTDoControl ;Type = Control
  MOV  CX,SetHIDIdleReq                     ;Point at Idle Request Struc
  CALL CopySetupReqToInt14SI                ;Copy Setup Pkt (CX)
  MOV  B [SI].I14RSetHIDIdleRptID,AL        ;Store Report ID
  MOV  B [SI].I14RSetHIDIdleDuration,2      ;Idle Rate = 2 (10ms)
  MOV  AL,[BX].DIInterfaceNum               ;Copy the
  MOV  B [SI].I14RSetHIDIdleIntf,AL         ;  Interface Number
  MOV  W [SI].I14RCallBackAddr[0],-1        ;Do nothing when done
  CALL DoInt14CallSaveAllSI                 ;Do it
Y90:                                        ;Done
  POP  SI,DI,CX,AX                          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;LOOK FOR A SPECIFIC REPORT TAG AND VALUE FOR THE REPORT TAG
;Inputs:  [SI] = Report Pointer
;         [DI] = End of Report Data Area
;         AL   = Report Tag to Look for
;         AH   = Report Tag Value to look for (The Byte after the Tag)
;Outputs: CF = Clear if Tag was found
;             [SI] = Points to next Tag after the one found
;            = Set if Tag was not Found
;              SI = Unchanged
;Changes:
;NOTES: This finds the first matching Report Tag, and tests the value (byte)
;         immediately following that Report Tag.  It does not continue looking
;         in the Report Descriptor after the first Report Tag it finds.
;         In addition, if the Data does not match, it returns SI unchanged.
;------------------------------------------------------------------------------
TestReportTagByte:
  PUSH AX,BX            ;Save used registers
  MOV  BX,SI            ;Save original Pointer
  CALL LookForReportTag ;Look for the Tag
  JC  >B70              ;If not found, error
  CMP  AL,AH            ;Does the Value match?
  JE  >B80              ;If so, it's a match
  MOV  SI,BX            ;Restore original Pointer
B70:                    ;No match
  STC                   ;Set no match flag
  JMP >B90              ;Done
B80:                    ;It matches
  CLC                   ;Set matches flag
B90:                    ;Done
  POP  BX,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;LOOK FOR A SPECIFIC REPORT TAG IN THE REPORT DESCRIPTOR
;Inputs:  [SI] = Report Pointer
;         [DI] = End of Report Data Area
;         AL   = Report Tag to Look for
;Outputs: CF = Clear if Tag was found
;              AL  = Data Byte immediately following the Tag
;             [SI] = Points to next Tag after the one found
;            = Set if Tag was not Found
;              AL = 0
;              SI = Unchanged
;Changes:
;NOTES: This works under the premise that Data is at most one byte
;         after a Report Tag (which all Keyboard Data should be!)
;------------------------------------------------------------------------------
LookForReportTag:
  PUSH BX,CX,DX     ;Save used registers
  MOV  DX,SI        ;Save original pointer
  XOR  CH,CH        ;Size Adder is always a Byte
  MOV  BL,AL        ;Save Tag we're looking for
L10:                ;Loop to here to find the Tag
  LODSB             ;Get the next Tag
  OR   AL,AL        ;Legitimate Tag?
  JZ  >L70          ;If not, error
  MOV  CL,AL        ;Get the
  AND  CL,03h       ;  Data Size
  AND  AL,(NOT 03h) ;Mask out the Size so we can test it
  CMP  AL,BL        ;Is it the Tag we're looking for?
  JE  >L80          ;If so, we're done
  ADD  SI,CX        ;If not, point at the next one
  CMP  SI,DI        ;Are we past the end of the buffer?
  JB   L10          ;If not, keep looking
L70:                ;Error
  XOR  AL,AL        ;AL = 0
  MOV  SI,DX        ;Restore original Pointer
  STC               ;Set Error Flag
  JMP >L90          ;Done
L80:                ;Found it
  MOV  AL,[SI]      ;Put the Data Byte in AL
  ADD  SI,CX        ;Update the Pointer
  CLC               ;Set OK Flag
L90:                ;Done
  POP  DX,CX,BX     ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PROCESS NOTIFICATIONS FROM THE HOST DRIVER REGARDING DEVICE CHANGES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HANDLE A NOTIFICATION FROM THE HOST DRIVER FOR SOMETHING RELATED TO THE DEVICE
;Inputs:  AX = Device Owner Call Code (various possibilities)
;         [BX] = Info Table Offset
;         CX, DX = Varies by exact type of call
;         DS = ES = TSR Data Area
;Outputs: Depends on Call Type
;         Calls appropriate "subfunction"
;Changes: Nearly all registers
;------------------------------------------------------------------------------
DvcOwnerFarCall:
  CLD                          ;Go forward with string functions
  MOV  DI,BX                   ;Point DI at the Info Table Entry
  MOV  BX,OwnerCallFunctionTbl ;Point at the Function table to search
  CALL SearchByte2WordTblES    ;Look for the function (in AL)
  JC  >H90                     ;If invalid function, quit
  CALL BX                      ;If OK, do it
H90:
  RETF

;------------------------------------------------------------------------------
;HANDLE A REQUEST FROM THE HOST SAYING THAT A NEW DEVICE HAS BEEN ADDED
;Inputs:  [DI] = Info Table Entry
;         DS = ES = TSR Data Area
;         CL = Host Index
;         CH = Device Address
;         DL = Interface
;         DH = Alternate Interface
;Outputs:
;Changes: Prompts us to look for a new Device earlier than normal
;NOTES:   Originally, this routine directly called LookForNewDevice.
;         For some reason, this did not work with some Devices (they would
;           return bad Descriptors).  This is probably due to the Devices not
;           being given enough time to "reorganize" themselves after the
;           enumeration process of the Host Driver, which downloads the same
;           descriptors we download again here.
;         So now, instead of calling LookForNewDevice directly, this routine
;           sets the Int08Counter to a small number so that we look for
;           the new Device after a small delay.  Doing it after a small
;           delay, instead of doing it immediately, seems to work better
;           (at least with some Devices).
;------------------------------------------------------------------------------
DeviceAdded:
  CMP  Int08Counter,0 ;Disabled?
  JE  >A90            ;If so, quit
  MOV  Int08Counter,2 ;If not, look for a new Device right away
A90:                  ;Done
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST FROM THE HOST SAYING THAT A DEVICE HAS BEEN DISCONNECTED
;Inputs:  [DI] = Info Table Entry
;         DS = ES = TSR Data Area
;         CL = Host Index
;         CH = Device Address
;Outputs:
;Changes: Removes Device from Configuration
;NOTES:   This is called if a REGISTERED Device has been disconnected
;------------------------------------------------------------------------------
DeviceDisconnected:
  CALL RlsPendingKeys  ;Release any pending keystrokes
  CALL ResetDvcEntryDI ;Delete entry from our table
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST FROM THE HOST SAYING THAT AN UNREGISTERED DEVICE IS DISCO'D
;Inputs:  DS = ES = TSR Data Area
;         CL = Host Index
;         CH = Device Address
;Outputs:
;Changes:
;NOTES: This is called if an UNREGISTERED Device has been disconnected,
;         so it will NOT be in DeviceInfoTable.  It may or may not be
;         in the BadDeviceTable.
;------------------------------------------------------------------------------
Device0Disconnected:
  CALL DeleteBadDevices ;Delete the Bad Entries from our Table, if there
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST FROM THE HOST TO TEMPORARILY STOP LOOKING FOR DEVICES
;Inputs:  DS = ES = TSR Data Area
;         CL = Host Index
;         CH = Device Address
;         DL = Interface Number
;         DH = TimeOut Value to use (deciseconds)
;         DI = Device Info Table Entry
;Outputs: DontLookCounter
;Changes:
;NOTES: This should only be called if a Device-specific Driver is trying
;         to take control of an already registered device from us.
;       We actually stop looking for ALL new Interfaces, rather than just
;         the one that is being requested.
;------------------------------------------------------------------------------
StartDontLook:
  PUSH AX,BX,DX,SI        ;Save used registers
  MOV  DontLookCounter,-1 ;Start not looking
  MOV  SI,Int14Request2   ;Point at Request Structure
  CALL RlsPendingKeys     ;Release any pending keystrokes
  CALL RlsDvcNoResetDI    ;Release the Device, don't Reset it
  MOV  AL,DH              ;Put seconds in AL
  XOR  AH,AH              ;Multiply
  MOV  BX,18206           ;  seconds
  MUL  BX                 ;  by
  MOV  BX,10000           ;  1.8206
  DIV  BX                 ;  (number of timer ticks per decisecond)
  CMP  DX,5000            ;Do we need to round up?
  JB  >S90                ;If not, continue
  INC  AX                 ;If so, round up
S90:                      ;Done
  INC  AX                 ;Add one more Timer Tick for good measure
  MOV  DontLookCounter,AX ;Store the Counter Value
  POP  SI,DX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A REQUEST FROM A HOST SAYING THAT IT'S BEEN UNINSTALLED
;Inputs:  CL = USB Host Index that isn't there any more
;         DS = ES = TSR Data Area
;Outputs:
;Changes:
;------------------------------------------------------------------------------
HostDisconnected:
  PUSH BX,DI                    ;Save used registers
  MOV  DI,DeviceInfoTable       ;Point at table
  MOV  BL,MaxDevices            ;Number of table entries
D20:                            ;Loop to here for each table entry
  TEST [DI].DIFlags,DIFlagInUse ;Empty Table Entry?
  JZ  >D40                      ;If so, skip it
  CMP  [DI].DIHostIndex,CL      ;Is it the Host this Device is on?
  JNE >D40                      ;If not, skip it
  CALL RlsPendingKeys           ;If so, release any pending keystrokes
  CALL ResetDvcEntryDI          ;Delete it from the Info Table
D40:                            ;Done with this table entry
  ADD  DI,DeviceInfoStrucSize   ;Point at the next Table Entry
  DEC  BL                       ;Decrement loop counter
  JNZ  D20                      ;If not done yet, keep looking
  CMP  CL,UserTblHost           ;Is it the Host that our User Interrupt is on?
  JNE >D90                      ;If not, we're done
  MOV  UserTblHost,-1           ;If so, mark us as not having a User Interrupt
  CALL SetupUserInt             ;Setup a new User Interrupt
D90:                            ;Done
  POP  DI,BX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE VARIOUS REQUESTS FROM THE USB HOST DRIVER ABOUT UPSTREAM CHANGES
;Inputs:  Depends on Call
;Outputs:
;Changes: We don't care about any of these calls, since they don't directly
;           affect our program.  Any critical changes to upstream devices
;           are eventually reflected to us as a call directly addressing
;           one of our Devices, which is how we handle those things.
;------------------------------------------------------------------------------
DeviceEnabled:        ;Device Enabled
DeviceDisabled:       ;Device Disabled
DeviceReset:          ;Device Reset
DeviceSuspend:        ;Device Suspended
DeviceResume:         ;Device Resumed
DevicePowerOn:        ;Device Power On
DevicePowerOff:       ;Device Power Off
DevicePowerReset:     ;Device Power Reset
NewHostAdded:         ;New Host Added
HostHWErr:            ;Host System/Processor Error
HostRun:              ;Host Running
HostStop:             ;Host Stopped
HostReset:            ;Host Reset
HostSuspend:          ;Host Suspended
HostResume:           ;Host Resumed
HostDebug:            ;Host in Debug Mode
HostSST:              ;Host Single-Stepped
TimingChange:         ;Host Timing Change
DeviceDisconnectedUS: ;Device Disconnect Upstream
DeviceEnabledUS:      ;Device Enable Upstream
DeviceDisabledUS:     ;Device Disable Upstream
DeviceResetUS:        ;Device Reset Upstream
DeviceSuspendUS:      ;Device Suspend Upstream
DeviceResumeUS:       ;Device Resume Upstream
DevicePowerOnUS:      ;Device Power On Upstream
DevicePowerOffUS:     ;Device Power Off Upstream
DevicePowerResetUS:   ;Device Power Reset Upstream
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE TO HANDLE PENDING KEYSTROKES
;  NEEDED FOR DEVICES BEING DISCONNECTED, RESET, DON'T-LOOKED, etc.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;REMOVE ALL "HANGING" KEYSTROKES FOR A KEYBOARD (JUST DISCONNECTED OR DISABLED)
;Inputs:  ES = TSR Data Area
;         [DI] = Device Info Buffer
;Outputs: DIFlagDisconnect is set
;         Marks all pending Keys as unpressed
;         Moves the pending keys keys to ExternalTable for processing
;Changes:
;NOTES: This routine sets DIFlagDisconnect at the beginning, but does not
;         UnSet it when it is done.  It is up to the calling routine
;         to do that.  This is because the calling routine will need to
;         Disable/Reset/whatever the Device, which may take several hundred
;         milliseconds to complete.  During that time, there may be keystrokes
;         continuing to come from the keyboard, which would continue to be
;         processed if DIFlagDisconnect is Unset by us.
;------------------------------------------------------------------------------
RlsPendingKeys:
  PUSH CX,DI,SI,DS            ;Save used registers
  PUSHF                       ;Save flags
  CLI                         ;Disable interrupts
  MOV  DS,ES                  ;Point DS at TSR data area
  CALL ReleasePressedSysESDI  ;Release pressed System Keys
  OR   [DI].DIFlags,DIFlagDisconnect ;Mark as being Disconnected
  LEA  SI,[DI].DIKeyCodes     ;Point SI at the pending Keys
  CALL PurgeUSBPressed        ;Mark the keys as unpressed
  MOV  CX,NumUSBKeys          ;Number of Table entries to copy
P10:                          ;Loop to here for each Table entry
  PUSH CX                     ;save Counter
  CMP  B [SI].UKKeyCode,0     ;Valid entry?
  JE  >P50                    ;If not, skip it
  MOV  DI,ExternalTable       ;Point DI at the External Table
  MOV  CX,NumUSBKeys          ;Number of Table entries to check
P20:                          ;Loop to here for each External entry
  CMP  [DI].UKKeyCode,0       ;Empty entry?
  JNZ >P30                    ;If not, go to the next one
  PUSH CX,DI,SI               ;Save used registers
  MOV  CX,(USBKeyStrucSize/2) ;Number of words to copy
P25:                          ;Loop to here for each Entry
  MOVSW                       ;Copy the word
  MOV  W [SI-2],0             ;Purge the word
  LOOP P25                    ;Keep going until we're done
  POP  SI,DI,CX               ;Restore used registers
  JMP >P50                    ;Done copying
P30:                          ;External entry not empty
  ADD  DI,USBKeyStrucSize     ;Point at the next entry
  LOOP P20                    ;Keep looking
P50:                          ;Done with this entry
  POP  CX                     ;Restore Counter
  ADD  SI,USBKeyStrucSize     ;Point at the next entry
  LOOP P10                    ;Keep going until we're done
P90:                          ;Done
  POPF                        ;Restore flags
  POP  DS,SI,DI,CX            ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE TO RELEASE/RESET A DEVICE
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;COMPLETELY RELEASE A DEVICE THAT WE CURRENTLY OWN (POSSIBLY INCLUDING A RESET)
;Inputs:  DS = ES = TSR Data Area
;         [DI] = Device Info Entry to Release
;         [SI] = Int 14 Request to use
;Outputs: Releases Device Entry
;           Closes Periodic Handle
;           Unregisters as Interface Owner
;           Resets Device (if appropriate)
;           Resets Device Info Entry
;Changes:
;------------------------------------------------------------------------------
RlsDvcNoResetDI:
  PUSH BX                                        ;Save used registers
  XOR  BL,BL                                     ;Mark as No Reset
  JMP >R00                                       ;Do it
RlsDvcDoResetDI:
  PUSH BX                                        ;Save used registers
  MOV  BL,-1                                     ;Mark as a Reset
;  JMP >R00                                       ;Do it
R00:
  PUSH AX                                        ;Save used registers
  MOV  W [SI].I14RCallBackAddr[0],-1             ;Set CallBackAddr to nothing
  MOV  AX,W [DI].DIHostIndex                     ;Copy Host Index and
  MOV  W [SI].I14RHostIndex,AX                   ;  Device Address
  MOV  AX,[DI].DIIntHandle                       ;Copy
  MOV  [SI].I14RRequestHandle,AX                 ;  Interrupt Handle Number
  MOV  [SI].I14RRequestType,I14RRTCloseHandle    ;Request = Close Handle
  CALL DoInt14CallSaveAllSI                      ;Do it
  MOV  AX,[DI].DIRegHandle                       ;Copy
  MOV  [SI].I14RRequestHandle,AX                 ;  Registry Handle
  MOV  [SI].I14RRequestType,I14RRTUnRegIntfOwner ;Request = UnRegister
  CALL DoInt14CallSaveAllSI                      ;Do it
  OR   BL,BL                                     ;Need to Reset the Device?
  JZ  >R80                                       ;If not, we're done
  MOV  [SI].I14RRequestType,I14RRTResetDevice    ;Request = Reset
  CALL DoInt14CallSaveAllSI                      ;Do it
R80:                                             ;Done with Host
  CALL ResetDvcEntryDI                           ;Delete the Device Info Entry
  POP  AX                                        ;Restore used registers
  POP  BX                                        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESET A DEVICE INFO TABLE ENTRY
;Inputs:  DS = ES = TSR Data Area
;        [BX] or [DI] = Info Table Entry to reset
;         CLD already issued
;Outputs:
;Changes: Resets (clears out) Info Table Entry
;NOTES:   This preserves the Disabled/Enabled and Exchange status of
;           the Device, so that the user does not need to worry about
;           re-setting it after a temporary Disconnect or Host Reset.
;         Unlike most routines, this one preserves Flags across the Call!
;------------------------------------------------------------------------------
ResetDvcEntryBX:
  PUSH DI              ;Save used registers
  MOV  DI,BX           ;Point DI at the Table Entry
  CALL ResetDvcEntryDI ;Reset the Entry
  POP  DI              ;Restore used registers
  RET

ResetDvcEntryDI:
  PUSH AX,CX,DI                       ;Save used registers
  PUSHF                               ;Save flags
  CLI                                 ;Disable interrupts
  AND  B [DI],DIFlagDisabled          ;Reset non-preserved flags
  INC  DI                             ;Point at next Table Byte
  XOR  AX,AX                          ;Need to store zeroes
  STOSB                               ;Reset it
  MOV  CX,((DeviceInfoStrucSize-2)/2) ;Number of words to store
  REP  STOSW                          ;Reset the reset of the table
  POPF                                ;Restore flags
  POP  DI,CX,AX                       ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO FIND/STORE ENTRIES IN VARIOUS STRUCTURE-BASED TABLES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;CONVERT A DEVICE INFO INDEX TO AN OFFSET
;Inputs:  ES = Data Segment where data is located
;         CL = Device Index, or BL = Device Index (if DIIndex2OffsetBL)
;Outputs: DI = Offset to Table Entry (Assuming ES is the segment)
;Changes:
;------------------------------------------------------------------------------
DIIndex2OffsetBL:
  PUSH CX             ;Save used registers
  MOV  CL,BL          ;Put Index in CL
  CALL DIIndex2Offset ;Do it
  POP  CX             ;Restore used registers
  RET

DIIndex2Offset:
  PUSH AX,CX,DX               ;Save used registers
  XOR  CH,CH                  ;Index is actually a byte
  MOV  DI,DeviceInfoTable     ;Offset to beginning of Table
  MOV  AX,DeviceInfoStrucSize ;Size of each entry
  MUL  CX                     ;Multiply Index by the size of each entry
  ADD  DI,AX                  ;Add the offset of the beginning of the table
  POP  DX,CX,AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND AN EMPTY INFO TABLE ENTRY
;Inputs:  DS = ES = TSR Data Area
;Outputs: ZF = Clear if OK (found an empty Table entry)
;              [BX] = Table Entry
;            = Set if error (Table is full)
;               BX  = 0
;Changes:
;------------------------------------------------------------------------------
FindEmptyInfoBX:
  PUSH CX                       ;Save used registers
  MOV  BX,DeviceInfoTable       ;Point at first Table Entry
  MOV  CX,MaxDevices            ;Number of Table Entries
E10:                            ;Loop to here to find empty Table Entry
  TEST [BX].DIFlags,DIFlagInUse ;Empty Table entry?
  JZ  >E90                      ;If so, continue
  ADD  BX,DeviceInfoStrucSize   ;Point at next table entry
  LOOP E10                      ;Keep looking
  XOR  BX,BX                    ;Table is full!
E90:                            ;Done
  OR   BX,BX                    ;Set Return Flag
  POP  CX                       ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE FOR BAD DEVICE TABLE
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;ADD A BAD (INCOMPATIBLE) DEVICE HOST & ADDRESS TO THE TABLE
;Inputs:  DS:[SI] = Int 14 Structure containing Bad Device Data (Host/Addr/Intf)
;Outputs: Adds Host & Address to Bad Device Table
;Changes:
;------------------------------------------------------------------------------
AddBadDevice:
  PUSH AX,BX,CX                 ;Save used registers
  PUSHF                         ;Save Flags
  CLI                           ;Disable Interrupts
  MOV  BX,BadDeviceTable        ;Point at Table
  MOV  CX,MaxBadDevices         ;Number of Entries in Table
A20:                            ;Loop here to find empty table entry
  TEST [BX].BDFlags,BDFlagInUse ;This entry already used?
  JNZ >A50                      ;If so, skip it
  OR   [BX].BDFlags,BDFlagInUse ;If not, mark it as used
  MOV  AX,W [SI].I14RHostIndex  ;Store the Host Index
  MOV  W [BX].BDHostIndex,AX    ;  & Device Address
  MOV  AL,[SI].I14RInterfaceNum ;Store the
  MOV  [BX].BDInterfaceNum,AL   ;  Interface Number
  MOV  AX,NewDeviceError        ;Store the
  MOV  [BX].BDNewDeviceError,AX ;  Error Code
  MOV  AL,NewDeviceStage        ;Store the
  MOV  [BX].BDNewDeviceStage,AL ;  New Device Stage
  JMP >A90                      ;Done
A50:                            ;Entry not Empty
  ADD  BX,BadDeviceStrucSize    ;Point at next entry
  LOOP A20                      ;Keep going until we're done
A90:                            ;Done
  POPF                          ;Restore Flags
  POP  CX,BX,AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;DELETE BAD (INCOMPATIBLE) DEVICE HOSTS & ADDRESSES FROM THE TABLE
;Inputs:  CL = Host Index, CH = Address
;Outputs: Deletes Host & Address from Bad Device Table
;Changes:
;NOTES: This is called as the result a a Device Disconnect, so we need to
;         delete all Interfaces of the Device.  There will probably only
;         be one Entry per Address, but we need to check all of them.
;------------------------------------------------------------------------------
DeleteBadDevices:
  PUSH AX,BX,CX,DX,DI            ;Save used registers
  PUSHF                          ;Save Flags
  MOV  AX,CX                     ;AL = Host Index, AH = Device Address
  MOV  DL,-1                     ;Don't care about the Interface Number
  CLI                            ;Disable Interrupts
D10:                             ;Loop here for each Table Entry
  CALL FindBadDeviceEntry        ;Any entries in the Table (returns BX)?
  JC  >D90                       ;If not, we're done
  PUSH AX                        ;If so, save used registers
  XOR  AX,AX                     ;Write zeroes
  MOV  CX,(BadDeviceStrucSize/2) ;Number of words to write
  MOV  DI,BX                     ;Point DI at Table Entry
  REP  STOSW                     ;Write them
  POP  AX                        ;Restore used registers
  JMP  D10                       ;Keep looking for more Entries
D90:                             ;Done
  POPF                           ;Restore Flags
  POP  DI,DX,CX,BX,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COMPARE A HOST AND ADDRESS TO SEE IF IT'S IN OUR BAD DEVICE TABLE
;Inputs:  CL = Host, CH = Address, DL = Interface, DH = Alt Interface
;Outputs: CF = Set if it's not in the Bad Device Table
;            = Clear if it is in Table
;Changes:
;NOTES: This ignores the Alt Interface Setting (we don't care about it).
;------------------------------------------------------------------------------
TestBadDevice:
  PUSH AX,BX              ;Save used registers
  MOV  AX,CX              ;AL = Host Index, AH = Device Address
                          ;DL = Interface Number
  CALL FindBadDeviceEntry ;Is it in the Table (returns BX)?
  POP  BX,AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND A MATCHING HOST/ADDRESS/INTERFACE ENTRY IN THE BAD DEVICE TABLE
;Inputs:  AL = Host Index to find
;         AH = Device Address to find
;         DL = Interface Number to find
;              if -1, we don't care about the Interface Number
;Outputs: CF = Clear if Entry Found
;              BX = Entry Offset
;            = Set if Entry not found
;              BX = Undefined
;Changes:
;------------------------------------------------------------------------------
FindBadDeviceEntry:
  PUSH CX                       ;Save used registers
  PUSHF                         ;Save flags
  MOV  BX,BadDeviceTable        ;Point at Table
  MOV  CX,MaxBadDevices         ;Number of Entries in Table
  CLI                           ;Disable Interrupts
E20:                            ;Loop here to find empty table entry
  TEST [BX].BDFlags,BDFlagInUse ;Valid Entry?
  JZ  >E50                      ;If not, skip it
  CMP  W [BX].BDHostIndex,AX    ;Do the Host Index & Device Address match?
  JNE >E50                      ;If not, skip it
  CMP  DL,-1                    ;Do we care about the Interface Number?
  JE  >E80                      ;If not, we've found it!
  CMP  [BX].BDInterfaceNum,DL   ;Does the Interface Number match?
  JE  >E80                      ;If so, we've found it!
E50:                            ;Go to next entry
  ADD  BX,BadDeviceStrucSize    ;Point at the next entry
  LOOP E20                      ;Keep looking
E70:                            ;Error
  POPF                          ;Restore Flags
  STC                           ;Set Not Found Flag
  JMP >E90                      ;Done
E80:                            ;OK
  POPF                          ;Restore Flags
  CLC                           ;Set Found Flag
E90:                            ;Done
  POP  CX                       ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO ISSUE INT 14h CALLS TO THE HOST DRIVER
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;ISSUE AN INT 14 CALL TO THE USB HOST
;Inputs:  DS:[DX] = Int 14 Request (filled with appropriate data)
;      OR DS:[DI]
;      OR DS:[SI]
;Outputs: CF = Set if error (host stalled, etc.)
;            = Clear if OK
;Changes: Sends the appropriate info to the USB Host via Int 14 call
;------------------------------------------------------------------------------
DoInt14CallSaveAllSI:       ;Save all changed registers
                            ;  [SI] = Int14 Structure
  PUSH DX                   ;Save used registers
  MOV  DX,SI                ;Point DX at the Data Offset
  CALL DoInt14CallSaveAllDX ;Do it
  POP  DX                   ;Restore used registers
  RET

DoInt14CallAXSI:     ;Save all changed registers except AX
                     ;  [SI] = Int14 Structure
  PUSH DX            ;Save used registers
  MOV  DX,SI         ;Point DX at the Data Offset
  CALL DoInt14CallAX ;Do it
  POP  DX            ;Restore used registers
  RET

DoInt14CallCXSI:     ;Save all changed registers except CX
                     ;  [SI] = Int14 Structure
  PUSH DX            ;Save used registers
  MOV  DX,SI         ;Point DX at the Data Offset
  CALL DoInt14CallCX ;Do it
  POP  DX            ;Restore used registers
  RET

DoInt14CallCXDI:     ;Save all changed registers except CX
                     ;  [DI] = Int14 Structure
  PUSH DX            ;Save used registers
  MOV  DX,DI         ;Point DX at the Data Offset
  CALL DoInt14CallCX ;Do it
  POP  DX            ;Restore used registers
  RET

DoInt14CallAXCXSI:     ;Save all changed registers except AX & CX
                       ;  [SI] = Int14 Structure
  PUSH DX            ;Save used registers
  MOV  DX,SI           ;Point DX at the Data Offset
  CALL DoInt14CallAXCX ;Do it
  POP  DX            ;Restore used registers
  RET

DoInt14CallBXCXSI:     ;Save all changed registers except BX & CX
                       ;  [SI] = Int14 Structure
  PUSH DX            ;Save used registers
  MOV  DX,SI           ;Point DX at the Data Offset
  CALL DoInt14CallBXCX ;Do it
  POP  DX            ;Restore used registers
  RET

DoInt14CallCXDXSI:     ;Save all changed registers except CX & DX
                       ;  [SI] = Int14 Structure
  MOV  DX,SI           ;Point DX at the Data Offset
  CALL DoInt14CallCXDX ;Do it
  RET

DoInt14CallSaveAllDX: ;Save all changed registers
                      ;  [DX] = Int14 Structure
  PUSH AX,BX,CX,DX    ;Save registers that Int14 changes!
  CALL DoInt14Call    ;Do it
  POP  DX,CX,BX,AX    ;Restore used registers
  RET

DoInt14CallAX:
  PUSH BX,CX,DX    ;Save registers that Int14 changes, except AX
  CALL DoInt14Call ;Do it
  POP  DX,CX,BX    ;Restore used registers
  RET

DoInt14CallCX:
  PUSH AX,BX,DX    ;Save registers that Int14 changes, except CX
  CALL DoInt14Call ;Do it
  POP  DX,BX,AX    ;Restore used registers
  RET

DoInt14CallAXCX:
  PUSH BX,DX       ;Save registers that Int14 changes, except AX & CX
  CALL DoInt14Call ;Do it
  POP  DX,BX       ;Restore used registers
  RET

DoInt14CallBXCX:
  PUSH AX,DX       ;Save registers that Int14 changes, except BX & CX
  CALL DoInt14Call ;Do it
  POP  DX,AX       ;Restore used registers
  RET

DoInt14CallCXDX:
  PUSH AX,BX       ;Save registers that Int14 changes, except CX & DX
  CALL DoInt14Call ;Do it
  POP  BX,AX       ;Restore used registers
  RET

;Int 14 returns various values in AX, BX, CX, & DX
DoInt14Call:
  STI           ;Enable Interrupts
  MOV  AX,5001h ;Set Function
  MOV  BX,'US'  ;Set
  MOV  CX,'B!'  ;  Registers
  STC           ;Preset Error Flag
  INT  14h      ;Do it
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO HANDLE INT 08h (Timer Tick)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HAVE INTERRUPT 08 (TIMER) RUN THIS EVERY TIME IT OCCURS
;Inputs:
;Outputs: Searches for Newly attached Device
;Changes:
;NOTES: In theory, we shouldn't even need to do this since we are registering
;         and will be notified automatically if a new Device is attached.
;       We will do this just in case we miss it or are busy for some reason.
;------------------------------------------------------------------------------
Int08Hdr:
  DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code

Int08:
  PUSHF                          ;Process the
  CALL D CS:Int08Hdr.OldVector   ;  Old Interrupt Handler
  STI                            ;Enable interrupts
  CLD                            ;Go forward with string functions
  CALL MakeStack                 ;Set up our own Stack Space
  PUSH BX,DI,SI,DS,ES            ;Save used registers
  MOV  DS,CS                     ;Point DS and
  MOV  ES,CS                     ;  ES at our data area
  CALL SetupUserInt              ;Make sure we have a User Interrupt
  CALL EnableInt70               ;Enable INT 70h (CMOS Timer)
  MOV  BX,OFFSET TSRFlags2       ;Point [BX] at TSRFlags2
  TEST B [BX],Int08InUse         ;Still processing the previous IRQ?
  JNZ >E95                       ;If so, quit
  OR   B [BX],Int08InUse         ;If not, mark as processing
E10:                             ;OK to process
  MOV  DI,OFFSET Int08Counter    ;Point DI at Int08Counter
  MOV  SI,OFFSET DontLookCounter ;Point BX at DontLookCounter
  CMP  W [SI],0                  ;Need to Decrement DontLookCounter?
  JE  >E20                       ;If not, continue
  DEC  W [SI]                    ;If so, Decrement it
  JNZ >E90                       ;If not 0 yet, quit
  CMP  B [DI],0                  ;Disabled?
  JE  >E90                       ;If so, quit
  MOV  B [DI],1                  ;If not, look for Device right away
E20:                             ;Done with DontLookCounter
  CMP  B [DI],0                  ;Are we supposed to look yet?
  JE  >E90                       ;If not, just quit
  DEC  B [DI]                    ;Decrement the Delay Counter
  JNZ >E90                       ;If not 0 yet, quit
  MOV  B [DI],182                ;If 0, reset for next time (approx 10 seconds)
  PUSH AX,BX,CX,DX,BP            ;Save used registers
  CALL LookForNewDevice          ;Look for a new Device
  POP  BP,DX,CX,BX,AX            ;Restore used registers
E90:                             ;Done, mark as not processing any more
  AND  B [BX],(NOT Int08InUse)   ;Mark as done processing
E95:                             ;Done
  POP  ES,DS,SI,DI,BX            ;Restore used registers
  CALL ReturnStack               ;Restore Original Stack Space
  IRET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO HANDLE INT 70h (CMOS Delay Timer)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HAVE INTERRUPT 70h (RTC Interrupt) RUN THIS PROGRAM WHEN IT OCCURS
;Inputs:
;Outputs:
;Changes: Types all the keys in our Buffer
;------------------------------------------------------------------------------
Int70Hdr:
  DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code

Int70:
  CALL MakeStack                   ;Create our own stack space
  PUSH AX,BX,DS,ES                 ;Save used registers
  MOV  DS,CS                       ;Point DS
  MOV  ES,CS                       ;  and ES at our data area
  STI                              ;Enable interrupts
  CMP  W Int70Hdr.OldVector[2],0   ;Is the Old Vector Valid?
  JE  >S20                         ;If not, handle it
  CMP  W Int70Hdr.OldVector[2],70h ;Is the Old Vector DOS (FreeDOS bug)?
  JE  >S20                         ;If not, handle it
  PUSHF                            ;Call the Old Interrupt Vector
  CALL D Int70Hdr.OldVector        ;  (this will issue the End-of-Interrupt)
  JMP >S40                         ;Continue
S20:                               ;Old Vector is invalid
  CALL IssueEOI2                   ;Issue End-of-Interrupt
S40:                               ;Done handling End-of-Interrupt
  MOV  BX,OFFSET TSRFlags2         ;Point [BX] at TSRFlags2
  TEST B [BX],Int70InUse           ;Still processing the last IRQ?
  JNZ >S90                         ;If so, quit
  OR   B [BX],Int70InUse           ;If not, mark as processing
  CALL TypeNextKey                 ;Type the next Key
  CALL EnableIRQ8                  ;Make sure IRQ 8 remains enabled in PIC
  CALL EnableInt70                 ;Make sure Int 70h remains enabled in CMOS
  AND  B [BX],(NOT Int70InUse)     ;Mark as done processing
S90:                               ;Done
  POP  ES,DS,BX,AX                 ;Restore used registers
  CALL ReturnStack                 ;Restore original Stack Space
  IRET

;------------------------------------------------------------------------------
;ISSUE AN END-OF-INTERRUPT SIGNAL TO THE PICs FOR AN IRQ ON THE SECOND PIC
;Inputs:
;Outputs:
;Changes: Issues End-of-Interrupt Signal for an IRQ on the second PIC
;------------------------------------------------------------------------------
IssueEOI2:
  PUSH AX                                   ;Save used registers
  PUSHF                                     ;Save flags
  CLI                                       ;Disable interrupts
  MOV  AL,OCW2SelectOCW2+OCW2NonSpecificEOI ;Non-specific EOI
  OUT  PIC2Addr,AL                          ;Send to PIC 2
  MOV  AL,OCW3SelectOCW3+OCW3ReadISR        ;Get the
  OUT  PIC2Addr,AL                          ;  Interrupt In-Service Register
  MOV  AX,AX                                ;  from
  IN   AL,PIC2Addr                          ;  PIC 2
  OR   AL,AL                                ;Other Ints still being serviced?
  JNZ >P90                                  ;If so, don't reset PIC 1 yet
  MOV  AL,OCW2SelectOCW2+OCW2NonSpecificEOI ;If not, Non-specific EOI
  OUT  PIC1Addr,AL                          ;Send to PIC 1
P90:                                        ;Done
  POPF                                      ;Restore flags
  POP  AX                                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ENABLE IRQ 8 (INT 70h)
;Inputs:
;Outputs:
;Changes: Makes sure IRQ 8 (INT 70h) is Enabled
;NOTES: We need to call this after every call to INT 70h, since many BIOSes
;       will Disable it (the Periodic Interrupt) when they are called.
;------------------------------------------------------------------------------
EnableIRQ8:
  PUSH AX              ;Save used registers
  PUSHF                ;Save flags
  CLI                  ;Disable Interrupts
  IN   AL,(PIC2Addr+1) ;Get the PIC2 IRQ Mask
  AND  AL,(NOT 01h)    ;Enable IRQ8
  OUT  (PIC2Addr+1),AL ;  (Int 70h)
  POPF                 ;Restore Flags
  POP  AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ENABLE INT 70h PERIODIC INTERRUPT, IF APPOPRIATE
;Inputs:  ES:CPUClass
;Outputs:
;Changes: Int 70 Frequency Divider & Periodic Interrupt Flag
;------------------------------------------------------------------------------
EnableInt70:
  PUSH AX             ;Save used registers
  MOV  AH,CMOSPortA   ;Get the current
  CALL GetCMOS        ;  frequency divider
  CMP  AL,Period1024  ;Is it 1024Hz?
  JE  >E30            ;If so, test the periodic interrupt flag
  MOV  AL,Period1024  ;If not, set it
  CALL SetCMOS        ;  to 1024Hz
E30:                  ;Enable periodic interrupt flag
  MOV  AH,CMOSPortB   ;Get the current
  CALL GetCMOS        ;  Periodic Interrupt status
  TEST AL,PeriodicInt ;Periodic Interrupts already enabled?
  JNZ >E80            ;If so, we're done
  OR   AL,PeriodicInt ;If not,
  CALL SetCMOS        ;  Enable Periodic Interrupt
E80:                  ;Done changing CMOS
  CALL FinishCMOS     ;Clean up the CMOS data so Int's are reissued
E90:                  ;We're done
  POP  AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CLEAN UP THE CMOS AFTER AN INT 70 IS ISSUED SO IT CAN GET ISSUED AGAIN
;Inputs:
;Outputs:
;Changes: "Resets" CMOS IRQ 08 Stuff
;NOTES: I ran across some documentation (thanks to a SLOWDOWN user) that says
;         after an IRQ 08/Int 70h occurs, CMOS Port C must be read or Periodic
;         Interrupts won't be re-issued (this supposedly tells the CMOS that
;         the Interrupt processing is complete).  The documentation also
;         stated that after done messing with the CMOS, you should leave the
;         CMOS pointed at CMOS Port D.  There was never a specific, practical
;         reason stated for doing this, but I guess is just good practice.
;         This little subroutine simply reads CMOS ports C & D, but doesn't
;         do anything with the data.
;       The documentation also stated that one should disable NMI while
;         messing with the CMOS.  The reason stated for this was that if the
;         NMI caused a reboot, and you were in the middle of changing
;         something in the CMOS, the computer could reboot to an unknown
;         state.  This is because the CMOS retains its state even through a
;         reboot.  While booting, most computers do not reset the CMOS to
;         a known state, because the CMOS contains things like the Date & Time
;         and BIOS configuration items.
;       Well, what we're changing here, even though it is in the CMOS, is
;         reset at reboot.  All we do to the CMOS is set the Periodic Interrupt
;         rate to 1024Hz (which is what it's supposed to be after a reboot)
;         and Enable (allow) the Periodic Interrupts to occur (which is
;         also supposed to be reset after a reboot, even if nothing else is).
;       Because Disabling NMI is a little bit cumbersome to do, and because
;         it really doesn't do anything useful anyway, we won't worry about
;         it!!
;------------------------------------------------------------------------------
FinishCMOS:
  PUSH AX           ;Save used registers
  MOV  AH,CMOSPortC ;Read Port C
  CALL GetCMOS      ;  (this supposedly allows Periodic Int's to keep happening)
  MOV  AH,CMOSPortD ;Read Port D
  CALL GetCMOS      ;  (this supposedly sets things to a "normalized" state)
  POP  AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET A BYTE FROM THE CMOS
;Inputs:  AH = CMOS port number to get
;Outputs: AL = Byte from CMOS
;Changes:
;------------------------------------------------------------------------------
GetCMOS:
  PUSHF       ;Save flags
  CLI         ;Disable interrupts
  MOV  AL,AH  ;Put Port number in AL
  OUT  70h,AL ;Tell CMOS which port number we want
  IN   AL,71h ;Get the byte from the CMOS
  POPF        ;Restore flags
  RET

;------------------------------------------------------------------------------
;SET A BYTE IN THE CMOS
;Inputs:  AH = CMOS port number to change
;         AL = What to change the CMOS byte to
;Outputs:
;Changes: Byte in CMOS
;------------------------------------------------------------------------------
SetCMOS:
  PUSHF       ;Save flags
  CLI         ;Disable interrupts
  XCHG AL,AH  ;Tell CMOS which
  OUT  70h,AL ;  port number we want
  XCHG AL,AH  ;Get what we want to change it to
  OUT  71h,AL ;Change the CMOS byte
  POPF        ;Restore flags
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE NEEDED TO PROCESS "RAW" USB KEYBOARD DATA
;  This is performed every time there is a USB Keyboard Interrupt (every 10ms)
;  This takes the Raw USB Data, converts it to Scan Codes, and "types"
;    those Scan Codes when and if Appropriate, including taking into account
;    the Keyboard Delay Factors.
;  This will also toggle the Keyboard "Lock" lights when appropriate
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;THIS CODE IS PROCESSED EVERY TIME AN INTERRUPT COMES FROM THE DEVICE
;Inputs:  DS = ES = TSR Data Area
;         [BX] = Info Table Offset (contains DeviceData)
;Outputs: Processes "Raw" Mouse data into an appropriate format
;         If appropriate, calls the "User" Code telling it what has changed
;Changes: Lots of things
;NOTES: If the Report that comes back is for System Keys,
;         we cannot send periodically reliable data to USBKEYB, since the
;         polling rate we use is determined by what the user wants the
;         Mouse to do, not by what we want the keyboard to do.
;       In addition, moving the Mouse while pressing one of the Keys
;         causes delays and interruptions in reporting the Keys, which
;         can create all kinds of grief.
;       Therefore, all we will be able to do is notify USBKEYB of presses
;         and releases, with no timing information while it is pressed.
;         Any Typematic Timing will need to be handled by USBKEYB.
;------------------------------------------------------------------------------
DeviceChangeCode:


;call ToggleColor


  OR   CX,CX                  ;Did we get any data?
  JZ  >V90                    ;If not, quit
  MOV  AL,[BX].DIReportIDData ;Is it the Mouse
  CMP  AL,[BX].DIReportID     ;  Report ID?
  JNE >V20                    ;If not, try the next possibility
  CALL DeviceChangeUSB        ;If so, handle it
  JMP >V90                    ;Done
V20:                          ;Not Mouse ID
  CMP  AL,[BX].DISysReportID  ;Is it the System Keys Report ID?
  JNE >V90                    ;If not, quit
  CALL DeviceChangeSys        ;If so,handle it
V90:                          ;Done
  RETF                        ;Quit


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PROCESS SYSTEM KEYS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HANDLE THE DEVICE NOTIFICATION FOR THE SYSTEM KEYS REPORT ID
;Inputs:  DS = ES = TSR Data Area
;         [BX] = Info Table Offset (contains DeviceData)
;Outputs: Processes "Raw" System Keys Data, sending call to the
;           USB Keyboard processor (USBKEYB) if appropriate.
;Changes: Lots of things, including possibly all Registers
;NOTES: We cannot send periodically reliable data to USBKEYB, since the
;         polling rate we use is determined by what the user wants the
;         Mouse to do, not by what we want the keyboard to do.
;       In addition, moving the Mouse while pressing one of the System Keys
;         causes delays and interruptions in reporting the Keys, which
;         can create all kinds of grief.
;       Therefore, all we will be able to do is notify USBKEYB of presses
;         and releases, with no timing information while it is pressed.
;         If a key needs Typematic functions, the timing will need to be
;         handled by USBKEYB.  System Keys shouldn't need to be Typematic.
;------------------------------------------------------------------------------
DeviceChangeSys:
  CALL MakeStack         ;Set up our own Stack Space (CS = TSR Data Area!)
  CALL DoDeviceChangeSys ;Handle the Keys
  CALL ReturnStack       ;Restore Original Stack Space
  RET

DoDeviceChangeSys:
  PUSH DX                    ;Save used registers
  MOV  DL,[BX].DISysLastTime ;Get the Data byte last time
  XOR  DH,DH                 ;Assume Uninstalled/Disabled
  TEST TSRFlags,Uninstalled  ;Are we uninstalled?
  JNZ >K30                   ;If so, continue
  TEST [BX].DIFlags,(DIFlagDisabled+DIFlagDisconnect) ;Disabled or Disconnected?
  JNZ >K30                   ;If so, continue
  MOV  DH,[BX].DIRawData[0]  ;If not, get the Real Data Byte
K30:                         ;DH contains Data this time
  MOV  [BX].DISysLastTime,DH ;Save it for next time
  CMP  DL,DH                 ;Anything changed since last time?
  JE  >K90                   ;If not, just quit
  CALL ProcessSysKeyReleases ;Process Key Releases
  CALL ProcessSysKeyPresses  ;Process Key Presses
K90:                         ;Done
  POP  DX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;REMOVE ALL "HANGING" KEYSTROKES FOR A MOUSE (JUST DISCONNECTED OR DISABLED)
;Inputs:   ES  = TSR Data Area
;         [DI] = Device Info Buffer
;Outputs: DIFlagDisconnect is set
;         Issues Release codes to USBKEYB
;Changes:
;NOTES: This routine sets DIFlagDisconnect at the beginning, but does not
;         UnSet it when it is done.  It is up to the calling routine
;         to do that.  This is because the calling routine will need to
;         Disable/Reset/whatever the Device, which may take several hundred
;         milliseconds to complete.  During that time, there may be keystrokes
;         continuing to come from the mouse, which would continue to be
;         processed if DIFlagDisconnect is Unset by us.
;------------------------------------------------------------------------------
ReleasePressedSysESDI:
  PUSH BX,DS             ;Save used registers
  PUSHF                  ;Save flags
  CLI                    ;Disable interrupts
  MOV  DS,ES             ;Point DS at TSR Data Area
  MOV  BX,DI             ;Point BX at the Device Info Entry
  OR   [BX].DIFlags,DIFlagDisconnect ;Mark as being Disconnected
  CALL DoDeviceChangeSys ;Send Key Releases
  POPF                   ;Restore flags
  POP  DS,BX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS SYSTEM KEY PRESSES & RELEASES
;Inputs:  DH = System Key bit map (1 = Press) This Time
;         DL = System Key bit map (1 = Press) Last Time
;Outputs: Notifies USB Keyboard Driver (via INT 16h Functions) as needed
;Changes:
;------------------------------------------------------------------------------
ProcessSysKeyPresses:
  PUSH AX,DX                ;Save used registers
  XOR  AL,AL                ;Mark as a Press
  JMP >Y00                  ;Do it
ProcessSysKeyReleases:
  PUSH AX,DX                ;Save used registers
  MOV  AL,-1                ;Mark as a Release
  NOT  DX                   ;Work with Releases
;  JMP >Y00                  ;Do it
Y00:
  PUSH CX                   ;Save used registers
  OR   DH,DL                ;Figure out which buttons
  XOR  DH,DL                ;  have been changed since last time (DH)
  JZ  >Y90                  ;If no changes, quit
  MOV  DL,RptGDSysPowerDown ;Start with the first possible key
  MOV  CX,8                 ;Test 8 bits
Y10:                        ;Loop to here for each bit
  ROR  DH,1                 ;Is bit 0 set?
  JNC >Y50                  ;If not, don't send anything
  OR   AL,AL                ;Are we doing presses?
  JNZ >Y30                  ;If not, handle a Release
Y20:                        ;Need to send a Press
  CALL SendSysKeyPress      ;Send a Press
  JMP >Y50                  ;Continue
Y30:                        ;Need to send a Release
  CALL SendSysKeyRelease    ;Send a Release
Y50:                        ;Key handled
  INC  DL                   ;Increment Key Code
  LOOP Y10                  ;Keep going until we're done
Y90:                        ;Done
  POP  CX                   ;Restore used registers
  POP  DX,AX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEND A SYSTEM KEY PRESS OR RELEASE SIGNAL TO THE USB KEYBOARD DRIVER
;Inputs:  DL = Key Code to send
;Outputs: CF = Clear if Function worked
;            = Set if not
;Changes:
;------------------------------------------------------------------------------
SendSysKeyPress:
  PUSH AX          ;Save used registers
  MOV  AL,31h      ;AL = Function = Send USB System Key Press
  JMP >Y00         ;Do it
SendSysKeyRelease:
  PUSH AX          ;Save used registers
  MOV  AL,32h      ;AL = Function = Send USB System Key Release
;  JMP >Y00         ;Do it
Y00:
  PUSH DX          ;Save used registers
  XOR  DH,DH       ;Make sure DH = 0
  CALL DoInt16Func ;Do it (returns CF)
  POP  DX          ;Restore used registers
  POP  AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PERFORM ONE OF THE INT 16H "SEND USB SYSTEM KEY" FUNCTIONS
;Inputs:  DX = Value to send in DX
;         AL = Subfunction to use
;Outputs: CF = Clear if Function worked
;            = Set if not
;Changes:
;------------------------------------------------------------------------------
DoInt16Func:
  PUSH AX,BX,CX,DX ;Save used registers
  PUSH DI,SI,BP    ;Save used registers
  PUSH DS,ES       ;Save used registers
  MOV  AH,1Bh      ;Set AH to correct function
  MOV  BX,'KE'     ;BX = 'KE'
  MOV  CX,'YB'     ;CX = 'YB'
  STC              ;Preset error flag
  INT  16h         ;Do it
  JC  >X70         ;If error, not installed
  OR   AX,AX       ;Error?
  JNZ >X70         ;If so, Error
  CMP  BX,'YB'     ;BX what it should be?
  JNE >X70         ;If not, Error
  CMP  CX,'KE'     ;CX what it should be?
  JE  >X80         ;If so, it's OK
X70:               ;Not installed
  STC              ;Set not installed flag
  JMP >X90         ;Done
X80:               ;Installed
  CLC              ;Set installed flag
X90:               ;Done
  POP  ES,DS       ;Restore used registers
  POP  BP,SI,DI    ;Restore used registers
  POP  DX,CX,BX,AX ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PROCESS REGULAR USB KEYS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HANDLE THE DEVICE NOTIFICATION FOR THE USB KEYS REPORT ID
;Inputs:  DS = ES = TSR Data Area
;         [BX] = Info Table Offset (contains DeviceData)
;Outputs: Processes "Raw" Keyboard data into an appropriate format
;Changes: Lots of things, including possibly all Registers
;------------------------------------------------------------------------------
DeviceChangeUSB:
  CALL MakeStack               ;Set up our own Stack Space
  MOV  DI,BX                   ;Point DI at the Info Table Entry
  MOV  AL,[DI].DIRawData[2]    ;Get first Data Byte from Keyboard
  OR   AL,AL                   ;Valid Data?
  JZ  >U10                     ;If so, continue
  CMP  AL,RptKbdErrorUndefined ;Keyboard Error?
  JBE >U90                     ;If so, just quit without doing anything
U10:                           ;Keyboard is OK
  LEA  SI,[DI].DIKeyCodes      ;Point SI at the Keys Table
  CALL PurgeUSBPressed         ;Assume no keystrokes this time
  TEST TSRFlags,(DisableAll+Uninstalled) ;All keyboards Disabled?
  JNZ >U90                     ;If so, don't type keystrokes
  TEST [DI].DIFlags,(DIFlagDisabled+DIFlagDisconnect) ;Keyboard Disabled/Disc?
  JNZ >U90                     ;If so, don't type keystrokes
  CALL ProcessShiftCode        ;Process the Shift Byte
  CALL ProcessNormalCodes      ;Process the remaining bytes
  CALL ProcessKeyCodes         ;Convert Key Codes to Scan Codes
  CALL ProcessLEDs             ;Toggle LEDs as appropriate
  CMP  BufferCount,0           ;Anything to type?
  JE  >U90                     ;If not, we're done
U90:                           ;Done
  CALL CopyRawData             ;Copy Data for Status
  CALL PurgeRawData            ;Set Raw Data to all zeroes
  CALL ReturnStack             ;Restore original Stack Space
  RET

;------------------------------------------------------------------------------
;PURGE THE USB KEY CODE TABLE OF OLD "PRESSED THIS TIME" FLAGS
;Inputs:  DS = ES = TSR Data Area
;         [SI] = Keys Table
;Inputs:
;Outputs:
;Changes: Marks all table Entries as "not pressed this time"
;------------------------------------------------------------------------------
PurgeUSBPressed:
  PUSH CX,SI              ;Save used registers
  MOV  CX,NumUSBKeys      ;Number of entries in Table
P10:                      ;Loop to here for each entry
  AND  [SI].UKFlags,(NOT (UKFlagPressed+UKFlagNewPress)) ;Mark as not pressed
  ADD  SI,USBKeyStrucSize ;Point at next entry
  LOOP P10                ;Keep going until we're done
  POP  SI,CX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PURGE THE RAW KEY CODE DATA AREA (IN CASE KEYB IS UNPLUGGED OR SOMETHING)
;Inputs:  DS = ES = TSR Data Area
;         [DI] = Keyboard Info Table Entry
;         CLD already issued
;Outputs: KeybRawData set to all zeroes
;Changes:
;------------------------------------------------------------------------------
PurgeRawData:
  PUSH AX,CX,DI               ;Save used registers
  ADD  DI,(OFFSET DIRawData)  ;Point at Data Area
  MOV  CX,(MaxKeybDataSize/2) ;Number of words to write
  XOR  AX,AX                  ;Write zeroes
  REP  STOSW                  ;Do it
  POP  DI,CX,AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY THE RAW KEY CODE DATA TO THE STATUS AREA, IN CASE WE NEED TO SHOW RAW STS
;Inputs:  DS = ES = TSR Data Area
;         [DI] = Keyboard Info Table Entry
;         [SI] = Keys Table
;         CLD already issued
;Outputs: Copies RawData to StatusData
;Changes:
;------------------------------------------------------------------------------
CopyRawData:
  PUSH CX,DI,SI               ;Save used registers
  MOV  CL,[DI].DIReportID     ;Is this the correct
  CMP  CL,[DI].DIReportIDData ;  Report ID?
  JNE >W90                    ;If not, don't copy it
  LEA  SI,[DI].DIRawData      ;Point SI at the Raw Data Area
  ADD  DI,(OFFSET DIStsData)  ;Point DI at the Status Data Area
  MOV  CX,(MaxKeybDataSize/2) ;Number of words to copy
  REP  MOVSW                  ;Copy the Raw Data to the Status Data
W90:                          ;Done
  POP  SI,DI,CX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS THE USB SHIFT BYTE (DIRAWDATA[0]), ADDING DATA TO THE KEYCODE TABLE
;Inputs:  DS = ES = TSR Data Area
;         [DI] = Keyboard Info Table Entry
;Outputs: To USBKeyTable
;Changes:
;------------------------------------------------------------------------------
ProcessShiftCode:
  PUSH AX                   ;Save used registers
  MOV  AH,[DI].DIRawData[0] ;Get Shift Status
  MOV  AL,RptKbdLControl    ;Start with USB "Scan Code" for Bit 0 (LControl)
S10:                        ;Loop to here for each bit
  OR   AH,AH                ;Any bits left to test?
  JZ  >S90                  ;If not, we're done
  SHR  AH,1                 ;Is the bit set (indicating a press)?
  JNC >S40                  ;If not, skip it
  CALL AddUSBKey            ;If so, add/update the USB KeyCode Table
S40:                        ;This bit is handled
  INC  AL                   ;Update Key Code
  JMP  S10                  ;Keep looking
S90:                        ;Done
  POP  AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS THE "NORMAL" KEYSTROKES FROM THE KEYBOARD (KEYBDATA[1]-[n])
;Inputs:  DS = ES = TSR Data Area
;         [DI] = Keyboard Info Table Entry
;         CLD already issued
;Outputs: To USBKeyTable
;Changes:
;------------------------------------------------------------------------------
ProcessNormalCodes:
  PUSH AX,CX,SI               ;Save used registers
  LEA  SI,[DI].DIRawData[2]   ;Point at the Raw Data
  MOV  CX,(MaxKeybDataSize-2) ;Number of Data Bytes to check
N10:                          ;Loop to here for each entry
  LODSB                       ;Get next Key Code
  OR   AL,AL                  ;Valid?
  JZ  >N40                    ;If not, keep looking
  CALL AddUSBKey              ;If so, add/update the USB KeyCode Table
N40:                          ;Done with that Code
  LOOP N10                    ;Keep going until we're done
  POP  SI,CX,AX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ADD/UPDATE A USB KEY CODE TO THE KEY CODE TABLE
;Inputs:  DS = ES = TSR Data Area
;         [DI] = Keyboard Info Table Entry
;         AL = USB Key Code to Add To/Update In the USB KeyCode Table
;Outputs: To KeyCodeTable
;Changes:
;NOTES: If KeyCode is already in the Table, this just sets the
;         "pressed this time" flag
;       If KeyCode is not in Table Yet, this adds it and sets the
;         "newly pressed" flag
;------------------------------------------------------------------------------
AddUSBKey:
  PUSH DX,DI,SI           ;Save used registers
  LEA  SI,[DI].DIKeyCodes ;Point SI at the Keys Table
  MOV  DL,AL              ;Put USB Code in DL
  CALL DoUSBCodeRePress   ;Put it in the Table (uses SI, may change DI)
                          ;Should never return Error!
  POP  SI,DI,DX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS KEY CODES IN BUFFER AND SEND SCANCODES AS NEEDED
;Inputs:  DS = ES = TSR Data Area
;         [SI] = Keys Table
;Outputs: To Scan Code Buffer as required
;Changes: KeyCodeTable Countdown Timers are Modified/Updated
;------------------------------------------------------------------------------
ProcessKeyCodes:
  PUSH AX,CX,DX,SI        ;Save used registers
  MOV  CX,NumUSBKeys      ;Number of Entries in Table
P10:                      ;Loop to here for each table entry
  MOV  AL,[SI].UKKeyCode  ;Get the Key Code
  OR   AL,AL              ;Valid Entry?
  JZ  >P60                ;If not, go to next one
  MOV  DL,[SI].UKFlags    ;If valid, get the Flags
  TEST DL,(UKFlagNewPress+UKFlagPressed) ;Key pressed?
  JZ  >P40                ;If not, handle a Release
  XOR  AH,AH              ;This will be a Press
  TEST DL,UKFlagNewPress  ;Is it a new Press?
  JZ  >P20                ;If not, handle an old one
  AND  [SI].UKFlags,(NOT UKFlagNewPress) ;Mark it as not pressed
  CALL SendKeyCode        ;Send it
  TEST DL,UKFlagRelease   ;Need to Release it immediately?
  JNZ >P40                ;If so, jump to do it
  JMP >P60                ;If not, we're done with this one
P20:                      ;An Old Press
  MOV  DH,[SI].UKTimer    ;Get Timer
  DEC  DH                 ;Decrement the Timer
  JNZ >P30                ;If not 0 yet, keep waiting
  MOV  DH,RepeatFactor    ;If so, initialize next Delay Counter
  CALL SendKeyCode        ;If 0, send the Delay Key
P30:                      ;Done messing with Timers
  MOV  [SI].UKTimer,DH    ;Store Updated Timer
  JMP >P60                ;Done with this Keystroke
P40:                      ;Key is released
  MOV  AH,80h             ;Mark as a Release
  CALL SendKeyCode        ;Send it
  CALL PurgeUSBKeyRecord  ;Release the Table Entry
P60:                      ;Done with this entry
  ADD  SI,USBKeyStrucSize ;Point at next entry
  LOOP P10                ;Keep looking
  POP  SI,DX,CX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PURGE AN INDIVIDUAL USB KEY RECORD
;Inputs:  ES:[SI] = Record to Purge
;         CLD already issued
;Outputs: Sets record to all zeroes
;Changes:
;------------------------------------------------------------------------------
PurgeUSBKeyRecord:
  PUSH AX,CX,DI ;Save used registers
  MOV  DI,SI    ;  at the Record
  MOV  CX,(USBKeyStrucSize/2) ;Number of words to write
  XOR  AX,AX    ;Write zeroes
  REP  STOSW    ;Do it
  POP  DI,CX,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT USB/SYSTEM/SCAN CODE AND INSERT INTO SCAN CODE BUFFER
;Inputs:  DS = ES = TSR Data Area
;         AL = Code to Type (can be USB Code, System Code, or Scan Code)
;         AH = 0 if Key Press, 80h if Key Release
;         DL = UKFlags (indicates which type of Code it is)
;         Buffer = Scan Code Buffer to fill with Scan Codes
;Outputs: Converts USB/System/Scan Code to standard Scan Code(s),
;           and inserts them at the end of Buffer
;         If Error, Beeps the Speaker
;Changes: Buffer
;------------------------------------------------------------------------------
SendKeyCode:
  PUSH AX,BX                ;Save used registers
  CALL Translate2ScanCode   ;Translate the Code into a Scan Code
  JZ  >K70                  ;If invalid Code, Beep
  CALL TestSpecialScanCodes ;Test for and Handle any Special Scan Codes
  JC  >K90                  ;If it was special, we're done
K50:                        ;ScanCode is in AL
  TEST AL,80h               ;Do we need to prefix it with 224?
  JZ  >K60                  ;If not, continue
  AND  AL,(NOT 80h)         ;If so, get rid of the 224 Prefix Code
  MOV  BL,224               ;Send
  CALL PutBuffer            ;  a 224
K60:                        ;224 Prefix is handled
  MOV  BL,AL                ;Add the Scan Code
  OR   BL,AH                ;  to the
  CALL PutBuffer            ;  Buffer
  CALL EnableInt70          ;Enable INT 70h (CMOS Timer)
  JMP >K90                  ;We're done
K70:                        ;Invalid Key
  CALL SendBeepRequest      ;Beep the Speaker
K90:                        ;Done
  POP  BX,AX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TRANSLATE A USB CODE< SYSTEM CODE, OR SCANCODE INTO A SCANCODE CODE
;Inputs:  DS = ES = TSR Data Area
;         AL = Code to Translate (can be USB Code, System Code, or Scan Code)
;         DL = UKFlags (indicates which type of Code it is)
;Outputs: ZF = Clear if OK (Code found in the Tables)
;              AL = Translated ScanCode Code (if bit 7 set, Prefix with 224)
;            = Set if Error (COuld not find Code in Translation Tables)
;              AL = 0
;Changes:
;------------------------------------------------------------------------------
Translate2ScanCode:
  PUSH BX                  ;Save used registers
T10:                       ;Test for Scan Code
  TEST DL,UKFlagScanCode   ;Is it a Scan Code?
  JNZ >T90                 ;If so, we're done
T20:                       ;Test for System Code
  TEST DL,UKFlagSysCode    ;Is it a System Code?
  JZ  >T30                 ;If not, it's a USB Code
  MOV  BX,UserSysTable     ;Start with User-Defined translations
  CALL SearchByte2ByteTbl  ;Is this Key User-Defined (rtns ScanCode AL)?
  JNC >T90                 ;If so, we're done
  MOV  BX,ConversionTblSys ;Look in standard System table
  CALL SearchByte2ByteTbl  ;In the Table?
  JNC >T90                 ;If so, we're done
  JMP >T70                 ;If not, Error
T30:                       ;Is a USB Code
  MOV  BX,UserUSBTable     ;Start with User-Defined Key translations
  CALL SearchByte2ByteTbl  ;Is this Key User-Defined?
  JNC >T90                 ;If so, we're done
  MOV  BX,ConversionTbl1   ;Look in default USB Code Table
  CALL SearchByte2ByteTbl  ;In the Table?
  JNC >T90                 ;If wo, we're done
T70:                       ;Error (No Translation Code Found)
  XOR  AL,AL               ;Set AL to 0
T90:                       ;Done
  OR   AL,AL               ;Set return flag
  POP  BX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST FOR AND HANDLE ANY SCAN CODES THAT REQUIRE SPECIAL HANDLING
;Inputs:  DS = ES = TSR Data Area
;         AL = ScanCode to Test
;                225 = Pause
;                Bit 7 set if prefixed with 224
;         AH =  0  if Key Press
;            = 80h if Key Release
;         Buffer (Buffer of Codes we need to "type")
;Outputs: CF = Set if Key is special, and we handled it
;            = Clear if Key is not, and still needs to be handled
;Changes: May change Buffer
;------------------------------------------------------------------------------
TestSpecialScanCodes:
  PUSH AX,BX                     ;Save used registers
C10:                             ;Test for Grey Key
  MOV  BX,ScanCodeTblGrey        ;Is it a
  CALL SearchByteTblBX           ;  Grey Key?
  JC  >C20                       ;If not, try the next possibility
  AND  AL,(NOT 80h)              ;Get rid of 224 prefix code
  CALL HandleGreyKey             ;Handle it
  JMP >C80                       ;Done
C20:                             ;Test for PrintScreen/SystemRequest
  CMP  AL,ScanCodeGreyStar+80h   ;PrintScreen?
  JE  >C25                       ;If so, handle it
  CMP  AL,ScanCodeSysReq         ;SystemRequest?
  JNE >C30                       ;If not, try the next possibility
C25:                             ;Is PrintScreen/SystemRequest
  CALL HandlePrtScrSysReq        ;Handle it
  JMP >C80                       ;Done
C30:                             ;Test for Pause/Break
  CMP  AL,225                    ;Pause?
  JE  >C35                       ;If so, handle it
  CMP  AL,ScanCodeScrollLock+80h ;Break?
  JNE >C70                       ;If not, it's not Special
C35:                             ;Is Pause/Break
  CALL HandlePauseBreak          ;Handle it
  JMP >C80                       ;Done
C70:                             ;Not a Special Key
  CLC                            ;Set as not Special
  JMP >C90                       ;Done
C80:                             ;Key was Special
  STC                            ;Mark as Special/Handled
C90:                             ;Done
  POP  BX,AX                     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS A GREY KEYSTROKE
;Inputs:  DS = ES = TSR Data Area
;         AL = Scan Code for Grey Key
;         AH =  0 if Key Press, 80h if Key Release
;         Buffer
;         Shift Key Status contained in BIOS Data Area
;Outputs: Adds appropriate Scan Codes to Buffer
;Changes: Buffer
;------------------------------------------------------------------------------
HandleGreyKey:
  PUSH AX,BX                 ;Save used registers
  OR   AL,AH                 ;Mask in the Release bit, if necessary
  CALL TestNumLock           ;NumLock Enabled?
  JZ  >G40                   ;If not, handle it
  CALL TestEitherShift       ;Is either Shift Key pressed?
  JNC >G80                   ;If so, jump to send 224 & original key
  CALL SendFakeLeftShift     ;Send a Fake Left Shift
  MOV  BL,AL                 ;Send the
  CALL SendKeyWith224        ;  Keystroke
  CALL ReleaseFakeLeftShift  ;Release the Fake Left Shift
  JMP >G90                   ;Done
G40:                         ;NumLock not Enabled
  CALL TestEitherShift       ;Is either Shift Key pressed?
  JC  >G80                   ;If not, just send the keystroke normally
  CALL TestLeftShift         ;Is it Left Shift?
  JC  >G45                   ;If not, do Right Shift
  CALL ReleaseFakeLeftShift  ;Release a Fake Left Shift
  JMP >G50                   ;Send the Key
G45:                         ;Left Shift Handled
  CALL TestRightShift        ;Is it Right Shift?
  JC  >G50                   ;If not, send the Keystroke
  CALL ReleaseFakeRightShift ;Release a Fake Right Shift
G50:                         ;Have the Shifts Handled
  MOV  BL,AL                 ;Send the
  CALL SendKeyWith224        ;  Keystroke
  CALL TestLeftShift         ;Is it Left Shift?
  JC  >G55                   ;If not, do Right Shift
  CALL SendFakeLeftShift     ;Send a Fake Left Shift
G55:                         ;Left Shift Handled
  CALL TestRightShift        ;Is it Right Shift?
  JC  >G90                   ;If not, we're done
  CALL SendFakeRightShift    ;Send a Fake Right Shift
  JMP >G90                   ;Done
G80:                         ;Send the original keystroke
  MOV  BL,AL                 ;Send the
  CALL SendKeyWith224        ;  Keystroke
G90:                         ;Done
  POP  BX,AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS A PRINTSCREEN/SYSREQ KEYSTROKE
;Inputs:  DS = ES = TSR Data Area
;         KeySentFlags
;         AL = PrintScreen or SystemRequest Scan Code
;         AH =  0 if Key Press, 80h if Key Release
;         Buffer
;         SftPrtScrSent, PrtScrSent, SysReqSent
;Outputs: Adds appropriate Scan Codes to Buffer
;Changes: Buffer
;         SftPrtScrSent, PrtScrSent, and/or SysReqSent (KeySentFlags)
;------------------------------------------------------------------------------
HandlePrtScrSysReq:
  PUSH BX                        ;Save used registers
  MOV  BH,KeySentFlags           ;Put KeySentFlags in BH
  OR   AH,AH                     ;Key Press or Release?
  JNZ >P40                       ;If Release, jump to handle it
  TEST BH,KeySentSftPrtScr       ;Repeated Shift-PrtScr?
  JNZ >P15                       ;If so, handle it
  TEST BH,KeySentPrtScr          ;Repeated PrtScr?
  JNZ >P35                       ;If so, handle it
  TEST BH,KeySentSysReq          ;Repeated SysReq?
  JNZ >P25                       ;If so, handle it
P10:                             ;First-time key
  CALL TestAnyShifts             ;Any "Shift" Keys Pressed?
  JNC >P20                       ;If so, jump to handle it
  OR   BH,KeySentSftPrtScr       ;Mark as Sft-PrtScr
P15:                             ;Send Sft-PrtScr
  CALL SendFakeLeftShift         ;Send a Fake Left Shift
  JMP >P35                       ;Jump to send the PrtScr Keystroke
P20:                             ;At least one Shift Key is pressed!
  CALL TestEitherAlt             ;Is an Alt Key Pressed?
  JC  >P30                       ;If not, jump to send a PrtScr
  OR   BH,KeySentSysReq          ;Mark as SysReq
P25:                             ;Send SysReq
  MOV  BL,ScanCodeSysReq         ;Send the SysReq Keystroke
  JMP >P80                       ;Done
P30:                             ;Need to mark as PrtScr
  OR   BH,KeySentPrtScr          ;Mark as PrtScr
P35:                             ;Need to send a PrtScr
  MOV  BL,ScanCodeGreyStar       ;Send a
  CALL SendKeyWith224            ;  PrtScr
  JMP >P90                       ;Done
P40:                             ;Key Released
  TEST BH,KeySentSftPrtScr       ;Did we send a Sft-PrtScr?
  JZ  >P50                       ;If not, try the next possibility
  AND  BH,(NOT KeySentSftPrtScr) ;If so, mark it as released
  MOV  BL,(ScanCodeGreyStar+80h) ;Release the
  CALL SendKeyWith224            ;  PrtScr
  CALL ReleaseFakeLeftShift      ;Release the Fake Left Shift
  JMP >P90                       ;Done
P50:                             ;Did not send Sft-PrtScr
  TEST BH,KeySentPrtScr          ;Did we send a plain PrtScr?
  JZ  >P60                       ;If not, try the next possibility
  AND  BH,(NOT KeySentPrtScr)    ;If so, mark it as released
  MOV  BL,(ScanCodeGreyStar+80h) ;Release the
  CALL SendKeyWith224            ;  PrtScr
  JMP >P90                       ;Done
P60:                             ;Did not send PrtScr
  TEST BH,KeySentSysReq          ;Did we send a SysReq (we should have!)?
  JZ  >P90                       ;If not, we're done
  AND  BH,(NOT KeySentSysReq)    ;If so, mark it as released
  MOV  BL,(ScanCodeSysReq+80h)   ;Release the SysReq Keystroke
;  JMP >P80                       ;Done
P80:                             ;Send last keystroke
  CALL PutBuffer                 ;Put scan code in Buffer
P90:                             ;Done
  MOV  KeySentFlags,BH           ;Store the new Flags
  POP  BX                        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS A PAUSE/BREAK KEYSTROKE
;Inputs:  DS = ES = TSR Data Area
;         KeySentFlags
;         AL = Pause or Break Scan Code
;         AH =  0 if Key Press, 80h if Key Release
;         Buffer
;         PauseSent, BreakSent
;Outputs: Adds appropriate Scan Codes to Buffer
;Changes: Buffer
;         PauseSent and/or BreakSent (KeySentFlags)
;------------------------------------------------------------------------------
HandlePauseBreak:
  PUSH BX                             ;Save used registers
  MOV  BH,KeySentFlags                ;Put KeySentFlags in BH
  OR   AH,AH                          ;Key Press or Release?
  JNZ >B40                            ;If Release, jump to handle it
  TEST BH,(KeySentBreak+KeySentPause) ;Repeated Key?
  JNZ >B90                            ;If so, handle it
B10:                                  ;First-time Key
  CALL TestEitherControl              ;Is a Control Key Pressed?
  JC  >B30                            ;If not, jump to send a Pause
B20:                                  ;Send Break
  OR   BH,KeySentBreak                ;Mark as Break
  MOV  BL,ScanCodeScrollLock          ;Send the
  CALL SendKeyWith224                 ;  Break
  MOV  BL,(ScanCodeScrollLock+80h)    ;Release the
  CALL SendKeyWith224                 ;  Break
  JMP >B90                            ;Done
B30:                                  ;Need to send Pause
  OR   BH,KeySentPause                ;Mark as Pause
  MOV  BL,225                         ;Send
  CALL PutBuffer                      ;  the
  MOV  BL,ScanCodeControl             ;  Pause
  CALL PutBuffer                      ;  Keystroke
  MOV  BL,ScanCodeNumLock
  CALL PutBuffer
  MOV  BL,225                         ;Release
  CALL PutBuffer                      ;  the
  MOV  BL,(ScanCodeControl+80h)       ;  Pause
  CALL PutBuffer                      ;  Keystroke
  MOV  BL,(ScanCodeNumLock+80h)
  CALL PutBuffer
  JMP >B90                            ;Done
B40:                                  ;Key Released
  TEST BH,KeySentPause                ;Did we send a Pause?
  JZ  >B50                            ;If not, try the next possibility
  AND  BH,(NOT KeySentPause)          ;If so, mark it as released
  JMP >B90                            ;Done
B50:                                  ;Did not send Sft-PrtScr
  TEST BH,KeySentBreak                ;Did we send a Break (we should have!)?
  JZ  >B90                            ;If not, we're done
  AND  BH,(NOT KeySentBreak)          ;If so, mark it as released
B90:                                  ;Done
  MOV  KeySentFlags,BH                ;Store the new Flags
  POP  BX                             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF A "SHIFT" KEY IS PRESSED IN BIOS OR IN USB TABLE
;Inputs:  DS = ES = TSR Data Area
;         [DI] = Keyboard Info Table Entry
;Outputs: CF = Clear if the Key is pressed
;            = Set if Key is not pressed
;Changes:
;------------------------------------------------------------------------------
TestEitherAlt:
  CALL TestBIOSEitherAlt     ;Pressed in the BIOS?
  JNZ >A80                   ;If so, we're done
  CALL TestUSBEitherAlt      ;Pressed on a USB Keyboard?
  JMP >A90                   ;Done
TestEitherControl:
  CALL TestBIOSEitherControl ;Pressed in the BIOS?
  JNZ >A80                   ;If so, we're done
  CALL TestUSBEitherControl  ;Pressed on a USB Keyboard?
  JMP >A90                   ;Done
TestEitherShift:
  CALL TestBIOSEitherShift   ;Pressed in the BIOS?
  JNZ >A80                   ;If so, we're done
  CALL TestUSBEitherShift    ;Pressed on a USB Keyboard?
  JMP >A90                   ;Done
TestLeftShift:
  CALL TestBIOSLeftShift     ;Pressed in the BIOS?
  JNZ >A80                   ;If so, we're done
  CALL TestUSBLeftShift      ;Pressed on a USB Keyboard?
  JMP >A90                   ;Done
TestRightShift:
  CALL TestBIOSRightShift    ;Pressed in the BIOS?
  JNZ >A80                   ;If so, we're done
  CALL TestUSBRightShift      ;Pressed on a USB Keyboard?
  JMP >A90                   ;Done
TestAnyShifts:
  CALL TestBIOSAnyShifts     ;Pressed in the BIOS?
  JNZ >A80                   ;If so, we're done
  CALL TestUSBAnyShifts      ;Pressed on a USB Keyboard?
  JMP >A90                   ;Done
A70:                         ;Not pressed
  STC                        ;Set not pressed flag
  JMP >A90                   ;Done
A80:                         ;Pressed
  CLC                        ;Set pressed flag
A90:                         ;Done
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF ONE OF THE "SHIFT" KEYS (SHIFT, ALT, CTRL) IS PRESSED ON USB
;Inputs:  DS = ES = TSR Data Area
;Outputs: CF = Clear if the Key is pressed
;            = Set if Key is not pressed
;Changes:
;NOTES: The Raw Keyboard Data gets purged at the end of each IRQ, so we need
;         to check both the Raw Data and the Status Data.  The Status Data
;         will be correct for the last IRQ that occured, if it is for a
;         different keyboard than the one we are currently processing.
;------------------------------------------------------------------------------
TestUSBEitherAlt:
  PUSH BX                      ;Save used registers
  MOV  BX,ScanCodeAlt+((ScanCodeAlt+80h) SHL 8) ;Left Alt + Right Alt
  JMP >U00                     ;Do it
TestUSBEitherControl:
  PUSH BX                      ;Save used registers
  MOV  BX,ScanCodeControl+((ScanCodeControl+80h) SHL 8) ;Left Ctl + Right Ctl
  JMP >U00                     ;Do it
TestUSBEitherShift:
  PUSH BX                      ;Save used registers
  MOV  BX,ScanCodeLShift+(ScanCodeRShift SHL 8) ;Left Shift + Right Shift
  JMP >U00                     ;Do it
TestUSBLeftShift:
  PUSH BX                      ;Save used registers
  MOV  BX,ScanCodeLShift+(ScanCodeLShift SHL 8) ;Left Shift Twice
  JMP >U00                     ;Do it
TestUSBRightShift:
  PUSH BX                      ;Save used registers
  MOV  BX,ScanCodeRShift+(ScanCodeRShift SHL 8) ;Left Shift Twice
;  JMP >U00                     ;Do it
U00:
  PUSH CX,SI                   ;Save used registers
U10:                           ;Test External table
  MOV  SI,ExternalTable        ;Point at the External Data Table
  CALL TestUSBModifier         ;Is a Modifier Key pressed?
  JNC >U90                     ;If so, we're done
U20:                           ;Test USB Keyboards
  MOV  CX,MaxDevices           ;If not, number of Table entries to test
  MOV  SI,DeviceInfoTable+(OFFSET DIKeyCodes) ;Point at first Table Entry
U30:                           ;Loop to here for each table entry
  CALL TestUSBModifier         ;Is a Modifier Key pressed?
  JNC >U90                     ;If so, we're done
  ADD  SI,DeviceInfoStrucSize  ;If not, point at the next table entry
  LOOP U30                     ;Keep going until we're done
  STC                          ;Set not-pressed flag
U90:                           ;Done
  POP  SI,CX                   ;Restore used registers
  POP  BX                      ;Restore used registers
  RET

TestUSBAnyShifts:
  CALL TestEitherShift   ;Either Shift Key pressed?
  JNC >S90               ;If so, we're done
  CALL TestEitherControl ;Either Control Key pressed?
  JNC >S90               ;If so, we're done
  CALL TestEitherAlt     ;Either Alt Key pressed?
S90:                     ;Done
  RET

;------------------------------------------------------------------------------
;TEST THE USB DATA AREA TO SEE IF A PARTICULAR MODIFIER KEY IS PRESSED
;Inputs:  DS = ES = TSR Data Area
;         [SI] = Keyboard Buffer to test
;Outputs: CF = Clear if Modifier Key is pressed in this Keyboard Buffer
;            = Set if Not
;Changes:
;NOTES: This does NOT simply test for a Modifier Key in the first byte of
;         the USB Report Codes (which is where the Modifier Key Codes are
;         normally placed by the USB hardware).
;       Rather, this tests for what the ultimate translated output of
;         the USB Code will be, accounting for the possibility of User
;         Translations inside this program and in the BIOS (using
;         INT 15h, Function 4Fh).
;       This also accounts for Modifier Keys that come in through the
;         Extended INT 16h Functions we provide.  If another program
;         intercepts the Extended INT 16h functions before we can
;         process them, we won't know about those Modifier Key presses
;         unless they get processed through the BIOS.
;------------------------------------------------------------------------------
TestUSBModifier:
  PUSH AX,CX,DX,SI        ;Save used registers
  MOV  CX,NumUSBKeys      ;Number of Table entries
M10:                      ;Loop to here for each table entry
  MOV  AL,[SI].UKKeyCode  ;Get the Code
  OR   AL,AL              ;Valid entry?
  JZ  >M40                ;If not, skip it
  MOV  DL,[SI].UKFlags    ;Get the flags
  CALL Translate2ScanCode ;Translate it to a Scan Code
  JZ  >M40                ;If invalid, skip it
  XOR  DH,DH              ;Assume standard key (not extended)
  TEST AL,80h             ;Is it extended?
  JZ  >M20                ;If not, skip it
  OR   DH,80h             ;If so, mark it as extended
  AND  AL,(NOT 80h)       ;Make AL the real Scan Code
M20:                      ;AL = Scan Code, DH = Extended Flag
  MOV  AH,4Fh             ;Function 4Fh (Translate Scan Code)
  STC                     ;CF needs to be set
  INT  15h                ;Do it
  JNC >M40                ;If error, skip it
  OR   AL,DH              ;Restore the original ScanCode Code
  CMP  AL,BL              ;Is it what we're looking for?
  JE  >M80                ;If so, we're done
  CMP  AL,BH              ;Is it what we're looking for?
  JE  >M80                ;If so, we're done
M40:                      ;Done with this entry
  ADD  SI,USBKeyStrucSize ;Point at next table entry
  LOOP M10                ;Keep going until we're done
M70:                      ;Key Not Pressed
  STC                     ;Set Not-Pressed Flag
  JMP >M90                ;Done
M80:                      ;Key Pressed
  CLC                     ;Set Pressed Flag
M90:                      ;Done
  POP  SI,DX,CX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF ONE OF THE "SHIFT" KEYS (SHIFT, ALT, CTRL) IS PRESSED IN BIOS
;Inputs:
;Outputs: ZF = Clear if the Key is pressed according to the BIOS
;            = Set if Key is not pressed
;Changes:
;------------------------------------------------------------------------------
TestBIOSEitherAlt:
  PUSH AX                  ;Save used registers
  MOV  AL,BIOS17EitherAltP ;Store appropriate mask
  JMP >B00                 ;Do it
TestBIOSEitherControl:
  PUSH AX                  ;Save used registers
  MOV  AL,BIOS17EitherCtlP ;Store appropriate mask
  JMP >B00                 ;Do it
TestBIOSLeftShift:
  PUSH AX                  ;Save used registers
  MOV  AL,BIOS17LShiftP    ;Store appropriate mask
  JMP >B00                 ;Do it
TestBIOSRightShift:
  PUSH AX                  ;Save used registers
  MOV  AL,BIOS17RShiftP    ;Store appropriate mask
  JMP >B00                 ;Do it
TestBIOSEitherShift:
  PUSH AX                  ;Save used registers
  MOV  AL,BIOS17LShiftP+BIOS17RShiftP ;Store appropriate mask
  JMP >B00                 ;Do it
TestBIOSAnyShifts:
  PUSH AX                  ;Save used registers
  MOV  AL,BIOS17ShiftKeysMask
                           ;Store appropriate mask
;  JMP >B00                 ;Do it
B00:
  PUSH BX,DS               ;Save used registers
  MOV  BX,40h              ;Point DS at the
  MOV  DS,BX               ;  BIOS Data Area
  TEST B [17h],AL          ;Is the bit set (sets return flag)
  POP  DS,BX               ;Restore used registers
  POP  AX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS KEYBOARD LED STATUS (TURN LEDs ON AND OFF AS APPROPRIATE)
;Inputs:  DS = ES = TSR Data Area
;         [DI] = Keyboard Info Table Entry
;Outputs:
;Changes:
;NOTE:  We will have the LEDs simply mirror the BIOS Data Area.
;       We will not try to keep track of things from "inside the keyboard".
;------------------------------------------------------------------------------
ProcessLEDs:
  PUSH AX,CX,SI                      ;Save used registers
  PUSH DS                            ;Save used registers
  MOV  AX,40h                        ;Point DS at the
  MOV  DS,AX                         ;  BIOS Data Area
  MOV  AL,[0097h]                    ;Get Keyboard Status Byte 4 (LEDs)
  POP  DS                            ;Restore used registers
  AND  AL,(BIOS97ScrLockLED+BIOS97NumLockLED+BIOS97CapLockLED)
  CMP  AL,[DI].DILockStatusLT        ;Has it changed since last time?
  MOV  [DI].DILockStatusLT,AL        ;Save it for next time
  JE  >L90                           ;If no change, we're done
  XOR  AH,AH                         ;Assume no LEDs are on
L10:                                 ;Test ScrollLock
  TEST AL,BIOS97ScrLockLED           ;ScrollLock On?
  JZ  >L20                           ;If not, try next one
  OR   AH,LEDScrollLockMask          ;If so, turn it on
L20:                                 ;Test NumLock
  TEST AL,BIOS97NumLockLED           ;NumLock On?
  JZ  >L30                           ;If not, try next one
  OR   AH,LEDNumLockMask             ;If so, turn it on
L30:                                 ;Test CapsLock
  TEST AL,BIOS97CapLockLED           ;CapsLock On?
  JZ  >L50                           ;If not, send it
  OR   AH,LEDCapsLockMask            ;If so, turn it on
L50:                                 ;LED Status is calculated (in BL)
  MOV  LEDStatus,AH                  ;Put Status Byte in Memory
  MOV  SI,Int14Request2              ;Point at Request Structure
  MOV  [SI].I14RRequestType,I14RRTDoControl       ;Type = Control
  MOV  W [SI].I14RDataAddress[0],OFFSET LEDStatus ;Byte to send
  MOV  W [SI].I14RCallBackAddr[0],-1 ;Code to call when done
  MOV  AX,W [DI].DIHostIndex         ;Copy Host Index and
  MOV  W [SI].I14RHostIndex,AX       ;  Device Address
  MOV  [SI].I14REndPoint,0           ;Use End Point 0
  MOV  CX,SetLEDReq                  ;Copy
  CALL CopySetupReqToInt14SI         ;  Request Pkt
  MOV  AL,[DI].DIInterfaceNum        ;Copy
  MOV  B [SI].I14RSetLEDIntf,AL      ;  the Interface Number
  CALL DoInt14CallSaveAllSI          ;Send Request to the Keyboard
L90:                                 ;Done
  POP  SI,CX,AX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEND A SCAN CODE PREFACED WITH A 224 SCAN CODE
;Inputs:  DS = ES = TSR Data Area
;         BL = Scan Code to send (if SendKeyWith224)
;Outputs: To Scan Code Buffer
;Changes:
;------------------------------------------------------------------------------
SendKeyWith224:
  PUSH BX                         ;Save used registers
  MOV  BH,BL                      ;Save key to send
  JMP >F00                        ;Do it
SendFakeLeftShift:
  PUSH BX                         ;Save used registers
  MOV  BH,ScanCodeLShift          ;Send a Left Shift
  JMP >F00                        ;Do it
ReleaseFakeLeftShift:
  PUSH BX                         ;Save used registers
  MOV  BH,(ScanCodeLShift OR 80h) ;Send a Left Shift Release
  JMP >F00                        ;Do it
SendFakeRightShift:
  PUSH BX                         ;Save used registers
  MOV  BH,ScanCodeRShift          ;Send a Right Shift
  JMP >F00                        ;Do it
ReleaseFakeRightShift:
  PUSH BX                         ;Save used registers
  MOV  BH,(ScanCodeRShift OR 80h) ;Send a Right Shift Release
;  JMP >F00                       ;Do it
F00:
  MOV  BL,224                     ;Send the
  CALL PutBuffer                  ;  224
  MOV  BL,BH                      ;Send the
  CALL PutBuffer                  ;  second Key
  POP  BX                         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF A "LOCK" STATUS IS ENABLED IN THE BIOS DATA AREA
;Inputs:  DS = ES = TSR Data Area
;Outputs: ZF = Clear if Lock is Enabled
;            = Set Lock is Disabled
;Changes:
;------------------------------------------------------------------------------
;TestScrollLock:
;  PUSH AX                ;Save used registers
;  MOV  AH,BIOS17ScrLockA ;Mask to Test
;  JMP >L00               ;Do it
TestNumLock:
  PUSH AX                ;Save used registers
  MOV  AH,BIOS17NumLockA ;Mask to Test
;  JMP >L00               ;Do it
;TestCapsLock:
;  PUSH AX                ;Save used registers
;  MOV  AH,BIOS17CapLockA ;Mask to Test
;  JMP >L00              ;Do it
L00:
  CALL GetBIOSLockStatus ;Get the Lock Status Byte
  TEST AL,AH             ;Test it
  POP  AX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE CURRENT "LOCK" STATUS WORD FROM THE BIOS DATA AREA
;Inputs:  DS = ES = TSR Data Area
;Outputs: AL = Current Lock Status
;Changes:
;------------------------------------------------------------------------------
GetBIOSLockStatus:
  PUSH BX,DS    ;Save used registers
  MOV  BX,40h   ;Point DS at
  MOV  DS,BX    ;  the BIOS Data Area
  MOV  AL,[17h] ;Get the Keboard Status Word
  AND  AL,BIOS17ScrLockA+BIOS17NumLockA+BIOS17CapLockA
                ;Mask out everything but the Lock Keys
  POP  DS,BX    ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE NEEDED TO STORE AND GET THINGS FROM THE SCAN CODE BUFFER
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;-----------------------------------------------------------------------------
;PUT A SCAN CODE AT THE END OF THE CIRCULAR BUFFER
;Inputs:  DS = ES = TSR Data Area
;         BufferHead, BufferTail = Head and Tail of the circular buffer
;         BL = Scan Code to put in the Buffer
;Outputs: Adds a Scan Code to the end of the Buffer
;         CF = Clear if it worked OK
;            = Set if it didn't work
;Changes: BufferTail, BufferCount
;NOTES: This checks the Scan Code, and if it is a 224 or 225, makes sure
;         there is "extra" space in the buffer for the additional Scan Code(s)
;         that will follow.  If there is not room, this will issue a
;         Beep Request to the Host Driver(s).
;-----------------------------------------------------------------------------
PutBuffer:
  PUSH AX,DI           ;Save used registers
  CLI                  ;Disable interrupts
  MOV  AL,BufferSize   ;Assume a single (non-extended) Scan Code
  CMP  BL,224          ;Is it a two- or three-number Scan Code?
  JB  >P10             ;If not, continue
  CMP  BL,225          ;Is it a two- or three-number Scan Code?
  JA  >P10             ;If not, continue
  PUSHF                ;Save flags
  DEC  AL              ;Need at least two spaces in the buffer
  POPF                 ;Restore flags
  JNE >P10             ;If not 225, it was 224, and AL is OK
  DEC  AL              ;If 225, we need at three spaces in the buffer
P10:                   ;AL contains maximum BufferCount
  CMP  BufferCount,AL  ;Is the buffer already too full?
  JAE >P85             ;If so, beep the speaker
  MOV  DI,BufferTail   ;If OK, get the buffer Tail
  INC  DI              ;Point at the next space in the buffer
  CMP  DI,BufferEnd    ;Will this put us past the end of the Buffer?
  JBE >P40             ;If not, our pointer is OK
  MOV  DI,Buffer       ;If so, point at the beginning of buffer
P40:                   ;Buffer Pointer is correct
  MOV  [DI],BL         ;Store the code
  MOV  BufferTail,DI   ;Store the new Tail
  INC  BufferCount     ;Increment the counter
P80:                   ;It worked OK
  CLC                  ;Set the "it worked" flag
  JMP >P90             ;We're done
P85:                   ;The buffer is already full
  CALL SendBeepRequest ;Beep the Speaker
  STC                  ;Set the "buffer is full" flag
P90:                   ;We're done
  STI                  ;Enable interrupts
  POP  DI,AX           ;Restore used registers
  RET

;-----------------------------------------------------------------------------
;ISSUE A REQUEST TO THE HOST DRIVER(S) TO BEEP THE SPEAKER
;Inputs:  DS = ES = TSR Data Area
;Outputs: Issues Beep Request to the Host Drivers
;Changes: Int14Request2
;NOTES: This issues a Request to Beep at 800 Hz, for 1 DeciSecond, which is
;         what we wil use as an error code for bad codes/buffer errors.
;-----------------------------------------------------------------------------
SendBeepRequest:
  PUSH AX,SI                      ;Save used registers
  MOV  SI,Int14Request2           ;Point at Request Structure
  MOV  [SI].I14RRequestType,I14RRTBeepSpeaker ;Request = Beep Speaker
  MOV  [SI].I14RHostIndex,-1      ;Any Host
  MOV  [SI].I14RBeepFrequency,800 ;Frequency = 800Hz
  MOV  AX,[SI].I14RTimeout        ;Save current Timeout value
  MOV  [SI].I14RTimeout,1         ;Beep length = 1 DeciSeconds
  CALL DoInt14CallSaveAllSI       ;Do it
  MOV  [SI].I14RTimeOut,AX        ;Restore original Timeout Value
  POP  SI,AX                      ;Restore used registers
  RET

;-----------------------------------------------------------------------------
;GET A SCAN CODE FROM THE BEGINNING OF THE CIRCULAR BUFFER
;Inputs:  DS = ES = TSR Data Area
;         BufferHead, BufferTail = Head and Tail of the circular buffer
;Outputs: Gets the next Scan Code from the buffer
;         BL = Scan code from the buffer
;         CF = Clear if it worked OK
;            = Set if it didn't work
;Changes: BufferHead (if there is anything in the buffer)
;-----------------------------------------------------------------------------
GetBuffer:
  PUSH DI             ;Save used registers
  CLI                 ;Disable interrupts
  CMP  BufferCount,0  ;Does the buffer have anything in it?
  JE  >G85            ;If not, we can't do anything
  MOV  DI,BufferHead  ;If so, point at the buffer Head
  MOV  BL,[DI]        ;Get the code
  INC  DI             ;Point at the next space in our buffer
  CMP  DI,BufferEnd   ;Will this put us past the end of the Buffer?
  JBE >G10            ;If not, our pointer is OK
  MOV  DI,Buffer      ;If so, point at the beginning of the Buffer
G10:                  ;Buffer Pointer is OK
  MOV  BufferHead,DI  ;Store the new Head
  DEC  BufferCount    ;Decrement the counter
G80:                  ;There's a scan code in AL
  CLC                 ;Set the "it worked" flag
  JMP >G90            ;We're done
G85:                  ;The buffer is empty
  STC                 ;Set the "buffer was empty" flag
G90:                  ;We're done
  STI                 ;Enable interrupts
  POP  DI             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;"TYPE" THE NEXT SCAN CODE THAT IS IN THE BUFFER
;Inputs:  DS = ES = TSR Data Area
;         Buffer
;Outputs: CF = Set if nothing was sent (Buffer Empty)
;            = Clear if something was typed
;Changes: "Types" the Scan Codes
;NOTE: This will only type 1 key at a time.  This is done to avoid problems
;        with some keystrokes (such as Pause or hot-keys in certain TSR's)
;        that issue an End-of-Interrupt signal, but continue running a
;        significant amount of code after they do (including waiting for
;        more keystrokes).  When using methods 2 or 3 with a program
;        that does this, we will lock up the computer if we try to "type"
;        more than one key at a time during a hardware interrupt.
;------------------------------------------------------------------------------
TypeNextKey:
  PUSH BX        ;Save used registers
T10:             ;Loop to here for each Scan Code in buffer
  CALL GetBuffer ;Get Keystroke from Buffer (BL)
  JC  >T90       ;If buffer is Empty, we're done
  OR   BL,BL     ;Is it a legitimate ScanCode?
  JZ   T10       ;If not, get the next one
  CMP  BL,128    ;Is it a legitimate ScanCode?
  JE   T10       ;If not, get the next one
  CALL FakeIt    ;If OK, "type" the Scan Code
  CLC            ;Set "typed something" flag
T90:             ;Done
  POP  BX        ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE NEEDED TO "TYPE" SCAN CODES, USING THE VARIOUS METHODS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;"TYPE" A SCAN CODE
;Inputs:  DS = ES = TSR Data Area
;         BL = Scan Code To Type
;         Method
;Outputs:
;Changes: "Types" the Scan Code
;------------------------------------------------------------------------------
FakeIt:
  CMP  Method,2 ;Which Method to use?
  JE  >F20      ;If Method 2, handle it
  JA  >F30      ;If Method 3, handle it
  CALL FakeIt1  ;Do Method 1
  JMP >F90      ;Done
F20:            ;Method 2
  CALL FakeIt2  ;Do Method 2
  JMP >F90      ;Done
F30:            ;Method 3
  CALL FakeIt3  ;Do Method 3
F90:            ;Done
  RET

;------------------------------------------------------------------------------
;FAKE A KEYBOARD KEYSTROKE USING METHOD 1 (WORKS WITH WINDOWS?)
;Inputs:  DS = ES = TSR Data Area
;         BL = Scan Code to fake
;Outputs: Sends the Scan Code to the keyboard controller to fake a keystroke
;Changes:
;------------------------------------------------------------------------------
FakeIt1:
  PUSH AX              ;Save used registers
  CLI                  ;Disable interrupts
  CALL WaitKbdInEmpty  ;Wait for the Input Buffer to clear
  MOV  AL,0D2h         ;When clear, function D2H (Fake a scancode with our key)
  OUT  64h,AL          ;Send it
  CALL WaitKbdInEmpty  ;Wait for the controller to take it in
  MOV  AL,BL           ;Send our ScanCode to the keyboard
  OUT  60h,AL          ;  (IRQ will be generated automatically)
  STI                  ;Enable interrupts (let Interrupt 09 occur)
  CALL WaitKbdInEmpty  ;Wait for the Input Buffer to clear
  CALL WaitKbdOutEmpty ;Wait for the Output Buffer to Clear
  POP  AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FAKE A KEYBOARD KEYSTROKE USING METHOD 2 (WORKS WITH MOST AT KEYBOARDS)
;Inputs:  DS = ES = TSR Data Area
;         BL = Scan Code to fake
;Outputs: Sends the Scan Code to the keyboard controller to fake a keystroke
;Changes:
;------------------------------------------------------------------------------
FakeIt2:
  PUSH AX              ;Save used registers
  PUSHF                ;Save Flags
  CLI                  ;Disable interrupts
  CALL DisableKbdInt   ;Disable Keyboard IRQ (so OUT 20h,20h at end of
                       ;  IRQ processing routine doesn't screw us up)
  CALL WaitKbdOutEmpty ;Wait for Keyboard Output Buffer to Clear
  JNZ >F90             ;If it never clears, quit
  CALL WaitKbdInEmpty  ;Wait for Keyboard Input Buffer to Clear
;  JNZ >F90             ;If it never clears, quit
  MOV  AL,KCCBWrite    ;Tell Keyboard Controller to
  OUT  64h,AL          ;  read the next byte as the KCCB
  CALL WaitKbdInEmpty  ;Wait for the Controller to take it in
;  JNZ >F90             ;If it didn't work, quit
  MOV  AL,BL           ;Send our scan code
  OUT  60h,AL          ;  to the keyboard as the KCCB
  CALL WaitKbdInEmpty  ;Wait for the buffer to Empty
  MOV  AL,KCCBRead     ;Tell Keyboard Controller to
  OUT  64h,AL          ;  output the KCCB to Port 60h
  CALL WaitKbdOutFull  ;Wait for the Keyboard to take it in
  MOV  AL,KCCBWrite    ;Tell Keyboard Controller to
  OUT  64h,AL          ;  read the next byte as the KCCB
  CALL WaitKbdInEmpty  ;Wait for the Controller to take it in
  MOV  AL,45h          ;Tell the Keyboard Controller to
  OUT  60h,AL          ;  work normally again
  IN   AL,60h          ;This prevents some computers from generating INT's
  INT  09              ;Perform the Int 09 Code
;  CALL WaitKbdInEmpty  ;Wait for the Input Buffer to Clear
;  MOV  AL,0AEh         ;Enable the Keyboard
;  OUT  64h,AL          ;  just to be safe
F90:                   ;Done
  CALL EnableKbdInt    ;Reenable the Keyboard Interrupt
  POPF                 ;Restore Flags
  POP  AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WAIT FOR THE KEYBOARD INPUT/OUTPUT BUFFER TO BE FULL/EMPTY
;Inputs:  DS = ES = TSR Data Area
;Outputs: If WaitXXFull:
;           ZF = Clear if OK (Buffer is Full)
;              = Set if Error (timed out waiting for Buffer to Fill)
;         If WaitXXEmpty:
;           ZF = Set if OK (Buffer is Empty)
;              = Clear if Error (timed out waiting for Buffer to Empty)
;Changes:
;------------------------------------------------------------------------------
;WaitKbdInFull:
;  PUSH AX                ;Save used registers
;  MOV  AH,P64InBuffFull  ;AH = bit to test for
;  JMP >F00               ;Do it
WaitKbdOutFull:
  PUSH AX                ;Save used registers
  MOV  AH,P64OutBuffFull ;AH = bit to test for
;  JMP >F00               ;Do it
F00:
  PUSH CX                ;Save used registers
  PUSHF                  ;Save flags
  CLI                    ;Disable interrupts
  MOV  CX,200            ;Try it 200 times before timing out
F10:                     ;Loop to here to wait for buffer to be full
  IN   AL,64h            ;Get the data from the controller
  TEST AL,AH             ;Is it full yet?
  LOOPZ F10              ;If not, keep waiting
F90:                     ;Done
  POPF                   ;Restore flags
  POP  CX                ;Restore used registers
  POP  AX                ;Restore used registers
  RET

WaitKbdInEmpty:
  PUSH AX                ;Save used registers
  MOV  AH,P64InBuffFull  ;AH = bit to test for
  JMP >E00               ;Do it
WaitKbdOutEmpty:
  PUSH AX                ;Save used registers
  MOV  AH,P64OutBuffFull ;AH = bit to test for
;  JMP >E00               ;Do it
E00:
  PUSH CX                ;Save used registers
  PUSHF                  ;Save flags
  CLI                    ;Disable interrupts
  MOV  CX,200            ;Try it 200 times before timing out
E10:                     ;Loop to here to wait for buffer to be full
  IN   AL,64h            ;Get the data from the controller
  TEST AL,AH             ;Is it empty yet?
  LOOPNZ E10             ;If not, keep waiting
E90:                     ;Done
  POPF                   ;Restore flags
  POP  CX                ;Restore used registers
  POP  AX                ;Restore used registers
  RET

;-----------------------------------------------------------------------------
;FAKE A KEYBOARD INTERRUPT WITh METHOD 3
;Inputs:  DS = ES = TSR Data Area
;         BL = ScanCode to fake
;Outputs:
;Changes: Fakes a keyboard interrupt
;-----------------------------------------------------------------------------
FakeIt3:
  PUSH AX,SI                      ;Save used registers
  AND  TSRFlags2,(NOT DoLoopTest) ;Default is no loop test
  MOV  AL,BL                      ;Is this Scancode
  MOV  SI,LoopTestCodes           ;  one of the "special" ones
  CALL SearchByteTblSI            ;  we need to do a loop test on?
  JC  >F30                        ;If not, just send it
  OR   TSRFlags2,DoLoopTest       ;We need to do the loop test
F30:                              ;Our loop test flag is set
  MOV  ScanCode,BL                ;Put the new ScanCode where Int01 can find it
  MOV  InstrCounter,1000          ;Initialize Maximum Instruction Counter
  AND  TSRFlags,(NOT EOIIssued)   ;Mark as not receiving End-of-Interrupt yet
  CALL StartInt01                 ;If so, initialize the Single Step Vector
  CALL PutScanCode                ;Fake the code
  CALL StopInt01                  ;If not recursive, reset the Single Step Vector
  MOV  InstrCounter,0             ;Reset OUT 20h,20h Instruction Counter
F90:                              ;Done
  POP  SI,AX                      ;Restore used registers
  RET

;-----------------------------------------------------------------------------
;DISABLE KBD INT & CHANGE INT 01 (SST) CODE TO OURS
;Inputs:  DS = ES = TSR Data Area
;Outputs:
;Changes:
;-----------------------------------------------------------------------------
StartInt01:
  PUSH AX,BX               ;Save used registers
  INC  Int01Counter        ;Increment Recursive Counter
  CMP  Int01Counter,1      ;First time?
  JNE >T90                 ;If not, just quit
  CALL DisableKbdInt       ;Don't allow real keystrokes
  MOV  AL,1                ;Change INT 01 vector
  MOV  BX,OFFSET Int01Vect ;Point to its new value
  CALL SwapIntVect         ;Swap it
T90:                       ;Done
  POP  BX,AX               ;Restore used registers
  RET

;-----------------------------------------------------------------------------
;CHANGE INT 01 (SST) BACK TO ORIGINAL & ENABLE KBD INT
;Inputs:  DS = ES = TSR Data Area
;Outputs:
;Changes: INT 01 Code, Enables Keyboard Interrupt
;-----------------------------------------------------------------------------
StopInt01:
  PUSH AX,BX               ;Save used registers
  CMP  Int01Counter,0      ;Recursive Counter already 0?
  JE  >P90                 ;If so, just quit
  DEC  Int01Counter        ;If not, decrement it
  JNZ >P90                 ;If not 0 yet, keep waiting
  MOV  AL,1                ;Change INT 01 vector
  MOV  BX,OFFSET Int01Vect ;Point to its original value
  CALL SwapIntVect         ;Swap it back
  CALL EnableKbdInt        ;Allow real keystrokes again
P90:                       ;DOne
  POP  BX,AX               ;Restore used registers
  RET

;-----------------------------------------------------------------------------
;DISABLE KEYBOARD INTERRUPTS
;Inputs:  DS = ES = TSR Data Area
;Outputs:
;Changes: Disables Keyboard (Hardware) Interrupt
;-----------------------------------------------------------------------------
DisableKbdInt:
  PUSH AX     ;Save used register
  PUSHF       ;Save flags
  CLI         ;Disable interrupts
  IN   AL,21h ;Get current Hardware Interrupt status byte
  OR   AL,02h ;Disable Keyboard Interrupt (IRQ 1/INT 9)
  OUT  21h,AL ;Do it
  POPF        ;Restore flags
  POP  AX     ;Restore used register
  RET

;-----------------------------------------------------------------------------
;ENABLE KEYBOARD INTERRUPTS
;Inputs:  DS = ES = TSR Data Area
;Outputs:
;Changes: Enables Keyboard (Hardware) Interrupt
;-----------------------------------------------------------------------------
EnableKbdInt:
  PUSH AX           ;Save used register
  PUSHF             ;Save flags
  CLI               ;Disable interrupts
  CALL EnableKbd    ;Make sure the Keyboard itself is Enabled
  IN   AL,21h       ;Get current Hardware Interrupt status byte
  AND  AL,(NOT 02h) ;Enable Keyboard Interrupt (IRQ 1/INT 9)
  OUT  21h,AL       ;Do it
  POPF              ;Restore flags
  POP  AX           ;Restore used register
  RET

;------------------------------------------------------------------------------
;ISSUE THE COMMAND TO THE KEYBOARD CONTROLLER TO DISABLE OR ENABLE THE KEYBOARD
;Inputs:
;Outputs:
;Changes: Issues the command to the Keyboard Controller to enables the Keyboard
;------------------------------------------------------------------------------
;DisableKbd:
;  PUSH AX             ;Save used registers
;  MOV  AL,0ADh        ;AL = ADh -= Disable Keyboard
;  JMP >A00            ;Continue
EnableKbd:
  PUSH AX             ;Save used registers
  MOV  AL,0AEh        ;AL = AEh -= Enable Keyboard
;  JMP >A00            ;Continue
;A00:
  PUSHF               ;Save flags
  CLI                 ;Disable interrupts
;  STI                 ;Enable interrupts
  CALL WaitKbdInEmpty ;Wait for the Keyboard Input buffer to clear
;  JNZ >A90            ;If it never clears, quit
  OUT  64h,AL         ;Send the command
;  CALL WaitKbdInEmpty ;Wait for the Keyboard Controller to accept it
A90:                  ;Done
  POPF              ;Restore flags
  POP  AX             ;Restore used registers
  RET

;-----------------------------------------------------------------------------
;"FAKE" INT 09 INTO ACCEPTING OUR SCAN CODE (NOT FROM KEYBOARD)
;Inputs:  DS = ES = TSR Data Area
;         ScanCode = Scan Code to use
;Outputs:
;Changes: Performs a "fake" INT 09 using the Scan Code
;-----------------------------------------------------------------------------
PutScanCode:
  PUSH AX,BX               ;Save used registers
  MOV  AL,9                ;Want to work with INT 09
  MOV  BX,OFFSET IntXXVect ;Point to Data area
  CALL MoveFromIntVect     ;Put INT XX Vector in storage
  PUSHF                    ;Get the
  POP  AX                  ;  flags
  OR   AH,((IntFlag+TrapFlag)SHR 8) ;Do Int 9 with Int & Trap flags On
  MOV  IntXXFlags,AX       ;Set Flags the way we want them to be
  POP  BX,AX               ;Restore used registers
  CALL DoIntXX             ;Perform Int 09 w/ Int 01 Enabled
  RET

;-----------------------------------------------------------------------------
;DO INT XX WITH OUR FLAGS
;Inputs:  IntXXFlags, IntXXVect
;Outputs:
;Changes: Performs INT XX with our Flags, Returns to this code
;-----------------------------------------------------------------------------
DoIntXX:
  PUSHF            ;Save current Flags
  PUSH CS          ;Push our CS for the return
  CALL DoIntXXPush ;Push things and do the INT
  RET

DoIntXXPush:
  PUSH W CS:IntXXFlags   ;Push the Flags
  PUSH W CS:IntXXVect[2] ;Push the CS
  PUSH W CS:IntXXVect[0] ;Push the IP
  IRET                   ;Do it

;-----------------------------------------------------------------------------
;SWAP OR CHANGE INTERRUPT VECTOR TO/FROM OUR CODE
;Inputs:  AL = Interrupt Number to Change
;         CS:[BX] = What we want it swapped with
;Outputs:
;Changes: Interrupt vector ->, <-, or <-> New Address
;-----------------------------------------------------------------------------
SwapIntVect:
  PUSH CX              ;Save used register
  XOR  CL,CL           ;If Swap, CL=00
  JMP >V10             ;Jump to do it
;MoveToIntVect:
;  PUSH CX              ;Save used register
;  MOV  CL,01           ;If Move To, CL=01
;  JMP >V10             ;Jump to do it
MoveFromIntVect:
  PUSH CX              ;Save used register
  MOV  CL,02           ;If Move From, CL=02
V10:                   ;Swap or change Int vect
  PUSH AX,BX,DI,ES     ;Save used registers
  MOV  CH,AL           ;Save Int # in CH
  XOR  AX,AX           ;AX=0000
  MOV  ES,AX           ;ES=0000 (Int Vector Table)
  MOV  AL,CH           ;Get Int # Back
  ADD  AX,AX           ;Multiply Int #
  ADD  AX,AX           ;  by 4 (to get offset)
  MOV  DI,AX           ;Put it in DI
  CLI                  ;Disable Interrupts
  CALL ChangeIntVectDo ;Change the IP
  INC  BX,2            ;Point to New CS
  INC  DI,2            ;Point to old CS
  CALL ChangeIntVectDo ;Change the CS
  STI                  ;Enable Interrupts
  POP  ES,DI,BX,AX     ;Restore used registers
  POP  CX              ;Restore used register
  RET

;-----------------------------------------------------------------------------
;SWAP OR CHANGE ES:[DI] TO/FROM CS:[BX]
;Inputs:  CL=00   ES:[DI] <-> CS:[BX]
;         CL=01   ES:[DI] <-  CS:[BX]
;         CL=02   ES:[DI]  -> CS:[BX]
;Outputs:
;Changes: AX
;-----------------------------------------------------------------------------
ChangeIntVectDo:
  CMP  CL,02      ;Are we Moving From?
  JNE >D10        ;If so, skip the next few steps
  MOV  AX,ES:[DI] ;If no, put old vector in AX
  JMP >D20        ;Jump to change it
D10:              ;Move to or Swap
  MOV  AX,CS:[BX] ;If Move To or Swap, Put New Vector in AX
  XCHG AX,ES:[DI] ;Swap new & old vectors
  CMP  CL,01      ;Are we Moving To?
  JE  >D90        ;If so, skip the next step
D20:              ;Move from or Swap
  MOV  CS:[BX],AX ;If Move From or Swap, Put old vector in CS:[BX]
D90:              ;We're done
  RET

;-----------------------------------------------------------------------------
;INTERRUPT 01 (SINGLE STEP):  PERFORMED AFTER EACH STEP IN INT 09
;Inputs:  ScanCode =  Scan Code to "fake" into INT 09
;Outputs:
;Changes: Single-Steps through INT 09 CALL
;-----------------------------------------------------------------------------
Int01:
  PUSH BP               ;Save used register
  MOV  BP,SP            ;Want to work with the stack
  PUSH AX,BX,DS,ES      ;Save used registers
  MOV  DS,CS            ;Make CS & DS the same
  LES  BX,SS:[BP+2]     ;ES = Current CS, BX = Current IP
  MOV  AX,ES:[BX]       ;Put the OpCode in AX
  DEC  InstrCounter     ;Decrement the Counter
  JNZ >Z10              ;If not 0 yet, keep working
Z05:                    ;Too many insructions - Give it up
  AND  B SS:[BP+7],((NOT TrapFlag)SHR 8) ;Unset Trap flag
  CALL EnableKbdInt     ;Enable the Keyboard Interrupt
  JMP >Z90              ;Done
Z10:                    ;Not timed out yet
  CMP  DoNextTime,Yes   ;Do we need to do it again?
  MOV  DoNextTime,No    ;Reset the NextTime flag
  JNE >Z20              ;If not, continue
  MOV  AL,ScanCode      ;Get our scan code
  CMP  AL,SS:[BP-2]     ;Did our code work last time?
  JE  >Z90              ;If so, no need to do it again
  MOV  SS:[BP-2],AL     ;If not, do it again
  JMP >Z90              ;Done
Z20:                    ;Need to test actual OpCode
  CMP  AL,OpCodeInt1Min ;Is the OpCode in the range we care about?
  JB  >Z90              ;If not, we're done
  CALL I1TestReboot     ;Are we in the middle of a Reboot?
  JNC >Z90              ;If so, we're done
  CALL I1TestLoop       ;Is it a Loop?
  JNC >Z90              ;If so, we're done
  CALL I1TestIN60h      ;Is it IN 60h?
  JNC >Z90              ;If so, we're done
  CALL I1TestOUT20h     ;Is it OUT 20h?
  JNC >Z90              ;If so, we're done
  CALL I1TestOUT60h     ;Is it OUT 60h?
  JNC >Z90              ;If so, we're done
  CALL I1TestOUT64h     ;Is it OUT 64h?
  JNC >Z90              ;If so, we're done
  CMP  AL,OpCodeINTxx   ;Is it an INT xx?
  JNE >Z90              ;If not, we're done
  CALL I1INTxxTest      ;If so, should we run it with Trap Set?
  JC  >Z99              ;If with Trap Set, handle it
Z90:                    ;Done
  POP  ES,DS,BX,AX      ;Restore used registers
  POP  BP               ;Restore used registers
  IRET

Int01Int:
Z99:
  MOV  AL,AH               ;Get the interrupt number
  MOV  BX,OFFSET IntXXVect ;Point at our data area
  CALL MoveFromIntVect     ;Store our interrupt pointer
  MOV  AX,SS:[BP+06]       ;Get the original flags
  MOV  IntXXFlags,AX       ;Store them for this interrupt
  ADD  W SS:[BP+2],2       ;Skip past the INT for next time through
  POP  ES,DS,BX,AX         ;Restore used registers
  POP  BP                  ;Restore used registers
  JUMP DoIntXXPush         ;Do the interrupt

;------------------------------------------------------------------------------
;TEST THE NEXT OPCODE TO SEE IF IT'S A REBOOT SEQUENCE (CTRL-ATL-DEL)
;Inputs:  CS = DS = TSR Data Area
;         AX        = Next OpCode to be performed
;         SS:[BP-2] = Original AX
;         SS:[BP+2] = Original IP
;         SS:[BP+4] = Original CS
;         SS:[BP+6] = Original Flags
;         ES:[BX]   = Original CS:IP
;Outputs: CF = Clear if it is a Reboot sequence
;              Disables Trap Flag
;            = Set if not Reboot Sequence
;Changes:
;------------------------------------------------------------------------------
I1TestReboot:
  PUSH AX                      ;Save used registers
  CMP  ScanCode,ScanCodeDelete ;Are we pushing Del?
  JNE >B70                     ;If not, quit
  CMP  BX,RebootIP             ;If so, are we at the reboot IP?
  JNE >B70                     ;If not, quit
  MOV  AX,ES                   ;Put ES in AX where we can test it
  CMP  AX,RebootCS             ;Are we at the reboot CS?
  JNE >B70                     ;If not, quit
  AND  B SS:[BP+7],((NOT TrapFlag)SHR 8) ;Unset Trap flag for next time
  MOV  InstrCounter,0          ;Reset the Instruction Counter
  CALL EnableKbdInt            ;Enable the Keyboard
  JMP >B80                     ;Done
B70:                           ;Not handled
  STC                          ;Set not handled flag
  JMP >B90                     ;Done
B80:                           ;Handled
  CLC                          ;Set handled flag
B90:                           ;Done
  POP  AX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST THE NEXT OPCODE TO SEE IF IT'S A LOOP WITH A LARGE VALUE IN CX
;Inputs:  CS = DS = TSR Data Area
;         AX        = Next OpCode to be performed
;         SS:[BP-2] = Original AX
;         SS:[BP+2] = Original IP
;         SS:[BP+4] = Original CS
;         SS:[BP+6] = Original Flags
;         ES:[BX]   = Original CS:IP
;Outputs: CF = Clear if it is a Large Loop
;              Modifies Flags/Counters as appropriate
;            = Set if not a Large Loop
;Changes:
;NOTES: With certain Keyboard Drivers (notably with some non-US keyboard
;         drivers),
;------------------------------------------------------------------------------
I1TestLoop:
  CMP  AL,OpCodeLOOP        ;Is it a LOOP?
  JE  >L10                  ;If so, handle it
  CMP  AL,OpCodeLOOPNZ      ;Is it a LOOPNZ?
  JE  >L10                  ;If so, handle it
  CMP  AL,OpCodeLOOPZ       ;Is it a LOOPZ?
  JNE >L70                  ;If not, quit
L10:                        ;Is a Loop OpCode
  TEST TSRFlags2,DoLoopTest ;Do we need to do a LOOP test?
  JZ  >L80                  ;If not, we're done
  CMP  CX,500               ;If so, is CX more than 500 (a really long wait)?
  JBE >L80                  ;If not, we're done
  MOV  CX,10                ;If so, make CX=10
  JMP >L80                  ;Done
L70:                        ;Not handled
  STC                       ;Set not handled flag
  JMP >L90                  ;Done
L80:                        ;Handled
  CLC                       ;Set handled flag
L90:                        ;Done
  RET

;------------------------------------------------------------------------------
;TEST THE NEXT OPCODE TO SEE IF IT'S AN IN 60h (Get ScanCode)
;Inputs:  CS = DS = TSR Data Area
;         AX        = Next OpCode to be performed
;         SS:[BP-2] = Original AX
;         SS:[BP+2] = Original IP
;         SS:[BP+4] = Original CS
;         SS:[BP+6] = Original Flags
;         ES:[BX]   = Original CS:IP
;Outputs: CF = Clear if it is an IN 60h
;              Modifies Flags/Counters as appropriate
;            = Set if not an IN 60h
;Changes:
;------------------------------------------------------------------------------
I1TestIN60h:
  PUSH AX              ;Save used registers
  CMP  AL,OpCodeINALDX ;Is it IN AL,DX?
  JE  >I10             ;If so, handle it
  CMP  AL,OpCodeINAXDX ;Is it IN AX,DX?
  JNE >I20             ;If not, try the next possibility
I10:                   ;Is IN AL,DX or IN AX,DX
  CMP  DX,60h          ;If so, does DX=60h?
  JE  >I50             ;If so, handle it
  JMP >I70             ;If not, quit
I20:                   ;Test IN AL,60h
  CMP  AX,(OpCodeINALxx+(60h SHL 8)) ;Is it IN AL,60h?
  JE  >I25                           ;If so, handle it
  CMP  AX,(OpCodeINAXxx+(60h SHL 8)) ;Is it IN AX,60h?
  JNE >I70             ;If not, we're done
I25:                   ;Is IN AL,60h or IN AX,60h
  INC  W SS:[BP+2]     ;Increment IP to skip the IN
I50:                   ;Increment IP, set ScanCode
  INC  W SS:[BP+2]     ;Increment IP to skip the IN
  MOV  DoNextTime,Yes  ;Mark as needing to do it again next time
  MOV  AL,ScanCode     ;Set AL to
  MOV  SS:[BP-2],AL    ;  our ScanCode
  JMP >I80             ;Done
I70:                   ;Not handled
  STC                  ;Set not handled flag
  JMP >I90             ;Done
I80:                   ;Handled
  CLC                  ;Set handled flag
I90:                   ;Done
  POP  AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST THE NEXT OPCODE TO SEE IF IT'S AN OUT XX
;Inputs:  CS = DS = TSR Data Area
;         AX        = Next OpCode to be performed
;         SS:[BP-2] = Original AX
;         SS:[BP+2] = Original IP
;         SS:[BP+4] = Original CS
;         SS:[BP+6] = Original Flags
;         ES:[BX]   = Original CS:IP
;Outputs: CF = Clear if it is an OUT xx that we care about
;              Modifies Flags/Counters as appropriate
;            = Set if not an OUT xx that we care about
;Changes:
;------------------------------------------------------------------------------
I1TestOUT20h:
  PUSH BX                 ;Save used registers
  MOV  BX,20h             ;Mark as Port 20h
  JMP >U00                ;Do it
I1TestOUT60h:
  PUSH BX                 ;Save used registers
  MOV  BX,60h             ;Mark as Port 60h
  JMP >U00                ;Do it
I1TestOUT64h:
  PUSH BX                 ;Save used registers
  MOV  BX,64h             ;Mark as Port 64h
;  JMP >U00                ;Do it
U00:
  PUSH CX,DX              ;Save used registers
  MOV  DX,SS:[BP-2]       ;Put original calling program's AX in DX
  MOV  CX,1               ;Assume OUT DX,AL or OUT DX,AX
  CMP  AL,OpCodeOUTDXAL   ;Is it OUT DX,AL?
  JE  >U10                ;If so, handle it
  CMP  AL,OpCodeOUTDXAX   ;Is it OUT DX,AX?
  JNE >U20                ;If not, try the next possibility
U10:                      ;Is OUT DX,AL or OUT DX,AX
  CMP  DX,BX              ;Is it the Port we're looking for?
  JE  >U30                ;If so, continue
  JMP >U70                ;If not, quit
U20:                      ;Test OUT xx,AL our OUT xx,AX
  INC  CX                 ;Assume OUT xx,AL or OUT xx,AX
  CMP  AL,OpCodeOUTxxAL   ;Is it OUT xx,AL?
  JE  >U25                ;If so,handle it
  CMP  AL,OpCodeOUTxxAX   ;Is it OUT xx,AX?
  JNE >U70                ;If not, we're done
U25:                      ;Is correct OpCode
  CMP  AH,BL              ;Is it the Port we're looking for?
  JNE >U70                ;If not, quit
U30:                      ;Is correct OpCode & Port
  CMP  BL,60h             ;Which Port is it?
  JB  >U60                ;If Port 20h, handle it
  JE  >U50                ;If Port 60h, handle it
U40:                      ;Is OUT 64h
  CMP  DL,0ADh            ;Is it function ADh (Disable Keyboard)?
  JE  >U80                ;If so, we're done
  CMP  DL,0AEh            ;Is it function AEh (Enable Keyboard)?
  JE  >U80                ;If so, we're done
U50:                      ;Is OUT 60h or OUT 64h,ADh
  TEST TSRFlags,EOIIssued ;Have we received the End-of-Interrupt yet?
  JZ  >U80                ;If not, we're done
  AND  B SS:[BP+7],((NOT TrapFlag)SHR 8) ;Unset Trap flag for next time
  MOV  InstrCounter,0     ;Reset the Instruction Counter
  CALL EnableKbdInt       ;Enable the Keyboard
  JMP >U80                ;Done
U60:                      ;Is OUT 20h
  CMP  DL,20h             ;Does AL=20h (non-specific EOI)?
  JE  >U65                ;If so, handle it
  CMP  DL,61h             ;Does AL=61h (specific EOI, IRQ 1)?
  JNE >U70                ;If not, we're done
U65:                      ;Is OUT,20h (EOI)
  OR   TSRFlags,EOIIssued ;Mark us as having gotten the OUT 20h,20h
  MOV  InstrCounter,100   ;Set the Instruction Counter
  ADD  SS:[BP+2],CX       ;Increment IP to skip the OUT
  JMP >U80                ;Done
U70:                      ;Not handled
  STC                     ;Set not handled flag
  JMP >U90                ;Done
U80:                      ;Handled
  CLC                     ;Set handled flag
U90:                      ;Done
  POP  DX,CX              ;Restore used registers
  POP  BX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST THE NEXT OPCODE TO SEE IF IT'S AN INT XX
;Inputs:  CS = DS = TSR Data Area
;         AX        = Next OpCode to be performed (AL = INT OpCode, AH = INT #)
;         SS:[BP-2] = Original AX
;         SS:[BP+2] = Original IP
;         SS:[BP+4] = Original CS
;         SS:[BP+6] = Original Flags
;         ES:[BX]   = Original CS:IP
;         Already tested for the INT xx OpCode (AL)
;Outputs: CF = Clear if the INT is one we know about
;                (should run "normally" (without the Trap Flag Set)
;            = Set if we the INT is unknown
;                (should run with the Trap Flag Set)
;Changes:
;NOTE: INT's that we "don't know about" could possibly ask for an IN AL,60h
;        which we will need to simulate.  For the INT's that we do know about
;        (PrintScreen, SystemRequest, Break, Bootstrap, and Translate
;        ScanCode), we know the ScanCode has already been received and
;        processed, so we will not need to simulate the ScanCode again
;        during the INT.
;------------------------------------------------------------------------------
I1IntXXTest:
  PUSH AX           ;Save used registers
  MOV  AL,AH        ;Put INT # in AL (makes Code smaller)
  MOV  AH,SS:[BP-1] ;Put original AH (Interrupt Function Number) in AH
I10:                ;Test for PrintScreen
  CMP  AL,05h       ;Is it INT 05h (PrintScreen)?
  JE  >I80          ;If so, it's one we know about
I20:                ;Test for Break
  CMP  AL,1Bh       ;Is it INT 1Bh (Control-Break Handler)?
  JE  >I80          ;If so, it's one we know about
I30:                ;Test for Translate Scan Code & System Request
  CMP  AL,15h       ;Is it INT 15h (BIOS Services)?
  JNE >I40          ;If not, keep testing
  CMP  AH,4Fh       ;Is it Function 4Fh (Translate Scan Code)?
  JE  >I80          ;If so, it's one we know about
  CMP  AH,85h       ;Is it Function 85h (Alt-System Request Handler)?
  JE  >I80          ;If so, it's one we know about
  JMP >I70          ;If not, we don't know about it
I40:                ;Test for Flush Disk Buffers (part of Ctrl-Alt-Del)
  CMP  AL,21h       ;Is it Int 21h (DOS Services)?
  JNE >I70          ;If not, we don't know about it
  CMP  AH,0Dh       ;Is it Function 0Dh (Flush Disk Buffers)?
  JE  >I80          ;If so, it's one we know about
I70:                ;Not an INT we know about
  STC               ;Set return flag
  JMP >I90          ;Done
I80:                ;Is an INT we know about
  CLC               ;Set return flag
I90:                ;Done
  POP  AX           ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;Code needed to flag BIOS functions as allowing Keyboard Delay/Repeat Rate
;  Changes to be made with BIOS calls
;Also handles External Calls to "type" Keys
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HAVE INTERRUPT 16h (KEYBOARD BIOS SVCS) RUN THIS PROGRAM EVERY TIME IT OCCURS
;Inputs:  AH = Function number
;Outputs: Depends of Function Number
;Changes:
;------------------------------------------------------------------------------
Int16Hdr:
  DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code

Int16:
  PUSH BP                          ;Save used registers
  MOV  BP,SP                       ;Point BP at Stack
  PUSHF                            ;Save flags
  STI                              ;Enable Interrupts
  CLD                              ;Go forward with string functions
  TEST CS:TSRFlags,Uninstalled     ;Are we uninstalled?
  JNZ  Int16Old2                   ;If so, just quit
  CMP  AH,1Bh                      ;Function 1Bh (USB Extended functions)?
  JNE >S20                         ;If not, try the next possibility
  PUSH BX                          ;Save used registers
  MOV  BX,Int16FunctionTbl         ;Point at Code Offset table
  CALL SearchByte2WordTblCS        ;Is the sub-function in AL OK (returns BX)?
  POP  BX                          ;Restore used registers
  JNC >S10                         ;If OK, jump to handle it
  CALL TestOldInt16                ;Is subfunction supported by another program?
  JNC  Int16Old2                   ;If so, let the other program handle it
  MOV  AX,I16ErrBadFunction        ;If not, error = Bad Function Code
  OR   B SS:[BP+6],CarryFlag       ;Set CF for the return
  JMP >S95                         ;Done
S10:                               ;Is an extended INT 16h Call
  CALL DoInt16Ext                  ;If so, handle it (Sets return CF)
  JMP >S95                         ;Done
S20:                               ;Get Keyboard Functionality call?
  CALL MakeStack                   ;Create our own stack space
  CMP  AH,9                        ;Get Keyboard Functionality?
  JNE >S30                         ;If not, try next possibility
  MOV  AL,0Dh                      ;Mark Int 16h Func 0300, 0305, 0306 valid
  JMP >S90                         ;Done
S30:                               ;Set Typematic stuff?
  CMP  AH,3                        ;Set Typematic stuff?
  JNE  Int16Old                    ;If not, no need to do anything
  OR   AL,AL                       ;Function 0 (Set Default Rate)?
  JZ  >S40                         ;If so, jump to handle it
  CMP  AL,5                        ;Function 5 (Set Rate)?
  JB   Int16Old                    ;If not, it's not for us
  JE  >S40                         ;If so, handle it
  CMP  AL,6                        ;Function 6 (Get Current Rate)?
  JA   Int16Old                    ;If not, it's not for us
  JMP >S50                         ;If so, handle it
S40:                               ;Send to Real Keyboard also
  PUSH AX,BX,CX,DX,DI,SI,BP        ;Save possibly used registers
  PUSHF                            ;Send it to the
  CALL D CS:Int16Hdr.OldVector     ;  other keyboard(s) also
  POP  BP,SI,DI,DX,CX,BX,AX        ;Restore used registers
S50:                               ;Handle Function 03
  CALL ChangeRates                 ;Do it
S90:                               ;Done
  CALL ReturnStack                 ;Restore original stack space
  AND  B SS:[BP+6],(NOT CarryFlag) ;Clear Carry Flag for the Return
S95:                               ;Done
  POPF                             ;Restore flags
  POP  BP                          ;Restore used registers
  IRET

Int16Old:
  CALL ReturnStack                 ;Restore original stack space
Int16Old2:
  POPF                             ;Restore flags
  POP  BP                          ;Restore used registers
  JMP  D CS:Int16Hdr.OldVector

;------------------------------------------------------------------------------
;TEST AND SEE IF A PRE-EXISTING INT 16h PROGRAM SUPPORTS A SUBFUNCTION GROUP
;Inputs:  CS = TSR Data Area
;         AL = (High Nibble) = Extended Subfunction Group Code
;         CS:Int16Hdr.OldVector = Old Interrupt 16h Vector Address
;Outputs: CF = Clear if a previous program supports the SubFunction Group
;            = Set if Not
;Changes:
;------------------------------------------------------------------------------
TestOldInt16:
  CALL MakeStack               ;Set up our own Stack Space
  PUSH AX,BX,CX,DX             ;Save used registers
  PUSH DI,SI,BP,DS,ES          ;Save used registers
  AND  AL,0F0h                 ;Set Subfunction call to Install Check
  MOV  AH,1Bh                  ;AH = Extended Call
  MOV  BX,'KE'                 ;Set BX for Extended Call
  MOV  CX,'YB'                 ;Set CX for Extended Call
  MOV  DX,InstallCheckDX       ;Set DX for Install Check
  STC                          ;Preset Error Flag
  PUSHF                        ;Call the
  CALL D CS:Int16Hdr.OldVector ;  Old Vector
  JC  >X70                     ;If subfunction not supported, quit
  OR   AX,AX                   ;Is the Subfunction supported?
  JNZ >X70                     ;If not, quit
  CMP  BX,'YB'                 ;Is the Subfunction supported?
  JNE >X70                     ;If not, quit
  CMP  CX,'KE'                 ;Is the Subfunction supported?
  JNE >X70                     ;If not, quit
  CMP  DX,InstallCheckDX       ;Is the Subfunction Supported?
  JNE >X80                     ;If so, we're done
X70:                           ;Subfunction Group not supported
  STC                          ;Set not supported flag
  JMP >X90                     ;Done
X80:                           ;Subfunction Group not supported
  CLC                          ;Set supported flag
X90:                           ;Done
  POP  ES,DS,BP,SI,DI          ;Restore used registers
  POP  DX,CX,BX,AX             ;Restore used registers
  CALL ReturnStack             ;Restore original Stack Space
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE FOR INT 16H EXTENDED FUNCTIONS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HANDLE INT 16h EXTENDED FUNCTIONS
;Inputs:  CS = TSR Data Area
;         SS:[BP+6] = Return Flags for IRET
;Outputs: Processes INT 16h Extended functions
;         Sets return CF if appropriate
;         AX,BX,CX,DX
;Changes:
;NOTES: If the called function includes "typing" any ScanCodes (either directly
;         or indirectly), we will put the appropriate ScanCodes in the Buffer
;         but will not actually type them.
;       We do this because the INT 16h function can be called from inside
;         INT 08, and if we are using Method 1, we cannot "type" the ScanCodes
;         from inside an INT 08.  We can never know for certain whether we
;         are being called from inside an INT 08, so we will just play
;         it safe and not do any "typing" from here.
;------------------------------------------------------------------------------
DoInt16Ext:
  PUSH DI,SI,DS,ES                 ;Save used registers
  MOV  DS,CS                       ;Point DS and
  MOV  ES,CS                       ;  ES at local data
  CALL MakeStack                   ;Create our own stack space
  CMP  BX,'KE'                     ;BX correct for call?
  JNE >X75                         ;If not, error
  CMP  CX,'YB'                     ;CX correct for call?
  JNE >X75                         ;If not, error
  MOV  DI,I16ErrBadFunction        ;Assume bad function number
  MOV  BX,Int16FunctionTbl         ;Point at Code Offset table
  CALL SearchByte2WordTblES        ;Is the sub-function in AL OK (returns BX)?
  JC  >X70                         ;If not, Error
  MOV  SI,ExternalTable            ;Point SI at the External Table
  CALL BX                          ;Call the Function
  JC  >X70                         ;If error, quit
  CALL ProcessKeyCodes             ;Fill Buffer with appropriate KeyCodes
  JMP >X80                         ;Done
X70:                               ;Error
  MOV  AX,DI                       ;Set Error Code
  MOV  BX,'KE'                     ;Restore original BX
  MOV  CX,'YB'                     ;Restore original CX
X75:                               ;Error (no need to restore original values)
  CALL ReturnStack                 ;Restore original stack space
  OR   B SS:[BP+6],CarryFlag       ;Set Error Flag for return
  JMP >X90                         ;Done
X80:                               ;OK
  XOR  AX,AX                       ;Set No Error Code
  MOV  BX,'YB'                     ;Set BX Return value
  MOV  CX,'KE'                     ;Set CX Return value
  CALL ReturnStack                 ;Restore original stack space
  AND  B SS:[BP+6],(NOT CarryFlag) ;Set OK flag for return
X90:                               ;Done
  POP  ES,DS,SI,DI                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE INT 16h EXTENDED INSTALL FUNCTIONS
;Inputs:  DS = ES = TSR Data Area
;         AX, BX, CX values already checked for validity
;Outputs: CF = Clear if OK
;              DX = API version (0.05)
;            = Set if Error
;              DI = Appropriate Error Code to put in AX
;Changes:
;------------------------------------------------------------------------------
DoScanCodeInstall:
DoUSBCodeInstall:
DoSysCodeInstall:
  MOV  DI,I16ErrBadCode  ;Error = Bad Value in DX
  CMP  DX,InstallCheckDX ;Correct Install Check value?
  JNE >I70               ;If not, error
  MOV  DX,Int16APIVer    ;Set DX to return value
  CLC                    ;Set OK flag
  JMP >I90               ;Done
I70:                     ;Error
  STC                    ;Set Error Flag
I90:                     ;Done
  RET

;------------------------------------------------------------------------------
;HANDLE INT 16h EXTENDED PRESS/RELEASE KEY FUNCTIONS
;Inputs:  DS = ES = TSR Data Area
;         [SI] = External Table (keeps track of Keys)
;          DL  = Code sent by User (USB Code, System Code, or Scan Code)
;Outputs: CF = Clear if OK (Function worked)
;              DI = undefined
;            = Set of Error
;              DI = Error Code
;Changes:
;------------------------------------------------------------------------------
DoUSBCodeRePress:                           ;Press or Re-Press (Internal Call)
  PUSH BX                                   ;Save used registers
  MOV  BL,CodeFlagUSBCode+CodeFlagRePress   ;BL = Flags
  JMP >E00                                  ;Do it

DoScanCodePress:
  PUSH BX                                   ;Save used registers
  MOV  BL,CodeFlagScanCode+CodeFlagPress    ;BL = Flags
  JMP >E00                                  ;Do it
DoScanCodeRelease:
  PUSH BX                                   ;Save used registers
  MOV  BL,CodeFlagScanCode+CodeFlagRelease  ;BL = Flags
  JMP >E00                                  ;Do it
DoScanCodePressRls:
  PUSH BX                                   ;Save used registers
  MOV  BL,CodeFlagScanCode+CodeFlagPressRls ;BL = Flags
  JMP >E00                                  ;Do it

DoUSBCodePress:
  PUSH BX                                   ;Save used registers
  MOV  BL,CodeFlagUSBCode+CodeFlagPress     ;BL = Flags
  JMP >E00                                  ;Do it
DoUSBCodeRelease:
  PUSH BX                                   ;Save used registers
  MOV  BL,CodeFlagUSBCode+CodeFlagRelease   ;BL = Flags
  JMP >E00                                  ;Do it
DoUSBCodePressRls:
  PUSH BX                                   ;Save used registers
  MOV  BL,CodeFlagUSBCode+CodeFlagPressRls  ;BL = Flags
  JMP >E00                                  ;Do it

DoSysCodePress:
  PUSH BX                                   ;Save used registers
  MOV  BL,CodeFlagSysCode+CodeFlagPress     ;BL = Flags
  JMP >E00                                  ;Do it
DoSysCodeRelease:
  PUSH BX                                   ;Save used registers
  MOV  BL,CodeFlagSysCode+CodeFlagRelease   ;BL = Flags
  JMP >E00                                  ;Do it
DoSysCodePressRls:
  PUSH BX                                   ;Save used registers
  MOV  BL,CodeFlagSysCode+CodeFlagPressRls  ;BL = Flags
;  JMP >E00                                  ;Do it

E00:
  PUSH SI                                ;Save used registers
  MOV  DI,I16ErrBadCode                  ;Assume Bad Code Error
  CALL TestExtCode                       ;Test for valid Codes
  JC  >E70                               ;If invalid, Error
  CALL FindUSBKeyEntry                   ;Look for a matching entry in the Table
  JNC >E60                               ;If found, handle it
  MOV  DI,I16ErrBufferFull               ;Assume Buffer Full Error
  OR   SI,SI                             ;Is the Key Code Buffer Full?
  JZ  >E70                               ;If so, quit
  CMP  BufferCount,BufferSize            ;Is the ScanCode Buffer Full?
  JE  >E70                               ;If so, quit
E10:                                     ;Code is not in the Table yet
  MOV  DI,I16ErrRlsNoPress               ;Assume Release with no Press
  TEST BL,CodeFlagRelease                ;Is this a Release?
  JNZ >E70                               ;If so, Error
  OR   [SI].UKFlags,(UKFlagNewPress+UKFlagPressed) ;Mark as New & Pressed
  MOV  BH,DelayFactor                    ;Initialize the
  MOV  [SI].UKTimer,BH                   ;  Countdown Timer
  TEST BL,CodeFlagPressRls               ;Does it need an immediate Release?
  JZ  >E20                               ;If not, continue
  OR   [SI].UKFlags,UKFlagRelease        ;If so, mark it for immediate Release
  MOV  [SI].UKTimer,0                    ;No need for Countdown Timer
E20:                                     ;Done with Press/Release Flags
  TEST BL,CodeFlagSysCode                ;Is it a System Code?
  JZ  >E25                               ;If not, try the next possibility
  OR   [SI].UKFlags,UKFlagSysCode        ;If so, mark it as a System Code
  JMP >E30                               ;Continue
E25:                                     ;Not a System Key
  TEST BL,CodeFlagScanCode               ;Is it a Scan Code?
  JZ  >E30                               ;If not, try the next possibility
  OR   [SI].UKFlags,UKFlagScanCode       ;If so, mark it as a Scan Code
E30:                                     ;Done with flags for new Table Entry
  MOV  [SI].UKKeyCode,DL                 ;Store the Code
  JMP >E80                               ;Done

E60:                                     ;Code is already in the Table
  TEST BL,CodeFlagRePress                ;Is it a RePress?
  JZ  >E65                               ;If not, continue
  OR   [SI].UKFlags,UKFlagPressed        ;Mark as Pressed
  AND  [SI].UKFlags,(NOT UKFlagNewPress) ;Mark as not a New Press
  JMP >E80                               ;Done
E65:                                     ;Already in Table, not a RePress
  MOV  DI,I16ErrDblPress                 ;Assume Double Press Error
  TEST BL,CodeFlagRelease                ;Is this a Press or Press/Release?
  JZ  >E70                               ;If so, Error
  AND  [SI].UKFlags,(NOT (UKFlagPressed+UKFlagNewPress)) ;If Release, mark as not Pressed
  JMP >E80                               ;Done
E70:                                     ;Error
  STC                                    ;Set error flag
  JMP >E90                               ;Done
E80:                                     ;OK
  CLC                                    ;Set OK flag
E90:                                     ;Done
  POP  SI                                ;Restore used registers
  POP  BX                                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST A USB OR SYSTEM KEY CODE FOR VALIDITY
;Inputs:  DX = Code to test
;         BL = Code Flags
;Outputs: CF = Clear if Code is Valid
;            = Set if Invalid
;Changes:
;------------------------------------------------------------------------------
TestExtCode:
  OR   DH,DH                ;Is DH 0?
  JNZ >O70                  ;If not, error
  TEST BL,CodeFlagSysCode   ;Is it a System Code?
  JNZ >O30                  ;If so, handle it
  TEST BL,CodeFlagScanCode  ;Is it a Scan Code?
  JZ  >O20                  ;If not, it's a USB Code
O10:                        ;ScanCode
  CMP  DL,225               ;Is it the Pause Key?
  JE  >O80                  ;If so, it's OK
  CMP  DL,224               ;Is it 224?
  JE  >O70                  ;If so, Error
  CMP  DL,224-80h           ;Is it illegal?
  JE  >O70                  ;If so, Error
  CMP  DL,225-80h           ;Is it illegal?
  JE  >O70                  ;If so, Error
  OR   DL,DL                ;Is it 0?
  JZ  >O70                  ;If so, Error
  CMP  DL,128               ;Is it 128?
  JE  >O70                  ;If so, Error
  JMP >O80                  ;If Ok, were' done
O20:                        ;USB Code
  CMP  DL,RptKbdA           ;Valid Code?
  JAE >O80                  ;If so, it's OK
  JMP >O70                  ;If not, Error
O30:                        ;System Key
  CMP  DL,RptGDSysCtl       ;Valid Code?
;  CMP  DL,RptGDSysPowerDown ;Valid Code?
  JB  >O70                  ;If not, Error
  CMP  DL,RptGDSysMenuDown  ;Valid Code?
  JBE >O80                  ;If so, it's OK
O70:                        ;Invalid Code
  STC                       ;Set error flag
  JMP >O90                  ;Done
O80:                        ;Valid Code
  CLC                       ;Set OK flag
O90:                        ;Done
  RET

;------------------------------------------------------------------------------
;FIND A MATCHING OR EMPTY USBKeyStruc TABLE ENTRY
;Inputs:  DS = ES = TSR Data Area
;         [SI] = USBKeyStruc Table to look in
;          DL  = Code to look for
;          BL  = Code Flags
;Outputs: CF = Clear if Entry is found in the Table
;              [SI] = Entry
;            = Set if not found in Table
;              [SI] = Empty Table Entry to use
;                   = 0 if Table is full
;Changes:
;------------------------------------------------------------------------------
FindUSBKeyEntry:
  PUSH AX,CX,DI            ;Save used registers
  XOR  DI,DI               ;Start with Empty Table entry
  MOV  CX,NumUSBKeys       ;Number of table entries
F10:                       ;Loop to here for each table entry
  MOV  AL,[SI].UKKeyCode   ;Get the Code from the Table
  OR   AL,AL               ;Empty entry?
  JZ  >F40                 ;If so, it can't match
  CMP  AL,DL               ;Is it the right code value?
  JNE >F50                 ;If not, it's not the right one
  MOV  AL,[SI].UKFlags     ;Get the Flags
  TEST AL,UKFlagSysCode    ;Is existing entry a System Code?
  JNZ >F30                 ;If so, handle it
  TEST AL,UKFlagScanCode   ;Is existing entry a Scan Code?
  JNZ >F25                 ;If so, handle it
F20:                       ;Existing entry is USB Code
  TEST BL,(CodeFlagScanCode+CodeFlagSysCode) ;Is the new entry a USB Code?
  JZ  >F80                 ;If so, it's a match
  JMP >F50                 ;If not, keep looking
F25:                       ;Existing entry is Scan Code
  TEST BL,CodeFlagScanCode ;Is the new entry a Scan Code?
  JNZ >F80                 ;If so, it's a match
  JMP >F50                 ;If not, keep looking
F30:                       ;Existing entry is System Code
  TEST BL,CodeFlagSysCode  ;Is the new entry a System Code?
  JNZ >F80                 ;If so, it's a match
  JMP >F50                 ;If not, keep looking
F40:                       ;Empty Entry
  OR   DI,DI               ;Already found the first empty entry?
  JNZ >F50                 ;If so, we don't need another one
  MOV  DI,SI               ;If not, this is the first one
F50:                       ;Go to next entry
  ADD  SI,USBKeyStrucSize  ;Point at next entry
  LOOP F10                 ;Keep going until we're done
F70:                       ;Entry not found
  MOV  SI,DI               ;Point SI at the first Empty entry
  STC                      ;Set not found flag
  JMP >F90                 ;Done
F80:                       ;Entry found
  CLC                      ;Set found flag
F90:                       ;Done
  POP  DI,CX,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF THERE AT LEAST ONE USB KEYBOARD INSTALLED
;Inputs:  ES = TSR Data Area
;Outputs: CF = Clear if at least one USB Keyboard is installed
;            = Set if Not
;Changes:
;------------------------------------------------------------------------------
TestKeybFoundES:
  PUSH BX,CX                       ;Save used registers
  MOV  BX,DeviceInfoTable          ;Point at the Table
  MOV  CX,MaxDevices               ;Number of Table entries
F10:                               ;Loop to here for each table entry
  TEST ES:[BX].DIFlags,DIFlagInUse ;This entry used?
  JNZ >F80                         ;If so, we have at least one keyboard
  ADD  BX,DeviceInfoStrucSize      ;Point at next table entry
  LOOP F10                         ;Keep looking
F70:                               ;No keyboard found
  STC                              ;Set Error Flag
  JMP >F90                         ;Done
F80:                               ;At least one Keyboard found
  CLC                              ;Set OK flag
F90:                               ;Done
  POP  CX,BX                       ;Restore used registers
  RET

;We handle Functions 0 (Set Default Rates), 5 (Set Rates), and 6 (Get Rates)
;We could also handle Function 4 (Disable Typematic) pretty easily at a
;  functional level.  But, I have not found any documentation that states
;  what codes should be returned for Function 6 (Get Rates) when things
;  are Disabled.  We can't return 0, because 0 is a legitimate code and
;  very specifically does not mean "disabled."  In fact, it means almost
;  the exact opposite of "disabled."
;Returning -1 sort of makes sense logically, but I suspect that many programs
;  would "blow up" if you returned a -1 to them.  Also, if that's what
;  is returned for a get status, you should be able to use the same values
;  to set things, and -1 is definitely invalid as a value to set.
;So, because I don't know how to handle the return values correctly, I am
;  not supporting Function 4.  I have a hard time believing anyone would
;  actually WANT to totally disable Typematic functionality anyway, so this
;  shouldn't be a problem.
;------------------------------------------------------------------------------
;HANDLE A REQUEST TO GET/CHANGE TYPEMATIC RATES
;Inputs:  AH = 03h (Int 16h Function Number)
;         AL = SubFunction Number (0, 5, or 6)
;              If Subfunction 5 (Set Rates), BX contains Rates to set
;         DS and ES are NOT Set yet!
;Outputs: Depends of Function Number
;Changes:
;------------------------------------------------------------------------------
ChangeRates:
  PUSH DS                           ;Save used registers
  MOV  DS,CS                        ;Point DS at our data area
C10:                                ;Get Current Codes?
  CMP  AL,6                         ;Get Current Codes function?
  JNE >C20                          ;If not, try next possibility
  MOV  BX,W RepeatCode              ;BL = Repeat Code, BH = Delay Code
  JMP >C95                          ;Done
C20:                                ;Set Defaults Rates?
  OR   AL,AL                        ;Set Default Rate function?
  JNZ >C30                          ;If not, try next possibility
  MOV  DelayFactor,DefDelayFactor   ;Set
  MOV  RepeatFactor,DefRepeatFactor ;  Default Rates
  MOV  DelayCode,DefDelayCode       ;Set
  MOV  RepeatCode,DefRepeatCode     ;  Default Codes
  JMP >C95                          ;Done
C30:                                ;Set New Rates?
  CMP  AL,5                         ;Set Rates Function?
  JNE >C95                          ;If not, just quit
  CALL CalcAndSetRates              ;If so, handle it
C95:                                ;Done
  POP  DS                           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE AND SET NEW KEYBOARD TYPEMATIC RATES FROM USER CODES
;Inputs:  DS = TSR Data Area
;         BL = Repeat Rate Code (0-31)
;         BH = Delay Code (0-3)
;Outputs:
;Changes: Keyboard Typematic Rates
;NOTES: Formula for cps is: 240/((8+Y)*(2^Z))
;         Where Z is bits 3 & 4 of Repeat Code, and
;         Y is bits 0-2 of Repeat Code
;------------------------------------------------------------------------------
CalcAndSetRates:
  PUSH AX,BX,CX,DX     ;Save used registers
  CMP  BL,31           ;Is it a valid Repeat code?
  JA  >S90             ;If not, just quit
  CMP  BH,3            ;Is it a valid Delay code?
  JA  >S90             ;If not, just quit
  MOV  W RepeatCode,BX ;Store Codes
S10:                   ;Handle Delay
  MOV  AL,25           ;Calculate
  INC  BH              ;  and
  MUL  BH              ;  store
  MOV  DelayFactor,AL  ;  Delay Factor
S20:                   ;Handle Repeat
  MOV  CH,BL           ;Calculate Divisor
  MOV  CL,3            ;  for a
  SHR  CH,CL           ;  240
  MOV  CL,CH           ;  Hertz
  MOV  AL,1            ;  Clock
  SHL  AL,CL           ;  (normal
  AND  BL,07h          ;  keyboard
  ADD  BL,8            ;  clock
  MUL  BL              ;  rate)
S30:                   ;Above is Divisor for 240Hz Clock, we're at 100Hz!
  XOR  DX,DX           ;Divide by 2.4
  MOV  CX,10           ;  to convert
  MUL  CX              ;  from 240Hz Clock
  MOV  CX,24           ;  to
  DIV  CX              ;  100Hz Clock
  CMP  DL,12           ;Need to round up?
  JB  >S50             ;If not, just store it
  INC  AL              ;If so, round it up
S50:                   ;AL contains Repeat Factor
  MOV  RepeatFactor,AL ;Store the Repeat Factor
S90:                   ;Done
  POP  DX,CX,BX,AX     ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;Code to Setup & Process the User (External) Interrupt
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;SET UP A USER TABLE INTERRUPT IF IT IS NOT ALREADY SET UP
;Inputs:  DS = ES = TSR Data Area
;Outputs: Makes sure we have a User Table Interrupt set up
;Changes:
;------------------------------------------------------------------------------
SetupUserInt:
  PUSH AX,CX,SI                  ;Save used registers
  CMP  UserTblHost,-1            ;Need to set up a new Interrupt?
  JNE >I90                       ;If not, we're done
  MOV  SI,Int14Request2          ;Point at Request Structure
  MOV  [SI].I14RRequestType,I14RRTDoInterruptPer ;Request = Periodic Interrupt
  MOV  [SI].I14RFlags,I14RFlagIn ;Direction = In
  MOV  [SI].I14RDeviceAddress,1  ;Address 1 (Root Hub)
  MOV  [SI].I14REndPoint,0       ;EndPoint 0
  MOV  [SI].I14RDataSize,0       ;Transfer 0 bytes (Data Address doesn't matter)
  MOV  [SI].I14RPeriodicity,10   ;Periodicity = 10ms
  MOV  W [SI].I14RCallBackAddr[0],UserTblIntCode ;Code to call when Int happens
  MOV  [SI].I14RUserPktID,0      ;Packet ID 0
  MOV  AL,15                     ;Start with Host Index 15
I10:                             ;Loop to here to find good Host
  MOV  [SI].I14RHostIndex,AL     ;Put the Host Index in the Request
  CALL DoInt14CallCXSI           ;Do it
  JNC >I80                       ;If it worked, we're done
  SUB  AL,1                      ;If not, go to the next Host Index
  JNC  I10                       ;If we haven't tested all Hosts, keep going
  JMP >I90                       ;If no Hoss available, we're done
I80:                             ;Interrupt is set up
  MOV  UserTblHost,AL            ;Store Host Index
  MOV  UserTblHandle,CX          ;Store Handle Number
I90:                             ;Done
  POP  SI,CX,AX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS THE USER TABLE INTERRUPT
;Inputs:  DS = ES = TSR Data Area
;         BX = 0 (User Packet ID)
;Outputs: Updates User Table Typematic Counters, Typing ScanCodes as needed
;Changes: Several CPU Registers
;------------------------------------------------------------------------------
UserTblIntCode:
  MOV  SI,ExternalTable ;Point at External Key Table
  CALL ProcessKeyCodes  ;Update Delay/Repeat Timers
  RETF


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO HANDLE INT 09h (Keyboard)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;HAVE INTERRUPT 09 (KEYBOARD PRESS/RELEASE) RUN THIS EVERY TIME IT OCCURS
;Inputs:
;Outputs: Manually processes a Ctl-Alt-Del keyboard press, if appropriate
;Changes:
;------------------------------------------------------------------------------
Int09Hdr:
  DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code

Int09:
  PUSHF               ;Save flags
  STI                 ;Enable interrupts
  CLD                 ;Go forward with string functions
  PUSH AX,DS          ;Save used registers
  MOV  DS,CS          ;Point DS at local data rea
  IN   AL,60h         ;If so, get the keystroke
  MOV  AH,4Fh         ;Translate
  STC                 ;  the
  INT  15h            ;  keystroke
  JNC  Int09Old       ;If we're supposed to ignore it, quit
  CALL HandleReboot   ;Reboot, if appropriate (returns if we don't Reboot)
  CALL HandlePauseKey ;Process Pause Key
  JNC >N95            ;If handled, we're done
  CALL HandleLockKeys ;Process Lock Keys (Caps/Num/Scroll)
  JC   Int09Old       ;If not handled, no more special keys to look for
N90:                  ;Keystroke Handled, if appropriate
  MOV  AL,OCW2SelectOCW2+OCW2NonSpecificEOI ;Non-specific EOI
  OUT  PIC1Addr,AL    ;Send to PIC 1
N95:                  ;Keystrokes handled, EOI already issued
  POP  DS,AX          ;Restore used registers
  POPF                ;Restore flags
  IRET

Int09Old:
  POP  DS,AX                   ;Restore used registers
  POPF                         ;Restore flags
  JMP  D CS:Int09Hdr.OldVector ;Let the old Interrupt Handler do it

;-----------------------------------------------------------------------------
;TEST FOR A CTRL-ALT-DEL KEYSTROKE< AND REBOOT THE COMPUTER IF NEEDED
;Inputs:  DS = TSR Data Area
;         AL = ScanCode from Keyboard
;         TSRFlags.NoHandleReboot
;Outputs:
;Changes: Flushes disk buffers and reboots the computer
;NOTES: Since this reboots the computer (or at least attempts to
;         reboot the computer), we don't worry about cleaning anything up
;         (like the stack or the registers).  If our reboot doesn't work
;         for some reason things will be so screwed up anyway that the user
;         will need to do a hard reboot (with the computer's power button).
;       This code is based on information from Microsoft's web site,
;         so should be OK: http://support.microsoft.com/kb/q67929/
;-----------------------------------------------------------------------------
HandleReboot:
  PUSH AX,DS                   ;Save used registers
  TEST TSRFlags,NoHandleReboot ;Are we supposed to do anything?
  JNZ >R90                     ;If not, we're done
  CMP  AL,ScanCodeDelete       ;Is it the Delete Key?
  JNE >R90                     ;If not, we're done
  MOV  AX,40h                  ;If so, point DS at
  MOV  DS,AX                   ;  the BIOS Data Area
  MOV  AL,[17h]                ;Get the current Shift Mask
  AND  AL,BIOS17ShiftKeysMask  ;Mask out Lock Keys, Keep Shift Keys
  CMP  AL,BIOS17EitherCtlP+BIOS17EitherAltP ;Are Control & Alt pressed?
  JNE >R90                     ;If not, quit
  MOV  AH,0Dh                  ;Function 0Dh (flush DOS & SmartDrv Disk Buffers)
  INT  21h                     ;Do it (does not update directory info!)
  MOV  W [72h],1234h           ;Mark memory for a Warm Boot
  JMP  0FFFFh:0000             ;Reboot!

R90:                           ;Done
  POP  DS,AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS THE LOCK KEYS ON THE KEYBOARD (SCROLL, NUM, CAPS)
;Inputs:  AL = Scan Code from Keyboard
;         DS = TSR Data Area
;         TSRFlags.NoHandleLocks
;Outputs: CF = Clear if it was a Lock Key (we processed it)
;              Modifies appropriate values in the BIOS Data Area
;            = Set if not a Lock Key (we didn't do anything)
;Changes:
;NOTE: We do this because, for some reason, with Methods 2 & 3
;        the Lock Keys sometimes disable the "real" keyboard even
;        though the USB keyboards still keep working.;  I have no
;        idea why this is the case.
;      In this code, we only update the Lock Key Pressed and Active
;        Statuses (at 0040:0017h & 0018h), but do NOT update the
;        LED Status (0040:0097h), or the LEDs themselves.  We let
;        the original keyboard BIOS do that for us, which it
;        faithfully does after we update the Active Status.
;------------------------------------------------------------------------------
HandleLockKeys:
  PUSH AX,BX,CX,DS            ;Save used registers
  PUSHF                       ;Save flags
  TEST TSRFlags,NoHandleLocks ;Are we supposed to do anything?
  JNZ >L70                    ;If not, we're done
  MOV  BX,40h                 ;Point DS at the
  MOV  DS,BX                  ;  BIOS Data Area
  MOV  BL,18h                 ;Point DS:[BX] at Keyboard Status Byte 1
  TEST B [BX+96h-18h],(BIOS96E1LastTime+BIOS96E0LastTime+BIOS961of2LastTime)
                              ;Is this part of a multiple-scancode-keystroke?
  JNZ >L70                    ;If so, skip it
  XOR  CL,CL                  ;Assume Key Press
  TEST AL,80h                 ;Is it a Press?
  JZ  >L10                    ;If so, continue
  AND  AL,(NOT 80h)           ;If not, get rid of the Release bit
  DEC  CL                     ;Mark as a Release
L10:                          ;Press/Release Flag handled
  MOV  AH,BIOS17ScrLockA      ;Assume Scroll Lock
  CMP  AL,ScanCodeScrollLock  ;Is it Scroll Lock?
  JE  >L20                    ;If so, continue
  SHL  AH,1                   ;Assume Num Lock
  CMP  AL,ScanCodeNumLock     ;Is it Num Lock?
  JE  >L20                    ;If so, continue
  SHL  AH,1                   ;Assume Caps Lock
  CMP  AL,ScanCodeCapsLock    ;Is it Caps Lock?
  JNE >L70                    ;If not, it's not for us
L20:                          ;Is one of the Lock Keys (AH = BIOS Mask)
  CLI                         ;Disable interrupts
  OR   CL,CL                  ;Is it a Press or a Release?
  JNZ >L50                    ;If a Release, handle it
  TEST [BX],AH                ;Is it a Repeated Press?
  JNZ >L80                    ;If so, we're done
L30:                          ;First-time Press
  OR   [BX],AH                ;Mark it as Pressed
  XOR  [BX+17h-18h],AH        ;Toggle Active Status
  JMP >L80                    ;Done
L50:                          ;Key was released
  NOT  AH                     ;Mark the Lock Key
  AND  [BX],AH                ;  as Released
  JMP >L80                    ;Done
L70:                          ;We did not process the keystroke
  POPF                        ;Restore flags
  STC                         ;Set return flag
  JMP >L90                    ;Done
L80:                          ;We processed the keystroke
  AND  B [BX+96h-18h],NOT (BIOS96E1LastTime+BIOS96E0LastTime+BIOS961of2LastTime)
                              ;Clear all multiple-scancode-keystroke flags
  POPF                        ;Restore flags
  CLC                         ;Set return flag
L90:                          ;Done
  POP  DS,CX,BX,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PROCESS THE PAUSE KEY ON THE KEYBOARD
;Inputs:  AL = Scan Code from Keyboard
;         DS = TSR Data Area
;         TSRFlags.NoHandlePause
;Outputs: CF = Clear if it was a the Pause Key (we processed it)
;            = Set if not the Pause Key (we didn't do anything)
;Changes:
;------------------------------------------------------------------------------
HandlePauseKey:
  PUSH AX,BX,DS                          ;Save used registers
  PUSHF                                  ;Save flags
  TEST TSRFlags,NoHandlePause            ;Are we supposed to do anything?
  JNZ >P70                               ;If not, we're done
  MOV  BX,40h                            ;Point DS at the
  MOV  DS,BX                             ;  BIOS Data Area
  MOV  BL,96h                            ;Point DS:[BX] at Kbd Status Byte 3
P10:                                     ;Test for 225
  CMP  AL,225                            ;Is it a double-extended key prefix?
  JNE >P15                               ;If not, continue
  OR   B [BX],BIOS96E1LastTime           ;If so, mark as 225 Press
  AND  B [BX],(NOT (BIOS96E0LastTime+BIOS961of2LastTime)) ;Clear out old stuff
  JMP >P80                               ;Done
P15:                                     ;ScanCode not 225
  TEST B [BX],BIOS96E1LastTime           ;Is it the second Pause ScanCode?
  JZ  >P20                               ;If not, continue
  OR   B [BX],BIOS961of2LastTime         ;If so, mark as second Pause ScanCode
  AND  B [BX],(NOT BIOS96E1LastTime)     ;Clear out old stuff
  JMP >P80                               ;Done
P20:                                     ;Not first two Pause ScanCodes
  TEST B [BX-96h+18h],BIOS18PauseA       ;Is Pause currently Active?
  JZ  >P50                               ;If not, jump to handle it

P30:                                     ;Pause currently Active
  CMP  AL,224                            ;Is it an extended key prefix?
  JNE >P35                               ;If not, continue
  OR   B [BX],BIOS96E0LastTime           ;If so, mark as a 224 Press
  JMP >P80                               ;Done
P35:                                     ;Not 224
  AND  AH,(NOT BIOS96E0LastTime+BIOS96E1LastTime+BIOS961of2LastTime)
                                         ;Mark all prefixes as handled
  TEST AL,80h                            ;Keystroke Release?
  JZ  >P80                               ;If not, we're done
  AND  B [BX-96h+18h],(NOT BIOS18PauseA) ;If so, Mark our Pause as completed
  JMP >P80                               ;Done

P50:                                     ;Pause NOT currently Active
  TEST B [BX],BIOS961of2LastTime         ;Is this the possible third Pause Code?
  JZ  >P70                               ;If not, we're done
  AND  B [BX],(NOT BIOS961of2LastTime)   ;Mark as done with Pause press
  CMP  AL,(ScanCodeNumLock+80h)          ;Is it the Pause Release ScanCode?
  JNE >P80                               ;If not, it's the Press - we're done
  OR   B [BX-96h+18h],BIOS18PauseA       ;Mark Pause as currently Active
  MOV  AL,OCW2SelectOCW2+OCW2NonSpecificEOI ;Non-specific EOI
  OUT  PIC1Addr,AL                       ;Send to PIC 1
P60:                                     ;Loop to here while Pausing
  TEST B [BX-96h+18h],BIOS18PauseA       ;Pause still Active?
  JNZ  P60                               ;If so, keep waiting
  JMP >P85                               ;If not, we're done
P70:                                     ;We did not process the keystroke
  POPF                                   ;Restore flags
  STC                                    ;Set return flag
  JMP >P90                               ;Done
P80:                                     ;We processed the keystroke
  MOV  AL,OCW2SelectOCW2+OCW2NonSpecificEOI ;Non-specific EOI
  OUT  PIC1Addr,AL                       ;Send to PIC 1
P85:                                     ;Done
  POPF                                   ;Restore flags
  CLC                                    ;Set return flag
P90:                                     ;Done
  POP  DS,BX,AX                          ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE NEEDED TO FIND THINGS IN VARIOUS LOOKUP TABLES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;SEARCH A BYTE LOOKUP TABLE FOR A MATCHING ENTRY
;Inputs:  AL = Byte to search for
;         DS:[BX] = Table to search OR
;         DS:[SI] = Table to search
;         CLD already issued
;Outputs: CF = Clear if OK (Byte is in the Table)
;            = Set if error (Byte is not in the Table)
;Changes:
;NOTES: The last entry in the table must be a 0
;------------------------------------------------------------------------------
SearchByteTblBX:
  PUSH SI              ;Save used registers
  MOV  SI,BX           ;Point SI at the Table
  CALL SearchByteTblSI ;Do the search
  POP  SI              ;Restore used registers
  RET

SearchByteTblSI:
  PUSH AX,SI   ;Save used registers
  MOV  AH,AL   ;Put Byte we're searching for in AH
Y10:           ;Loop to here for each table entry
  LODSB        ;Get the Byte from the Table
  OR   AL,AL   ;End of the Table?
  JZ  >Y70     ;If so, it's not in the Table
  CMP  AL,AH   ;Is it a match?
  JNE  Y10     ;If not, keep looking
  JMP >Y80     ;If so, we're done
Y70:           ;No Match
  STC          ;Set no match flag
  JMP >Y90     ;Done
Y80:           ;Found a match
  CLC          ;Set OK flag
Y90:           ;Done
  POP  SI,AX   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEARCH A BYTE-TO-BYTE LOOKUP TABLE FOR A MATCHING ENTRY
;Inputs:  AL = Byte to search for
;         DS:[BX] = Table to search
;         CLD already issued
;Outputs: CF = Clear if OK
;              AL = Byte from Table
;            = Set if error (not in Table)
;              AL = Unchanged
;Changes:
;NOTES: The last entry in the table must be a 0 in the first column
;------------------------------------------------------------------------------
SearchByte2ByteTbl:
  PUSH BX,SI ;Save used registers
  MOV  SI,BX ;Put Table Pointer in SI
  MOV  BX,AX ;Save original AH and Byte we're looking for
S10:         ;Loop to here for each table entry
  LODSW      ;Get the next entry from the table
  OR   AL,AL ;End of Table?
  JZ  >S70   ;If so, we're done
  CMP  AL,BL ;Is it a match?
  JNE  S10   ;If not, keep looking
  JMP >S80   ;If so, we're done
S70:         ;No Match
  STC        ;Set no match flag
  MOV  AL,BL ;Restore original AL
  JMP >S90   ;Done
S80:         ;Found a match
  CLC        ;Set OK flag
  MOV  AL,AH ;Put value in AL for the return
S90:         ;Done
  MOV  AH,BH ;Restore original AH
  POP  SI,BX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEARCH A BYTE-TO-WORD LOOKUP TABLE FOR A MATCHING ENTRY
;Inputs:  ES:[BX] = Table to search OR
;         CS:[BX] = Table to Search
;         AL      = Byte to search for
;         CLD already issued
;Outputs: CF = Clear if a byte match as found in table
;              BX = Word from Table
;            = Set if no match found in table
;              BX = unchanged
;Changes:
;NOTES: Last Entry in Table (end-of-table marker) = DB -1, DW -1
;------------------------------------------------------------------------------
SearchByte2WordTblCS:
  PUSH ES                   ;Save used registers
  MOV  ES,CS                ;Point ES at correct data area
  CALL SearchByte2WordTblES ;Search the Table
  POP  ES                   ;Restore used registers
  RET

SearchByte2WordTblES:
  PUSH AX,SI,DS  ;Save used registers
  CLD            ;Go forward with string functions
  MOV  DS,ES     ;Point DS at correct data area
  MOV  SI,BX     ;Put pointer in SI
  MOV  AH,AL     ;Put byte to check in AH
B10:             ;Loop to here for each table entry
  LODSB          ;Get the next table entry
  CMP  AL,-1     ;Is it possibly the end of the table?
  JNE >B20       ;If not, continue
  CMP  W [SI],-1 ;Is it actually the end of the table?
  JE  >B70       ;If so, there's no match
B20:             ;Not end of table
  CMP  AL,AH     ;Is it a match?
  JE  >B80       ;If so, handle it!
  INC  SI,2      ;If not, skip over this table entry
  JMP  B10       ;And keep looking
B70:             ;No entry found
  STC            ;Set the not found flag
  JMP >B90       ;Quit
B80:             ;Entry found [SI]
  MOV  BX,[SI]   ;Point BX at the table entry
  CLC            ;Set the found flag
B90:             ;Done
  POP  DS,SI,AX  ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;STACK-RELATED FUNCTIONS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;CREATE/DELETE OUR OWN STACK
;Inputs:  CS = TSR Data Area
;         StackInUse
;Outputs: Interrupts Enabled
;Changes: SS,SP to/from our stack
;------------------------------------------------------------------------------
MakeStack:
  CLI                  ;Disable interrupts
  PUSHF                ;Save
  POP  CS:TempFlags    ;  Flags
  INC  CS:StackInUse   ;Increment number-of-calls counter
  CMP  CS:StackInUse,1 ;Is this the first call?
  JNE >M90             ;If not, the stack is already in use
  MOV  CS:TempBX,BX    ;  BX in memory
  POP  BX              ;Save MakeStack's return address in BX
  MOV  CS:OldSS,SS     ;Save original SS
  MOV  CS:OldSP,SP     ;Save original SP
  MOV  SP,CS           ;Put our CS
  MOV  SS,SP           ;  into SS
  MOV  SP,LastTSRByte  ;SP = Top of Stack
  PUSH BX              ;Restore MakeStack's return address to stack
  MOV  BX,CS:TempBX    ;Restore BX from memory
M90:                   ;Done
  PUSH CS:TempFlags    ;Restore
  POPF                 ;  Flags
  STI                  ;Enable interrupts
  RET

ReturnStack:
  CLI                ;Disable interrupts
  PUSHF              ;Save
  POP  CS:TempFlags  ;  Flags
  DEC  CS:StackInUse ;Decrement number-of-calls counter
  JNZ >R90           ;If sack is still in use, quit
  MOV  CS:TempBX,BX  ;Save BX in memory
  POP  BX            ;Save MakeStack's return address in BX
  MOV  SS,CS:OldSS   ;Restore original SS
  MOV  SP,CS:OldSP   ;Restore original SP
  PUSH BX            ;Restore MakeStack's return address to stack
  MOV  BX,CS:TempBX  ;Restore BX from memory
R90:                 ;Done
  PUSH CS:TempFlags  ;Restore
  POPF               ;  Flags
  STI                ;Enable interrupts
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;DEBUGGING CODE - NOT NEEDED IN FINAL RELEASE OF PROGRAM!!!
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;  VideoStartRow    EQU 12
;  VideoEndRow      EQU 50
;  VideoStartColumn EQU 40
;
;  VideoOffsetFirst EQU ((80*2*(VideoStartRow-1))+((VideoStartColumn-1)*2))
;  VideoOffsetLast  EQU ((80*2)*VideoEndRow)
;
;  VideoOffset DW VideoOffsetFirst ;Video Offset to use this time
;;
;;WriteCL:
;;  PUSH AX,DI,ES
;;  PUSHF
;;  CLD
;;  CALL GetVideoOffset ;(ES:[DI])
;;  MOV  AL,CL
;;  CALL WriteALByte
;;  POPF
;;  POP  ES,DI,AX
;;  RET
;
;WriteAXBXCXDX:
;  PUSHF               ;Save Flags
;  PUSH AX,DI,ES       ;Save used registers
;  PUSH BP             ;Save used registers
;  MOV  BP,SP          ;SS:[BP+0] = BP
;                      ;SS:[BP+2] = ES
;                      ;SS:[BP+4] = DI
;                      ;SS:[BP+6] = AX
;  CALL GetVideoOffset ;Get video offset to use (ES:[DI])
;  CALL WriteAXWord    ;Write AX
;  MOV  AX,BX          ;Write
;  CALL WriteAXWord    ;  BX
;  MOV  AX,CX          ;Write
;  CALL WriteAXWord    ;  CX
;  MOV  AX,DX          ;Write
;  CALL WriteAXWord    ;  DX
;;  MOV  AX,SS:[BP+4]   ;Write
;;  CALL WriteAXWord    ;  DI
;;  MOV  AX,SI          ;Write
;;  CALL WriteAXWord    ;  SI
;;  MOV  AX,SS:[BP+0]   ;Write
;;  CALL WriteAXWord    ;  BP
;;  MOV  AX,DS          ;Write
;;  CALL WriteAXWord    ;  DS
;;  MOV  AX,SS:[BP+2]   ;Write
;;  CALL WriteAXWord    ;  ES
;  POP  BP             ;Restore used regsiters
;  POP  ES,DI,AX       ;Restore used registers
;  POPF                ;Restore flags
;  RET
;
;WriteAXWord:
;  PUSH AX,CX         ;Save used registers
;  MOV  CH,4          ;Need to write 4 characters
;  MOV  CL,4          ;Need to shift 4 bits at a time
;W30:                 ;Loop to here for each Nibble we write
;  ROL  AX,CL         ;Put bits to write in low nibble
;  CALL WriteNibbleC  ;Write the Nibble
;  XOR  B ES:[DI],77h ;Toggle the Color
;  INC  DI            ;Skip over the Attribute Byte
;  DEC  CH            ;Decrement the Loop Counter
;  JNZ  W30           ;If not 0 yet, keep writing
;  MOV  AL,' '        ;Write a
;  STOSB              ;  Space
;  XOR  B ES:[DI],77h ;Toggle the Color
;  INC  DI            ;Skip over the Attribute Byte
;  POP  CX,AX         ;Restore used registers
;  RET
;
;;WriteALByte:
;;  PUSH AX,CX         ;Save used registers
;;  MOV  CH,2          ;Need to write 4 characters
;;  MOV  CL,4          ;Need to shift 4 bits at a time
;;W30:                 ;Loop to here for each Nibble we write
;;  ROL  AL,CL         ;Put bits to write in low nibble
;;  CALL WriteNibbleC  ;Write the Nibble
;;  XOR  B ES:[DI],77h ;Toggle the Color
;;  INC  DI            ;Skip over the Attribute Byte
;;  DEC  CH            ;Decrement the Loop Counter
;;  JNZ  W30           ;If not 0 yet, keep writing
;;  MOV  AL,' '        ;Write a
;;  STOSB              ;  Space
;;  XOR  B ES:[DI],77h ;Toggle the Color
;;  INC  DI            ;Skip over the Attribute Byte
;;  POP  CX,AX         ;Restore used registers
;;  RET
;
;WriteEAX:
;  PUSH EAX,CX,DI,ES   ;Save used registers
;  PUSHF               ;Save Flags
;  CALL GetVideoOffset ;Get video offset to use (ES:DI)
;  MOV  CH,8           ;Need to write 4 characters
;  MOV  CL,4           ;Need to shift 4 bits at a time
;F20:                  ;Loop to here for each Nibble we write
;  ROL  EAX,CL         ;Put bits to write in low nibble
;  CALL WriteNibbleC   ;Write the Nibble
;  XOR  B ES:[DI],77h  ;Toggle the Color
;  INC  DI             ;Skip over the Attribute Byte
;  DEC  CH             ;Decrement the Loop Counter
;  JNZ  F20            ;If not 0 yet, keep writing
;  POPF                ;Restore flags
;  POP  ES,DI,CX,EAX   ;Restore used registers
;  RET
;
;WriteAX:
;  PUSH AX,CX,DI,ES    ;Save used registers
;  PUSHF               ;Save Flags
;  CALL GetVideoOffset ;Get video offset to use (ES:DI)
;  MOV  CH,4           ;Need to write 4 characters
;  MOV  CL,4           ;Need to shift 4 bits at a time
;F20:                  ;Loop to here for each Nibble we write
;  ROL  AX,CL          ;Put bits to write in low nibble
;  CALL WriteNibbleC   ;Write the Nibble
;  XOR  B ES:[DI],77h  ;Toggle the Color
;  INC  DI             ;Skip over the Attribute Byte
;  DEC  CH             ;Decrement the Loop Counter
;  JNZ  F20            ;If not 0 yet, keep writing
;  POPF                ;Restore flags
;  POP  ES,DI,CX,AX    ;Restore used registers
;  RET
;
;WriteNibbleC:
;  PUSH AX             ;Save used register
;  AND  AL,0Fh         ;Get rid of the high nibble
;  ADD  AL,'0'         ;Convert it to a number
;  CMP  AL,'9'         ;Should it be a number?
;  JBE >N90            ;If so, we're done
;  ADD  AL,('A'-'9'-1) ;If not, convert it to a letter
;N90:                  ;We're done
;  STOSB               ;Write it to the string
;  POP  AX             ;Restore used register
;  RET                 ;We're done
;
;;Outputs:  ES = 0B800h (Video Segment)
;;          [DI] = Video Offset to use
;GetVideoOffset:
;  MOV  DI,0B800h                       ;Point ES at
;  MOV  ES,DI                           ;  Video Memory
;  MOV  DI,CS:VideoOffset               ;Point at Video Offset we want to change
;  ADD  CS:VideoOffset,160              ;Go to next row for next time
;  CMP  CS:VideoOffset,VideoOffsetLast  ;Gone too far yet?
;  JB  >V90                             ;If not, we're done
;  MOV  CS:VideoOffset,VideoOffsetFirst ;If so, reset it to the top
;V90:                                   ;Video Offset updated for next time
;  RET
;
;  TRow EQU 49 ;Row to Toggle Color in (1-based)
;  TCol EQU 80 ;Column to Toggle Color in (1-based)
;
;ToggleColor:
;  PUSH BX,DS        ;Save used registers
;  PUSHF             ;Save Flags
;  MOV  BX,0B800h    ;Point DS at
;  MOV  DS,BX        ;  video memory
;  MOV  BX,((TRow-1)*160)+((TCol-1)*2)
;  INC  B [BX]       ;Change the character
;  XOR  B [BX+1],77h ;Toggle the Color
;  POPF              ;Restore flags
;  POP  DS,BX        ;Restore used registers
;  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SPACE FOR OUR TSR STACK
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

  EVEN 16
  DB (StackSize/8) DUP ('TSRStack')


LastTSRByte:


;€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€
;€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€


;ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
;DATA NEEDED TO INSTALL/UPDATE/SHOW STATUS (NOT NEEDED DIRECTLY IN TSR)
;‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹

;==============================================================================
;TSR Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Table of Interrupt Numbers that the TSR Intercepts
  ;First byte of each entry is the Interrupt Number
  ;Second word is the Pointer to our Interrupt Handler Code Header
  ;----------------------------------------------------------------------------
  IntNumTable:
    DB 70h       ;Real-time Clock
     DW Int70Hdr
    DB 2Fh       ;TSR Multiplex
     DW Int2FHdr
    DB 16h       ;BIOS Keyboard Services
     DW Int16Hdr
    DB 09h       ;Keyboard
     DW Int09Hdr
    DB 08h       ;Timer Tick
     DW Int08Hdr
    DB 0         ;End of Table

  ;----------------------------------------------------------------------------
  ;Data needed to install as a TSR, Hooking into the Multiplex Int
  ;----------------------------------------------------------------------------
  FirstHandle DB 0 ;First available user handle for Int 2Fh


;==============================================================================
;Miscellaneous
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Miscellaneous Yes/No flags (individual bits)
  ;----------------------------------------------------------------------------
  ProgFlags        DB 00h ;Yes/No Test bits #1
    Uninstall     EQU 01h ;Uninstall resident program?
    InMemory      EQU 02h ;Already installed in memory?
    UseLowMemory  EQU 04h ;User does not want us in High Memory
    MemoryMoved   EQU 08h ;TSR Memory has been moved by our Auto-Code
    FoundSuptFile EQU 10h ;Found Support File in the Path

  ProgFlags2   DB 00h ;Yes/No Test bits #2
    DoEnvir   EQU 01h ;Parsing/Testing Environment variable
    DoStdIn   EQU 02h ;Parsing/Testing StdIn buffer
    Alias     EQU 04h ;Write the Alias List to the Screen
    ErrLvl    EQU 08h ;Write ErrorLevel Table
    Help      EQU 10h ;User wants help?
    Write2Err EQU 20h ;Write to ERR instead of Pause/CON

  StatusFlags     DB 00h ;Yes/No Test bits #3
   Report        EQU 01h ;Show HID Report Data
   Status        EQU 02h ;Show Status
   Descriptors   EQU 04h ;Show Device/Config Descriptors Data
   BadDevices    EQU 08h ;Print Bad Device Table
   RawData       EQU 10h ;Show Raw Data
   RawEscPress   EQU 20h ;Escape Pressed while writing Raw Data
   RawEscRelease EQU 40h ;Escape Released while writing Raw Data

  StatusFlags2    DB 00h ;Yes/No Test bits #4
   KeybUsagePage EQU 01h ;Show Keyboard Usage Page
   GenericPage   EQU 02h ;Show Generic Desktop System Keys Usage page
   ScanCodePage  EQU 04h ;Show Keyboard Scan Codes

  ;----------------------------------------------------------------------------
  ;Miscellaneous Strings we need to write to the screen
  ;----------------------------------------------------------------------------
  HexString: DB '0000',0
  CrLfMsg:   DB CR,LF,0
  SingleMsg: DB ' '
  NoMsg:     DB 0
  Space5Msg: DB ' '
  Space4Msg: DB ' '
  Space3Msg: DB ' '
  Space2Msg: DB ' '
  SpaceMsg:  DB ' ',0


;==============================================================================
;Pause Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Strings and Data needed to Pause the screen
  ;----------------------------------------------------------------------------
  PauseMsg:
    DB CR,LF
    DB ' MORE   (Esc stops Pausing, Ctrl-C stops Completely, any other Continues)',CR,0
  PauseNMsg:
    DB ' MORE                                                                    ',CR,LF,0
  PauseDMsg:
    DB '                                                                               ',CR,0
  PauseRows       DW ? ;Number of rows per screen
  PauseHeaderPtr  DW 1 ;Pointer to Header Message (start with a fake one <> 0)
  PauseHeaderSize DW 2 ;Number of lines in the Header Message
  PauseRowCount   DW 2 ;Current Row Counter


;==============================================================================
;DOS Environment Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Variables to search for our Environment Variable
  ;----------------------------------------------------------------------------
  EnvVarString:  DB 'USBKEYB='     ;Environment Variable String
  EnvVarSize    EQU $-EnvVarString ;Length of String
  EnvVarPointer  DW -1             ;Pointer to Program Environment Variable

  ;----------------------------------------------------------------------------
  ;Variables to search for an extended Command Line String
  ;This should only be valid/needed if the Command Line Size (PSP:[80h]) is 7Eh
  ;----------------------------------------------------------------------------
  CmdLineVarString:  DB 'CMDLINE='         ;Environment Variable String
  CmdLineVarSize    EQU $-CmdLineVarString ;Length of String
  CmdLineVarPointer  DW -1                 ;Pointer to Program Environment Variable


;==============================================================================
;EXEC Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Size of our program stack (in bytes)
  ;----------------------------------------------------------------------------
  ProgStackSize EQU 512

  ;----------------------------------------------------------------------------
  ;Variables to Locate and Run another Program (EXEC Child Program)
  ;----------------------------------------------------------------------------
  PathToUse:      DB MaxPathSize DUP (0) ;Path to Use
  OurPathPointer  DW -1                  ;Pointer to our Path String
  CurrentPath:    DB  0                  ;Current Path (Zero-Length ASCIIZ)
  PathVarPointer  DW -1                  ;Pointer to PATH Environment Variable
  SupportFile:    DB 'USBSUPT1.COM',0    ;Support File Name to Look for
  PathVarString1: DB 'PATH='             ;PATH Environment String Header (DOS)
  PathVarString2: DB 'Path='             ;PATH Environment String Header (NT?)
  PathVarSize    EQU $-PathVarString2    ;Length of String

  ;----------------------------------------------------------------------------
  ;Variables needed to do EXEC Call
  ;----------------------------------------------------------------------------
  CmdTailSize DB CmdTailMax-2           ;Length of command tail (Maximize it)
  CmdTail:    DB CmdTailMax DUP (CR)    ;Command Tail for EXEC Call
  ParamBlock: DB ParamBlockSize DUP (?) ;Parameter Block for EXEC Call
  FCB1:       DB FCBSize DUP (?)        ;File Control Block #1
  FCB2:       DB FCBSize DUP (?)        ;File Control Block #2
  OldSPExec   DW ?                      ;SP may be destroyed by EXEC Call

  ;----------------------------------------------------------------------------
  ;Strings needed to write Descriptor Header Information to the screen
  ;----------------------------------------------------------------------------
  HostIndexMsg:  DB 'USB HOST INDEX: ',0
  DvcAddressMsg: DB 'DEVICE ADDRESS: ',0

  ;----------------------------------------------------------------------------
  ;Strings needed to set up Command Tail for Exec Calls
  ;----------------------------------------------------------------------------
  ReportDescrMsg:     DB 'ReportDescriptor '
  ReportDescrMsgAddr: DB 'xxxx:xxxx '
  ReportDescrCallBk:  DB 'xxxx:xxxx'
                      DB  0

  DescriptorMsg:     DB 'Descriptor '
  DescriptorMsgAddr: DB 'xxxx:xxxx '
  DescriptorMsgHost: DB 'xxh '
  DescriptorMsgDvc:  DB 'xxh '
  DescriptorCallBk:  DB 'xxxx:xxxx'
                     DB  0

  TDStatusMsg:    DB 'TDStatusCode '
  TDStatusCode:   DB 'xxxxh '
  TDStatusCallBk: DB 'xxxx:xxxx'
                  DB 0

  Int14ErrMsg:    DB 'Int14ErrorCode '
  Int14ErrCode:   DB 'xxxxh '
  Int14ErrCallBk: DB 'xxxx:xxxx'
                  DB 0

  ;----------------------------------------------------------------------------
  ;Error Message for when the Support File is not found
  ;----------------------------------------------------------------------------
  NoSuptFileMsg:
    DB 'Error! Need Support File ',0


;==============================================================================
;Help Screen Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Data needed if the User has changed the name of the program from USBKEYB
  ;----------------------------------------------------------------------------
  RealName:
    DB 'USBKEYB',0,0 ;Real name of our program (MUST end in 0)
                     ;  & MUST have enough space for 8-char name
  RealNameSz DW 7    ;Size of RealName (not incl 0)

  ;----------------------------------------------------------------------------
  ;Syntax Help String (if user asks for, or otherwise needs, Help)
  ;----------------------------------------------------------------------------
  SyntaxMsgHdr:
    DB 'SYNTAX: ',0
  SyntaxMsg:
    DB '[Options]',CR,LF
    DB LF
    DB '  /?      Õ Show this HELP screen',CR,LF
    DB '  /A      Õ Show all ALIASES for these command line Options',CR,LF
    DB '  /ErrLvl Õ Show all ErrorLevels (DOS Return Codes)',CR,LF
    DB '  /U      Õ UNINSTALL from memory',CR,LF
    DB '  /L:Y|N  Õ Force installation into LOW memory (Default = No)',CR,LF
    DB LF
    DB '  /S Õ Display current STATUS of Program (including Translation Tables)',CR,LF
    DB '  /C Õ Diplay CONFIGURATION (& other) descriptors of last keyboard found',CR,LF
    DB '  /R Õ Show HID REPORT descriptor of last keyboard found',CR,LF
    DB '  /K Õ Show Raw KEYBOARD Data from USB Keyboard(s)',CR,LF
    DB LF
    DB '  /B        Õ Show list of BAD (incompatible) keyboards found',CR,LF
    DB '  /Beep:Y|N Õ BEEP Speaker when bad keyboard is found (Default = Yes)',CR,LF
    DB LF
    DB '  /Real:Y|N Õ Assume there is a REAL keyboard (Default = Yes)',CR,LF
    DB '  /D:#      Õ DISABLE keyboard index # (0-3, 255 = All)',CR,LF
    DB '  /E:#      Õ ENABLE keyboard index # (0-3, 255 = All)',CR,LF
    DB LF
    DB '  /Lock:Y|N   Õ Process LOCK keys (Caps/Num/Scroll) (Default = Yes)',CR,LF
    DB '  /Pause:Y|N  Õ Process PAUSE keys (Default = Yes)',CR,LF
    DB '  /Reboot:Y|N Õ Process REBOOT requests (Ctl-Alt-Del) (Default = Yes)',CR,LF
    DB LF
    DB '  /T:U#,S# Õ TRANSLATE USB Key Code U# (4 to 255) to Scancode(s) S#',CR,LF
    DB '  /Y:Y#,S# Õ Translate USB sYSTEM Key Code Y# (129 to 255) to Scancode(s) S#',CR,LF
    DB '                S# = 1 to 95, 98 to 127, 224-1 to 224-95, 224-98 to 224-127,',CR,LF
    DB '                       or 225-29-69',CR,LF
    DB '                S# = 0 = restore translation to US QWERTY default',CR,LF
    DB '  /M:#     Õ "Type" Scan Codes using Method # (1-3, Default = Auto)',CR,LF
    DB LF
    DB '  /P        Õ Show USB HID Usage PAGE 7 (USB Keyboard/KeyPad Key Codes)',CR,LF
    DB '  /G        Õ Show USB GENERIC Desktop Usage Page (System Key Codes)',CR,LF
    DB '  /ScanCode Õ Show list of Legacy Keyboard SCANCODEs'
    DB 0


;==============================================================================
;Program Status Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Strings needed to print the Status to the screen
  ;----------------------------------------------------------------------------
  RealKeybMsg:
    DB 'Assume Real Keyboard Exists: ',0
  RealKeybYesMsg:
    DB "Yes (Allow USB Keyboards to be Disabled)",0
  RealKeybNoMsg:
    DB "No (Don't Allow USB Keyboards to be Disabled)",0
  StatusMsg1:
    DB 'COMBINED USB KEYBOARD STATUS      INDIVIDUAL KEYBOARDS  ',CR,LF
    DB 'ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ     ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ',CR,LF
    DB 'Typing Method:           '
    DB 0
  StatusMsg2:
    DB            ,                '     Idx Enbl Host Addr Intf',CR,LF
    DB 'Initial Delay (ms):    ',0
  StatusMsg3:
    DB                             '     ƒƒƒ ƒƒƒƒ ƒƒƒƒ ƒƒƒƒ ƒƒƒƒ',CR,LF
    DB 'Repeat Rate (cps):       ',0
  StatusMsg4:
    DB 'Process Lock Keys:       ',0
  StatusMsg5:
    DB 'Process Pause Keys:      ',0
  StatusMsg6:
    DB 'Process Reboot Requests: ',0

  Status1EndMsg:
    DB 'ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ     ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ',CR,LF
    DB LF
    DB LF
    DB '       USER-DEFINED USB KEY CODE to KEYBOARD SCAN CODE TRANSLATION TABLE',CR,LF
    DB 'ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ',CR,LF
    DB '            USB Key Codes                         Keyboard Scan Codes',CR,LF
    DB 'ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ  ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ',CR,LF
    DB 'Code            Description                Code(s)          Description',CR,LF
    DB 'ƒƒƒƒ ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ  ƒƒƒƒƒƒƒƒƒƒƒ ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ',CR,LF
    DB 0

  Status3EndMsg:
    DB LF
    DB LF
    DB '   USER-DEFINED USB SYSTEM KEY CODE to KEYBOARD SCAN CODE TRANSLATION TABLE',CR,LF
    DB 'ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ',CR,LF
    DB '         USB System Key Codes                     Keyboard Scan Codes',CR,LF
    DB 'ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ  ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ',CR,LF
    DB 'Code            Description                Code(s)          Description',CR,LF
    DB 'ƒƒƒƒ ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ  ƒƒƒƒƒƒƒƒƒƒƒ ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ',CR,LF
    DB 0

  NoXlatMsg:
    DB '#ƒƒ# #ƒƒƒƒƒƒƒƒƒƒƒƒ# NONE #ƒƒƒƒƒƒƒƒƒƒƒƒ#  #ƒƒƒƒƒƒƒƒƒ# #ƒƒƒƒƒƒƒƒ# NONE #ƒƒƒƒƒƒƒƒ#',0

  YesMsg:     DB 'Yes',0
  NoMsgS:     DB ' No',0
  Msg224:     DB '224-',0
  Msg225:     DB '225- 29- 69 Pause',0
  Msg2252:    DB '225- 29- 69  Pause',0
  UnknownMsg: DB '??? Unknown ???',0


;==============================================================================
;Raw Keyboard Data Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Strings and Data needed to print Raw Keyboard Data to the screen
  ;----------------------------------------------------------------------------
  RawDataHdr:
    DB CR,LF
    DB '<Escape> to Quit',CR,LF
    DB 'ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ',CR,LF
;    DB '                             RAW DATA',CR,LF
;    DB '                 ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ',CR,LF
;    DB 'Kbd Hst Dvc Itf  Shift     Key Key Key Key Key Key',CR,LF
;    DB 'Idx Idx Adr Num  Codes N/A  1   2   3   4   5   6 ',CR,LF
;    DB 'ƒƒƒ ƒƒƒ ƒƒƒ ƒƒƒ  ƒƒƒƒƒ ƒƒƒ ƒƒƒ ƒƒƒ ƒƒƒ ƒƒƒ ƒƒƒ ƒƒƒ',CR,LF
    DB  LF
    DB 'K  H     I                              RAW DATA',CR,LF
    DB 'E  O     N  ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ',CR,LF
    DB 'Y  S DVC T  Shift     Key Key Key Key Key Key Key Key Key Key Key Key Key Key',CR,LF
    DB 'B  T ADR F  Codes N/A  1   2   3   4   5   6   7   8   9   10  11  12  13  14',CR,LF
    DB 'ƒ ƒƒ ƒƒƒ ƒ  ƒƒƒƒƒ ƒƒƒ ƒƒƒ ƒƒƒ ƒƒƒ ƒƒƒ ƒƒƒ ƒƒƒ ƒƒƒ ƒƒƒ ƒƒƒ ƒƒƒ ƒƒƒ ƒƒƒ ƒƒƒ ƒƒƒ',CR,LF
    DB MaxDevices DUP (LF)
    DB 0


  VideoPage  DB -1 ;Current Video Page
  CursorSize DW  0 ;Current Cursor Size

  ;PrintScreen Handler
  Int05RawHdr:
    DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code
  Int05Raw:
    IRET

  ;Ctrl-Break Handler
  Int1BRawHdr:
    DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code
  Int1BRaw:
    IRET

  ;Ctrl-C Handler
  Int23RawHdr:
    DB TYPE IntHdr DUP (0) ;Header for removable interrupt vector code
  Int23Raw:
    IRET


;==============================================================================
;USB System Key Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;USB Generic Desktop Table (includes ACPI Keys, which are not considered
  ;  "real" keyboard keys for some reason)
  ;We could theoretically use USBSUPT1 to print this table, but the Generic
  ;  Desktop Page in USB has a bunch of non-keyboard related codes in it
  ;  in addition to the keyboard codes.  If we used USBSUPT1, we would need
  ;  to filter out the non-keyboard-related stuff somehow.
  ;One way to filter it out would be to call USBSUPT1 for each individual
  ;  code, which would mean calling USBSUPT1 many times.  This could be OK
  ;  if everything is on a hard drive (especially if it's a cached hard
  ;  drive), but would be unacceptable from a floppy drive.
  ;We could also "download" the entire table from USBSUPT1 and filter it out
  ;  after we got the whole thing.  Unfortunately, this would actually use
  ;  more memory than doing it ourselves, so it's rather pointless.  Whether
  ;  we do it ourselves or through USBSUPT1, we still need to monitor changes
  ;  in the USB specifications, so we haven't bought anything there, either.
  ;So, we will handle it ourselves.  We'll need to make sure this
  ;  stays up-to-date as the USB standards change.
  ;----------------------------------------------------------------------------

  ;----------------------------------------------------------------------------
  ;Header for writing GenericDesktopTbl
  ;----------------------------------------------------------------------------
  GenericDesktopTblHdr:
    DB '    USB GENERIC DESKTOP SYSTEM KEY CODES',CR,LF
    DB 'ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ',CR,LF
    DB 'Code               Description',CR,LF
    DB 'ƒƒƒƒ ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ',CR,LF
    DB 0

  ;----------------------------------------------------------------------------
  ;The Generic Desktop Keyboard Code Table
  ;----------------------------------------------------------------------------
  GenericDesktopTbl:
    DB RptGDSysCtl,         'System Control (not a key)',0
    DB RptGDSysPowerDown,   'System Power',0
    DB RptGDSysSleep,       'System Sleep',0
    DB RptGDSysWakeUp,      'System Wake Up',0
    DB RptGDSysMenuContext, 'System Menu Context',0
    DB RptGDSysMenuMain,    'System Menu Main',0
    DB RptGDSysMenuApp,     'System Menu Application',0
    DB RptGDSysMenuHelp,    'System Menu Help',0
    DB RptGDSysMenuExit,    'System Menu Exit',0
    DB RptGDSysMenuSelect,  'System Menu Select',0
    DB RptGDSysMenuRight,   'System Menu Right',0
    DB RptGDSysMenuLeft,    'System Menu Left',0
    DB RptGDSysMenuUp,      'System Menu Up',0
    DB RptGDSysMenuDown,    'System Menu Down',0
    DB RptGDSysColdStart,   'System Cold Restart',0
    DB RptGDSysWarmStart,   'System Warm Restart',0
    DB RptGDSysDock,        'System Dock',0
    DB RptGDSysUndock,      'System Undock',0
    DB RptGDSysSetup,       'System Setup',0
    DB RptGDSysBreak,       'System Break',0
    DB RptGDSysDbgBrk,      'System Debugger Break',0
    DB RptGDSysAppBrk,      'Application Break',0
    DB RptGDSysAppDbgBrk,   'Application Debugger Break',0
    DB RptGDSysMute,        'System Speaker Mute',0
    DB RptGDSysHibernate,   'System Hibernate',0
    DB RptGDSysDispInvt,    'System Display Invert',0
    DB RptGDSysDispInt,     'System Display Internal',0
    DB RptGDSysDispExt,     'System Display External',0
    DB RptGDSysDispBoth,    'System Display Both',0
    DB RptGDSysDispDual,    'System Display Dual',0
    DB RptGDSysDispTgl,     'System Display Toggle Internal/External',0
    DB RptGDSysDispSwap,    'System Display Swap Primary/Secondary',0
    DB RptGDSysDispAuto,    'System Display LCD Autoscale',0
    DW -1   ;End of Table


;==============================================================================
;USB Regular Key Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;We could theoretically use USBSUPT1 to print this table, but the USB
  ;  Keyboard Usage Page has a code of 0 (None) that we don't want to
  ;  print.  We could probably live with that, as it could be filtered out
  ;  pretty easily.
  ;The real problem is that we have the potential to use this table twice.
  ;  Sometimes we will want to print the entire table, and sometimes we
  ;  use it do display our key translation tables.  When displaying the
  ;  translation tables, we would need to do an individual call to
  ;  USBSUPT1 for each entry in the translation table.  This could be OK
  ;  if everything is on a hard drive (especially if it's a cached hard
  ;  drive), but would be unacceptable from a floppy drive.
  ;So, we will handle it ourselves.  We'll need to make sure this
  ;  stays up-to-date as the USB standards change.
  ;----------------------------------------------------------------------------

  ;----------------------------------------------------------------------------
  ;Header for writing USBCodeTable
  ;----------------------------------------------------------------------------
  USBTableHdr:
    DB ' USB KEYBOARD CODES (HID Usage Page 7)',CR,LF
    DB 'ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ',CR,LF
    DB 'Code            Description',CR,LF
    DB 'ƒƒƒƒ ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ',CR,LF
    DB 0

  ;----------------------------------------------------------------------------
  ;USB Keyboard Keys & Error Codes
  ;----------------------------------------------------------------------------

  USBCodeTable:
    DB RptKbdErrorRollOver,  'Roll Over Error (not a key)',0
    DB RptKbdErrorPOSTFail,  'POST Failure (not a key)',0
    DB RptKbdErrorUndefined, 'Undefined Error (not a key)',0
    DB RptKbdA,              'Aa',0
    DB RptKbdB,              'Bb',0
    DB RptKbdC,              'Cc',0
    DB RptKbdD,              'Dd',0
    DB RptKbdE,              'Ee',0
    DB RptKbdF,              'Ff',0
    DB RptKbdG,              'Gg',0
    DB RptKbdH,              'Hh',0
    DB RptKbdI,              'Ii',0
    DB RptKbdJ,              'Jj',0
    DB RptKbdK,              'Kk',0
    DB RptKbdL,              'Ll',0
    DB RptKbdM,              'Mm',0
    DB RptKbdN,              'Nn',0
    DB RptKbdO,              'Oo',0
    DB RptKbdP,              'Pp',0
    DB RptKbdQ,              'Qq',0
    DB RptKbdR,              'Rr',0
    DB RptKbdS,              'Ss',0
    DB RptKbdT,              'Tt',0
    DB RptKbdU,              'Uu',0
    DB RptKbdV,              'Vv',0
    DB RptKbdW,              'Ww',0
    DB RptKbdX,              'Xx',0
    DB RptKbdY,              'Yy',0
    DB RptKbdZ,              'Zz',0
    DB RptKbd1,              '1!',0
    DB RptKbd2,              '2@',0
    DB RptKbd3,              '3#',0
    DB RptKbd4,              '4$',0
    DB RptKbd5,              '5%',0
    DB RptKbd6,              '6^',0
    DB RptKbd7,              '7&',0
    DB RptKbd8,              '8*',0
    DB RptKbd9,              '9(',0
    DB RptKbd0,              '0)',0
    DB RptKbdEnter,          'Enter',0
    DB RptKbdEscape,         'Escape',0
    DB RptKbdBackSpace,      'BackSpace',0
    DB RptKbdTab,            'Tab/BackTab',0
    DB RptKbdSpace,          'Space',0
    DB RptKbdMinus,          '-_',0
    DB RptKbdEquals,         '=+',0
    DB RptKbdLBracket,       '[{',0
    DB RptKbdRBracket,       ']}',0
    DB RptKbdBackSlash,      '\|',0
    DB RptKbdNonUSPound,     'Non-US #~',0
    DB RptKbdSemiColon,      ';:',0
    DB RptKbdQuote,          "'",'"',0
    DB RptKbdTilde,          '`~',0
    DB RptKbdComma,          ',<',0
    DB RptKbdPeriod,         '.>',0
    DB RptKbdSlash,          '/?',0
    DB RptKbdCapsLock,       'Caps Lock',0
    DB RptKbdF1,             'F1',0
    DB RptKbdF2,             'F2',0
    DB RptKbdF3,             'F3',0
    DB RptKbdF4,             'F4',0
    DB RptKbdF5,             'F5',0
    DB RptKbdF6,             'F6',0
    DB RptKbdF7,             'F7',0
    DB RptKbdF8,             'F8',0
    DB RptKbdF9,             'F9',0
    DB RptKbdF10,            'F10',0
    DB RptKbdF11,            'F11',0
    DB RptKbdF12,            'F12',0
    DB RptKbdPrintScreen,    'Print Screen',0
    DB RptKbdScrollLock,     'Scroll Lock',0
    DB RptKbdPause,          'Pause',0
    DB RptKbdGreyInsert,     'Grey Insert',0
    DB RptKbdGreyHome,       'Grey Home',0
    DB RptKbdGreyPageUp,     'Grey PageUp',0
    DB RptKbdGreyDelete,     'Grey Delete',0
    DB RptKbdGreyEnd,        'Grey End',0
    DB RptKbdGreyPageDown,   'Grey PageDown',0
    DB RptKbdGreyRight,      'Grey Right',0
    DB RptKbdGreyLeft,       'Grey Left',0
    DB RptKbdGreyDown,       'Grey Down',0
    DB RptKbdGreyUp,         'Grey Up',0
    DB RptKbdNumLock,        'Num Lock/Clear',0
    DB RptKbdGreySlash,      'KeyPad /',0
    DB RptKbdGreyStar,       'KeyPad *',0
    DB RptKbdGreyMinus,      'KeyPad -',0
    DB RptKbdGreyPlus,       'KeyPad +',0
    DB RptKbdGreyEnter,      'KeyPad Enter',0
    DB RptKbdEnd,            'End & 1',0
    DB RptKbdDown,           'Down & 2',0
    DB RptKbdPageDown,       'PageDown & 3',0
    DB RptKbdLeft,           'Left & 4',0
    DB RptKbdGrey5,          'KeyPad 5',0
    DB RptKbdRight,          'Right & 6',0
    DB RptKbdHome,           'Home & 7',0
    DB RptKbdUp,             'Up & 8',0
    DB RptKbdPageUp,         'PageUp & 9',0
    DB RptKbdInsert,         'Insert & 0',0
    DB RptKbdDelete,         'Delete & .',0
    DB RptKbdKey102,         'Non-US \| (102nd Key)',0
    DB RptKbdMouseMenu,      'Mouse Menu (Application)',0
    DB RptKbdPower,          'Power (not a key)',0
    DB RptKbdGreyEquals,     'KeyPad =',0
    DB RptKbdF13,            'F13',0
    DB RptKbdF14,            'F14',0
    DB RptKbdF15,            'F15',0
    DB RptKbdF16,            'F16',0
    DB RptKbdF17,            'F17',0
    DB RptKbdF18,            'F18',0
    DB RptKbdF19,            'F19',0
    DB RptKbdF20,            'F20',0
    DB RptKbdF21,            'F21',0
    DB RptKbdF22,            'F22',0
    DB RptKbdF23,            'F23',0
    DB RptKbdF24,            'F24',0
    DB RptKbdExecute,        'Execute',0
    DB RptKbdHelp,           'Help',0
    DB RptKbdMenu,           'Menu',0
    DB RptKbdSelect,         'Select',0
    DB RptKbdStopMedia,      'Stop (Media)',0
    DB RptKbdAgain,          'Again',0
    DB RptKbdUndo,           'Undo',0
    DB RptKbdCut,            'Cut',0
    DB RptKbdCopy,           'Copy',0
    DB RptKbdPaste,          'Paste',0
    DB RptKbdFind,           'Find',0
    DB RptKbdMute,           'Mute',0
    DB RptKbdVolumeUp,       'Volume Up',0
    DB RptKbdVolumeDown,     'Volume Down',0
    DB RptKbdLockingCapsLk,  'Locking Caps Lock',0
    DB RptKbdLockingNumLk,   'Locking Num Lock',0
    DB RptKbdLockingScrlLk,  'Locking Scroll Lock',0
    DB RptKbdGreyComma,      'KeyPad ,',0
    DB RptKbdGreyEquals2,    'KeyPad = (AS/400)',0
    DB RptKbdIntl1,          'International 1',0
    DB RptKbdIntl2,          'International 2',0
    DB RptKbdIntl3,          'International 3',0
    DB RptKbdIntl4,          'International 4',0
    DB RptKbdIntl5,          'International 5',0
    DB RptKbdIntl6,          'International 6',0
    DB RptKbdIntl7,          'International 7 (Byte Mode Toggle)',0
    DB RptKbdIntl8,          'International 8',0
    DB RptKbdIntl9,          'International 9',0
    DB RptKbdLang1,          'LANG 1 (Hangul/English, Korea)',0
    DB RptKbdLang2,          'LANG 2 (Hanja Conversion, Korea)',0
    DB RptKbdLang3,          'LANG 3 (Katakana, Japan)',0
    DB RptKbdLang4,          'LANG 4 (Hiragana, Japan)',0
    DB RptKbdLang5,          'LANG 5 (Zenkaku/Hnakaku, Japan)',0
    DB RptKbdLang6,          'LANG 6',0
    DB RptKbdLang7,          'LANG 7',0
    DB RptKbdLang8,          'LANG 8',0
    DB RptKbdLang9,          'LANG 9',0
    DB RptKbdAltErase,       'Alternate Erase',0
    DB RptKbdSysRqAttention, 'System Request/Attention',0
    DB RptKbdCancel,         'Cancel',0
    DB RptKbdClear,          'Clear',0
    DB RptKbdPrior,          'Prior',0
    DB RptKbdReturn,         'Return',0
    DB RptKbdSeparator,      'Separator',0
    DB RptKbdOut,            'Out',0
    DB RptKbdOper,           'Open',0
    DB RptKbdClearAgain,     'Clear/Again',0
    DB RptKbdCRSelProps,     'CrSel/Props',0
    DB RptKbdExSel,          'ExSel',0
    DB RptKbdKP00,           'Keypad 00',0
    DB RptKbd000,            'Keypad 000',0
    DB RptKbdKPThousSep,     'Keypad Thousands Separator',0
    DB RptKbdKPDecSep,       'Keypad Decimal Separator',0
    DB RptKbdKPCurrUnit,     'Keypad Currency Unit',0
    DB RptKbdKPCurrSubUnit,  'Keypad Currency Sub-unit',0
    DB RptKbdKPLParen,       'Keypad (',0
    DB RptKbdKPRParen,       'Keypad )',0
    DB RptKbdKPLCBrkt,       'Keypad {',0
    DB RptKbdKPRCBrkt,       'Keypad }',0
    DB RptKbdKPTab,          'Keypad Tab',0
    DB RptKbdKPBkSp,         'Keypad Backspace',0
    DB RptKbdKPA,            'Keypad A',0
    DB RptKbdKPB,            'Keypad B',0
    DB RptKbdKPC,            'Keypad C',0
    DB RptKbdKPD,            'Keypad D',0
    DB RptKbdKPE,            'Keypad E',0
    DB RptKbdKPF,            'Keypad F',0
    DB RptKbdKPXor,          'Keypad XOR',0
    DB RptKbdKPExponent,     'Keypad ^',0
    DB RptKbdKPPercent,      'Keypad %',0
    DB RptKbdKPLArrow,       'Keypad <',0
    DB RptKbdKPRArrow,       'Keypad >',0
    DB RptKbdKPAnd,          'Keypad &',0
    DB RptKbdKPAndAnd,       'Keypad &&',0
    DB RptKbdKPOr,           'Keypad |',0
    DB RptKbdKPOrOr,         'Keypad ||',0
    DB RptKbdKPColon,        'Keypad :',0
    DB RptKbdKPPound,        'Keypad #',0
    DB RptKbdKPSpace,        'Keypad Space',0
    DB RptKbdKPAt,           'Keypad @',0
    DB RptKbdKPExclaim,      'Keypad !',0
    DB RptKbdKPMemStore,     'Keypad Memory Store',0
    DB RptKbdKPMemRecall,    'Keypad Memory Recall',0
    DB RptKbdKPMemClear,     'Keypad Memory Clear',0
    DB RptKbdKPMemAdd,       'Keypad Memory Add',0
    DB RptKbdKPMemSub,       'Keypad Memory Subtract',0
    DB RptKbdKPMemMul,       'Keypad Memory Multiply',0
    DB RptKbdKPMemDiv,       'Keypad Memory Divide',0
    DB RptKbdKPNegate,       'Keypad +/-',0
    DB RptKbdKPClear,        'Keypad Clear',0
    DB RptKbdKPClearEntry,   'Keypad Clear Entry',0
    DB RptKbdKPBinary,       'Keypad Binary',0
    DB RptKbdKPOctal,        'Keypad Octal',0
    DB RptKbdKPDecimal,      'Keypad Decimal',0
    DB RptKbdKPHex,          'Keypad Hexadecimal',0
    DB RptKbdLControl,       'Left Control',0
    DB RptKbdLShift,         'Left Shift',0
    DB RptKbdLAlt,           'Left Alt',0
    DB RptKbdLWindows,       'Left Windows (Left GUI)',0
    DB RptKbdRControl,       'Right Control',0
    DB RptKbdRShift,         'Right Shift',0
    DB RptKbdRAlt,           'Right Alt (AltGr)',0
    DB RptKbdRWindows,       'Right Windows (Right GUI)',0
    DW  -1   ;End of Table


;==============================================================================
;ScanCode Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Header for writing USBCodeTable
  ;----------------------------------------------------------------------------
  ScanCodeTableHdr:
    DB '         KEYBOARD SCAN CODES',CR,LF
    DB '(Keys surrounded by *Stars* are found',CR,LF
    DB '  on Microsoft Multimedia Keyboards)',CR,LF
    DB 'ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ',CR,LF
    DB ' Scan Code         Description',CR,LF
    DB 'ƒƒƒƒƒƒƒƒƒƒƒ ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ',CR,LF
    DB 0

  ;----------------------------------------------------------------------------
  ;Scandard Keyboard Scan Codes
  ;The ones at the end of the Table (added to 80h) are prefixed with 224 (E0h)
  ;The Microsoft MultiMedia keys are surrounded by *'s.
  ;----------------------------------------------------------------------------
  ScanCodeTable:
    DB ScanCodeEscape,         ' Escape',0
    DB ScanCode1,              ' 1!',0
    DB ScanCode2,              ' 2@',0
    DB ScanCode3,              ' 3#',0
    DB ScanCode4,              ' 4$',0
    DB ScanCode5,              ' 5%',0
    DB ScanCode6,              ' 6^',0
    DB ScanCode7,              ' 7&',0
    DB ScanCode8,              ' 8*',0
    DB ScanCode9,              ' 9(',0
    DB ScanCode0,              ' 0)',0
    DB ScanCodeMinus,          ' -_',0
    DB ScanCodeEquals,         ' =+',0
    DB ScanCodeBackSpace,      ' BackSpace',0
    DB ScanCodeTab,            ' Tab/BackTab',0
    DB ScanCodeQ,              ' Qq',0
    DB ScanCodeW,              ' Ww',0
    DB ScanCodeE,              ' Ee',0
    DB ScanCodeR,              ' Rr',0
    DB ScanCodeT,              ' Tt',0
    DB ScanCodeY,              ' Yy',0
    DB ScanCodeU,              ' Uu',0
    DB ScanCodeI,              ' Ii',0
    DB ScanCodeO,              ' Oo',0
    DB ScanCodeP,              ' Pp',0
    DB ScanCodeLBracket,       ' [{',0
    DB ScanCodeRBracket,       ' ]}',0
    DB ScanCodeEnter,          ' Enter',0
    DB ScanCodeControl,        ' Left Control',0
    DB ScanCodeA,              ' Aa',0
    DB ScanCodeS,              ' Ss',0
    DB ScanCodeD,              ' Dd',0
    DB ScanCodeF,              ' Ff',0
    DB ScanCodeG,              ' Gg',0
    DB ScanCodeH,              ' Hh',0
    DB ScanCodeJ,              ' Jj',0
    DB ScanCodeK,              ' Kk',0
    DB ScanCodeL,              ' Ll',0
    DB ScanCodeSemiColon,      ' ;:',0
    DB ScanCodeQuote,          " '",'"',0
    DB ScanCodeTilde,          ' `~',0
    DB ScanCodeLShift,         ' Left Shift',0
    DB ScanCodeBackSlash,      ' \|',0
    DB ScanCodeZ,              ' Zz',0
    DB ScanCodeX,              ' Xx',0
    DB ScanCodeC,              ' Cc',0
    DB ScanCodeV,              ' Vv',0
    DB ScanCodeB,              ' Bb',0
    DB ScanCodeN,              ' Nn',0
    DB ScanCodeM,              ' Mm',0
    DB ScanCodeComma,          ' ,<',0
    DB ScanCodePeriod,         ' .>',0
    DB ScanCodeSlash,          ' /?',0
    DB ScanCodeRShift,         ' Right Shift',0
    DB ScanCodeGreyStar,       ' NumPad *',0
    DB ScanCodeAlt,            ' Left Alt',0
    DB ScanCodeSpace,          ' Space',0
    DB ScanCodeCapsLock,       ' Caps Lock',0
    DB ScanCodeF1,             ' F1',0
    DB ScanCodeF2,             ' F2',0
    DB ScanCodeF3,             ' F3',0
    DB ScanCodeF4,             ' F4',0
    DB ScanCodeF5,             ' F5',0
    DB ScanCodeF6,             ' F6',0
    DB ScanCodeF7,             ' F7',0
    DB ScanCodeF8,             ' F8',0
    DB ScanCodeF9,             ' F9',0
    DB ScanCodeF10,            ' F10',0
    DB ScanCodeNumLock,        ' Num Lock',0
    DB ScanCodeScrollLock,     ' Scroll Lock',0
    DB ScanCodeHome,           ' Home & 7',0
    DB ScanCodeUp,             ' Up & 8',0
    DB ScanCodePageUp,         ' PageUp & 9',0
    DB ScanCodeGreyMinus,      ' NumPad -',0
    DB ScanCodeLeft,           ' Left & 4',0
    DB ScanCodeGrey5,          ' NumPad 5',0
    DB ScanCodeRight,          ' Right & 6',0
    DB ScanCodeGreyPlus,       ' NumPad +',0
    DB ScanCodeEnd,            ' End & 1',0
    DB ScanCodeDown,           ' Down & 2',0
    DB ScanCodePageDown,       ' PageDown & 3',0
    DB ScanCodeInsert,         ' Insert & 0',0
    DB ScanCodeDelete,         ' Delete & .',0
    DB ScanCodeSysReq,         ' System Request',0
    DB ScanCodeKey102,         ' \| (102nd Key)',0
    DB ScanCodeF11,            ' F11',0
    DB ScanCodeF12,            ' F12',0

    DB ScanCodeMessenger+80h,  '*Messenger/Files*',0
    DB ScanCodeRedo+80h,       '*Redo*',0
    DB ScanCodeUndo+80h,       '*Undo*',0
    DB ScanCodeAppLeft+80h,    '*Application Left*',0
    DB ScanCodePaste+80h,      '*Paste*',0
    DB ScanCodeScrollUp+80h,   '*Scroll Up*',0
    DB ScanCodePrevTrack+80h,  '*Previous Track*',0
    DB ScanCodeScrollUpF1+80h, '*Scroll Up Fast*',0
    DB ScanCodeScrollUpF2+80h, '*Scroll Up Faster*',0
    DB ScanCodeWord+80h,       '*Word*',0
    DB ScanCodeExcel+80h,      '*Excel*',0
    DB ScanCodeCalendar+80h,   '*Calendar*',0
    DB ScanCodeLogOff+80h,     '*Log Off*',0
    DB ScanCodeCut+80h,        '*Cut*',0
    DB ScanCodeCopy+80h,       '*Copy*',0
    DB ScanCodeNextTrack+80h,  '*Next Track*',0
    DB ScanCodeEnter+80h,      ' NumPad Enter',0
    DB ScanCodeControl+80h,    ' Right Control',0
    DB ScanCodeAppRight+80h,   '*Application Right*',0
    DB ScanCodeScrollUpF3+80h, '*Scroll Up Fastest*',0
    DB ScanCodeMute+80h,       '*Mute*',0
    DB ScanCodeCalculator+80h, '*Calculator*',0
    DB ScanCodePlayPause+80h,  '*Play/Pause*',0
    DB ScanCodeSpell+80h,      '*Spell*',0
    DB ScanCodeStopMedia+80h,  '*Stop (Media)*',0
    DB ScanCodeLShift+80h,     ' Fake Left Shift',0
    DB ScanCodeVolumeDown+80h, '*Volume Down*',0
    DB ScanCodeVolumeUp+80h,   '*Volume Up*',0
    DB ScanCodeWebHome+80h,    '*Web/Home*',0
    DB ScanCodeSlash+80h,      ' NumPad /',0
    DB ScanCodeRShift+80h,     ' Fake Right Shift',0
    DB ScanCodeGreyStar+80h,   ' PrintScreen (needs Shift)',0
    DB ScanCodeAlt+80h,        ' Right Alt (AltGr)',0
    DB ScanCodeHelp+80h,       '*Help*',0
    DB ScanCodeMusicOffic+80h, '*My Music/Office Home*',0
    DB ScanCodeTaskPane+80h,   '*Task Pane*',0
    DB ScanCodeNew+80h,        '*New*',0
    DB ScanCodeOpen+80h,       '*Open*',0
    DB ScanCodeClose+80h,      '*Close*',0
    DB ScanCodeReply+80h,      '*Reply*',0
    DB ScanCodeMailFwd+80h,    '*Forward (E-mail)*',0
    DB ScanCodeSend+80h,       '*Send*',0
    DB ScanCodeScrollLock+80h, ' Break (needs Control)',0
    DB ScanCodeHome+80h,       ' Grey Home',0
    DB ScanCodeUp+80h,         ' Grey Up',0
    DB ScanCodePageUp+80h,     ' Grey PageUp',0
    DB ScanCodeLeft+80h,       ' Grey Left',0
    DB ScanCodeRight+80h,      ' Grey Right',0
    DB ScanCodeEnd+80h,        ' Grey End',0
    DB ScanCodeDown+80h,       ' Grey Down',0
    DB ScanCodePageDown+80h,   ' Grey PageDown',0
    DB ScanCodeInsert+80h,     ' Grey Insert',0
    DB ScanCodeDelete+80h,     ' Grey Delete',0
    DB ScanCodeSave+80h,       '*Save*',0
    DB ScanCodePrint+80h,      '*Print*',0
    DB ScanCodeLWindows+80h,   ' Left Windows (Left GUI)',0
    DB ScanCodeRWindows+80h,   ' Right Windows (Right GUI)',0
    DB ScanCodeMouseMenu+80h,  ' Mouse Menu (Application)',0
    DB ScanCodePower+80h,      '*Power*',0
    DB ScanCodeSleep+80h,      '*Sleep*',0
    DB ScanCodeWakeup+80h,     '*Wake Up*',0
    DB ScanCodeMyPictures+80h, '*My Pictures*',0
    DB ScanCodeSearch+80h,     '*Search*',0
    DB ScanCodeFavorites+80h,  '*Favorites*',0
    DB ScanCodeRefresh+80h,    '*Refresh*',0
    DB ScanCodeStopInet+80h,   '*Stop/Halt (Internet)*',0
    DB ScanCodeForward+80h,    '*Forward (Internet)*',0
    DB ScanCodeBack+80h,       '*Back*',0
    DB ScanCodeMyComputer+80h, '*My Computer*',0
    DB ScanCodeMail+80h,       '*Mail*',0
    DB ScanCodeMedia+80h,      '*Media*',0
    DB 225,                    ' Pause',0
    DW  -1   ;End of Table


;==============================================================================
;Bad Device Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Strings needed to print Bad Device Table to the screen
  ;----------------------------------------------------------------------------
  BadDeviceHdr:
    DB ' BAD (INCOMPATIBLE) KEYBOARDS',CR,LF
    DB 'ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ',CR,LF
    DB  LF
    DB 'HOST  DVC   INTF  STAGE  ERROR',CR,LF
    DB 'INDX  ADDR  NUM    NUM   CODE',CR,LF
    DB 'ƒƒƒƒ  ƒƒƒƒ  ƒƒƒƒ  ƒƒƒƒƒ  ƒƒƒƒƒ',CR,LF
    DB  0

  NoneFoundMsg:
    DB '#ƒƒ#  #ƒƒ#  None  #ƒƒƒ# #ƒƒƒ#',CR,LF,0
  BadBeepMsg:
    DB 'Beep for Bad Keyboards: ',0


;==============================================================================
;ErrorLevel Related
;==============================================================================

  ;------------------------------------------------------------------------------
  ;ErrorLevels, and Table for ErrorLevel Description Strings
  ;------------------------------------------------------------------------------
  ErLvlOption   EQU  1 ;Bad Option on the command line
  ErLvlMemory   EQU  2 ;Memory problem with the computer
  ErLvlUninst   EQU  3 ;Not in memory yet, can't perform function
  ErLvlVersion  EQU  4 ;Another version of the program already installed
  ErLvlDOSVer   EQU  5 ;DOS Version too old
  ErLvlStdIn    EQU  6 ;StdIn file too big
  ErLvlBadCPU   EQU  7 ;Incompatible CPU
  ErLvlNoHost   EQU  8 ;No USB Host Driver installed
  ErLvlHostInit EQU  9 ;Error while trying to initialize host request
  ErLvlNoData   EQU 10 ;No Report/Descriptor Data to Print
  ErLvlSuptFile EQU 11 ;Could not Find Support File
  ErLvlNoDevice EQU 12 ;No Devices installed, can't show Raw Data

  ErrLvlHdr:
    DB  CR,LF
    DB '                      ERRORLEVELS (DOS RETURN CODES)',CR,LF
    DB '  ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ',CR,LF
    DB '   0 No Error.',CR,LF
    DB 0

  ErrLvlTbl:
    DB ErLvlOption
       DB "Bad Command-line Option.",0
    DB ErLvlMemory
       DB "Memory problem with the computer.",0
    DB ErLvlUninst
       DB "USBKEYB is not installed in memory yet -- can't perform Request.",0
    DB ErLvlVersion
       DB "A different version of USBKEYB is already installed in memory.",0
    DB ErLvlDOSVer
       DB "DOS must be at least version 3.00.",0
    DB ErLvlStdIn
       DB "The Redirected Input Option File (USBKEYB < InFile) is too big.",0
    DB ErLvlBadCPU
       DB "This program requires at least an 80286 CPU.",0
    DB ErLvlNoHost
       DB "Could not find a compatible USB Host Driver in memory.",0
    DB ErLvlHostInit
       DB "Could not properly initialize the USB Host Driver.",0
    DB ErLvlNoData
       DB "There is no Report or Configuration Descriptor data to write.",0
    DB ErLvlSuptFile
       DB "Could not find the required USBSUPT1.COM support file.",0
    DB ErLvlNoDevice
       DB "No Keyboard is available to show the Raw Data for.",0
    DB -1,-1 ;End of Table


;==============================================================================
;Alias Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Strings needed to print Command Line Aliases to the screen
  ;----------------------------------------------------------------------------
  AliasHdrMsg:
    DB '                       ALIASES FOR COMMAND-LINE OPTIONS',CR,LF
    DB 'ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ',CR,LF
    DB 0

  YesNoHdrMsg:
    DB '       ALIASES FOR YES & NO',CR,LF
    DB 'ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ',CR,LF
    DB 0

  KeybHdrMsg:
    DB '    ALIASES FOR KEYBOARD INDEXES',CR,LF
    DB 'ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ',CR,LF
    DB 0

  ;----------------------------------------------------------------------------
  ;Table needed to temporarily store Aliases.
  ;They are originally sorted in reverse alphabetical order.
  ;To write them in forward alphabetical order, we temporarily store
  ;  the String Pointers, in the original reverse order, in this table.
  ;  We then write the strings, starting with the last entry in this table
  ;  and moving backwards.
  ;The number of entries in this table must be AT LEAST as big as the largest
  ;  number of Aliases for a single command Option.  Most Options don't have
  ;  more than a dozen or so Aliases.
  ;----------------------------------------------------------------------------
  AliasSortTbl: DW 100 DUP (?) ;Table to store Alias Strings (to reverse order)


;==============================================================================
;Command-line (Parsing) Related
;==============================================================================

  ;----------------------------------------------------------------------------
  ;Extra Memory Segment (used to store compressed contents of STDIN)
  ;----------------------------------------------------------------------------
  ExtraMemSegment DW ?

  ;----------------------------------------------------------------------------
  ;Data needed to Parse the command line for Options
  ;----------------------------------------------------------------------------
  ParseTest  DB Yes ;Testing the command for errors?
  ParseError DB  No ;Error while Parsing Command Line?

  ;----------------------------------------------------------------------------
  ;Various Parsing-related messages we may need to print to the screen
  ;----------------------------------------------------------------------------
  ParseCmdMsg:
    DB 'Error in the command-line Options for USBKEYB:',0
  ParseEnvMsg:
    DB 'Error in the Environment variable "USBKEYB":',0
  ParseStdInMsg:
    DB 'Error in the redirected input file ("USBKEYB < {FileName}"):',0
  ParseErrMsg:
    DB '^ Error',CR,LF,LF,0
  ParseEnvMsg2:
    DB 'Reset the Environment variable (type "SET USBDRIVE=") and then',CR,LF
  ParseErrMsg2:
    DB 'Type "USBKEYB ?" for Help.',CR,LF,0
  StdInTooBigMsg:
    DB 'The redirected input file ("USBKEYB < {FileName}") is too big!',CR,LF,0

  Copyright:
    DB "USBKEYB 0.09, (C) 2007-2009, Bret E. Johnson.",CR,LF
    DB "DOS Driver for up to 4 USB Keyboards.",CR,LF
    DB  LF,0
  EnvMsg:
    DB 'Environment: ',0
  InstallMsg1:
    DB 'USBKEYB has been ',0
  InstallMsgAuto:
    DB 'automatically ',0
  InstallMsgHigh:
    DB 'installed into Upper Memory.',0
  InstallMsgHole:
    DB 'installed into a Low Memory "Hole".',0
  InstallMsgNorm:
    DB 'installed into Low Memory.',0
  InstallMsgLast:
    DB CR,LF
    DB 'Type "USBKEYB U" to Uninstall USBKEYB from memory.',CR,LF,0
  BadCPUMsg:
    DB 'This program requires at least an 80286 CPU.',0
  DOSVerMsg:
    DB 'You must be using DOS version 3.00 or later to use this program.',0
  NoHostMsg:
    DB 'There must be a compatible USB Host Driver installed in memory',CR,LF
    DB '  (something like USBUHCI.COM) before this program can be installed.',0
  HostInitErrMsg:
    DB 'There was an error while trying to initialize the USB Host.',0
  NoEnvironMsg:
    DB 'There is no DOS Environment.',CR,LF
    DB 'There is something WIERD going on here!',0
  ExtraMemoryMsg:
    DB 'There is not enough available memory to run this program!',0
  WrongVerMsg:
    DB 'Another version of USBKEYB was found in memory.',CR,LF
    DB 'Please UNINSTALL the other version before continuing.',0
  NoDescrDataMsg:
    DB 'There is no Descriptor Data to Write!',0
  NoSuptFileMsg1:
    DB 'Support File ',0
  NoSuptFileMsg2:
    DB ' could not be found.',0
  UninstallMsg:
    DB 'USBKEYB has been Uninstalled from memory.',CR,LF,0
  NoUninstallMsg:
    DB 'Unable to Uninstall USBKEYB from memory, but it has been Disabled.',CR,LF
    DB "Remove any TSR's installed after USBKEYB and try again.",CR,LF
    DB LF
    DB 'To Re-Enable USBKEYB, simply type "USBKEYB" at the command-line.',0
  ReEnabledMsg:
    DB 'USBKEYB has been Re-Enabled.',CR,LF
    DB LF,0
  UninstallErrMsg:
    DB "Can't find USBKEYB in memory.",CR,LF
    DB 'You must install it before it can be Uninstalled.',0
  NoDeviceMsg:
    DB 'No USB Keyboard(s) are Currently Installed.',0
  UpdateMsg:
    DB 'Resident USBKEYB has been updated with new information.',0

  BadDvcErrMsg:
    DB 'Bad Device',0
  RawDataErrMsg:
    DB 'Raw Keyboard',0
  ReportErrMsg:
    DB 'Report '
  DescrErrMsg:
    DB 'Descriptor',0
  StatusErrMsg:
    DB 'Program Status',0
  DataErrMsg:
    DB ' Data is not available until after',CR,LF
    DB '  USBKEYB has been installed into memory.',0

  ;----------------------------------------------------------------------------
  ;Strings needed to write the Command-line error message
  ;----------------------------------------------------------------------------
  MoreLeftMsg:   DB '<<-More}  ',0
  MoreRightMsg:  DB '  {More->>',0
  MoreMsgSize   EQU $-MoreRightMsg

  ;----------------------------------------------------------------------------
  ;Command Line Options with no single-character equivalents
  ;These must be in the same numerical order that we want the
  ;  Alias Option to Sort them in!
  ;----------------------------------------------------------------------------
  OptionBeep     EQU 1 ;Do beep the speaker
  OptionErrLvl   EQU 2 ;Write ErrorLevel Table
  OptionLockKeys EQU 3 ;Manually Handle Lock Keys (Caps/Num/Scroll)
  OptionPause    EQU 4 ;Manually Handle Pause Key
  OptionReboot   EQU 5 ;Manually Handle Reboot Request (Ctrl-Alt-Del)
  OptionRealKeyb EQU 6 ;Existence of REal Keyboard
  OptionScanCode EQU 7 ;Show table of Keyboard ScanCodes

  ;----------------------------------------------------------------------------
  ;Command Line Options
  ;----------------------------------------------------------------------------
  SwitchList:
    DB 'Help',0
    DB  0, '?'
      ; ^              Beginning-of-List Marker
      ;    ^   ^        Code(s) to use

    DB 'UseLowMemory',0
    DB 'UseLowMem',0
    DB 'UseLowerMemory',0
    DB 'UseLowerMem',0
    DB 'UseLow',0
    DB  0, 'L'

    DB 'USBSystemKeys',0
    DB 'USBSystemKeyCodes',0
    DB 'USBSystemCodeTbl',0
    DB 'USBSystemCodeTable',0
    DB  0, 'G'

    DB 'USBRawKeyboardData',0
    DB 'USBRawKeybData',0
    DB 'USBRawData',0
    DB  0, 'K'

    DB 'USBKeyTbl',0
    DB 'USBKeyTable',0
    DB 'USBKeys',0
    DB 'USBKeyCodeTbl',0
    DB 'USBKeyCodeTable',0
    DB 'USBKeyCodes',0
    DB  0, 'P'

    DB 'UsagePage',0
    DB  0, 'P'

    DB 'Uninstall',0
    DB  0, 'U'

    DB 'TypingMthd',0
    DB 'TypingMethod',0
    DB 'TypeMthd',0
    DB 'TypeMethod',0
    DB  0, 'M'

    DB 'TranslateUSBSystemKeyCode',0
    DB  0, 'Y'

    DB 'TranslateUSBKeyCode',0
    DB 'TranslateUSBKey',0
    DB 'TranslateUSBCode',0
    DB  0, 'T'

    DB 'TranslateSystemKeyCode',0
    DB 'TranslateSystemCode',0
    DB 'TranslateSystem',0
    DB 'TranslateSysKeyCode',0
    DB 'TranslateSysCode',0
    DB 'TranslateSys',0
    DB  0, 'Y'

    DB 'Translate',0
    DB  0, 'T'

    DB 'SystemKeyTbl',0
    DB 'SystemKeyTable',0
    DB 'SystemKeys',0
    DB 'SystemKeyCodes',0
    DB 'SystemCodeTbl',0
    DB 'SystemCodeTable',0
    DB  0, 'G'

    DB 'StatusTbl',0
    DB 'StatusTable',0
    DB  0, 'S'

    DB 'StatusofKeyboards',0
    DB 'StatusofKeyboard',0
    DB 'StatusofKeybs',0
    DB 'StatusofKeyb',0
    DB  0, 'S'

    DB 'Status',0
    DB  0, 'S'

    DB 'Sounds',0
    DB 'Sound',0
    DB  0, OptionBeep

    DB 'ShowStatusTbl',0
    DB 'ShowStatusTable',0
    DB 'ShowStatus',0
    DB  0, 'S'

    DB 'ScancodeTable',0
    DB 'ScancodeTbl',0
    DB  0, OptionScanCode

    DB 'Scancodes',0
    DB  0, OptionScanCode

    DB 'ScancodeMethod',0
    DB 'ScancodeMthd',0
    DB  0, 'M'

    DB 'Scancode',0
    DB  0, OptionScanCode

    DB 'RptDescriptor',0
    DB 'RptDescr',0
    DB 'Rpt',0
    DB  0, 'R'

    DB 'ReportDescriptor',0
    DB 'ReportDescr',0
    DB 'Report',0
    DB  0, 'R'

    DB 'Remove',0
    DB  0, 'U'

    DB 'Reboots',0
    DB 'RebootRequests',0
    DB 'RebootRequest',0
    DB 'Reboot',0
    DB  0, OptionReboot

    DB 'RealKeyboard',0
    DB 'RealKeyb',0
    DB 'Real',0
    DB  0, OptionRealKeyb

    DB 'RawUSBKeyboardData',0
    DB 'RawUSBKeybData',0
    DB 'RawUSBData',0
    DB  0, 'K'

    DB 'RawKeyboardData',0
    DB 'RawKeybData',0
    DB 'RawData',0
    DB 'Raw',0
    DB  0, 'K'

    DB 'ProcessReboots',0
    DB 'ProcessRebootRequests',0
    DB 'ProcessRebootRequest',0
    DB 'ProcessReboot',0
    DB  0, OptionReboot

    DB 'ProcessPauses',0
    DB 'ProcessPauseKeys',0
    DB 'ProcessPauseKey',0
    DB 'ProcessPause',0
    DB  0, OptionPause

    DB 'ProcessLocks',0
    DB 'ProcessLockKeys',0
    DB 'ProcessLockKey',0
    DB 'ProcessLock',0
    DB  0, OptionLockKeys

    DB 'Pauses',0
    DB 'PauseKeys',0
    DB 'PauseKey',0
    DB 'Pause',0
    DB  0, OptionPause

    DB 'Out',0
    DB  0, 'U'

    DB 'OptionAliases',0
    DB 'OptionAlias',0
    DB  0, 'A'

    DB 'On',0
    DB  0, 'E'

    DB 'Off',0
    DB  0, 'D'

    DB 'Mthd',0
    DB 'Method',0
    DB  0, 'M'

    DB 'LowMemory',0
    DB 'LowMem',0
    DB 'LowerMemory',0
    DB 'LowerMem',0
    DB 'Low',0
    DB  0, 'L'

    DB 'Locks',0
    DB 'LockKeys',0
    DB 'LockKey',0
    DB 'Lock',0
    DB  0, OptionLockKeys

    DB 'KeyTbl',0
    DB 'KeyTable',0
    DB 'Keys',0
    DB  0, 'P'

    DB 'KeyCodeTbl',0
    DB 'KeyCodeTable',0
    DB 'KeyCodes',0
    DB  0, 'P'

    DB 'KeybUsagePage',0
    DB  0, 'P'

    DB 'KeybStatusTbl',0
    DB 'KeybStatusTable',0
    DB 'KeybStatus',0
    DB  0, 'S'

    DB 'KeyboardUsagePage',0
    DB  0, 'P'

    DB 'KeyboardStatusTbl',0
    DB 'KeyboardStatusTable',0
    DB 'KeyboardStatus',0
    DB  0, 'S'

    DB 'KeyboardsStatusTbl',0
    DB 'KeyboardsStatusTable',0
    DB 'KeyboardsStatus',0
    DB  0, 'S'

    DB 'KeyboardData',0
    DB 'KeybData',0
    DB  0, 'K'

    DB 'IntfDescriptor',0
    DB 'IntfDescr',0
    DB 'Intf',0
    DB  0, 'C'

    DB 'InterfaceDescriptor',0
    DB 'InterfaceDescr',0
    DB 'Interface',0
    DB  0, 'C'

    DB 'IncompatibleKeyboardsList',0
    DB 'IncompatibleKeyboards',0
    DB 'IncompatibleKeybsList',0
    DB 'IncompatibleKeybs',0
    DB  0, 'B'

    DB 'IncompatibleKeyboardList',0
    DB 'IncompatibleKeyboard',0
    DB 'IncompatibleKeybList',0
    DB 'IncompatibleKeyb',0
    DB 'Incompatible',0
    DB  0, 'B'

    DB 'Hlp',0
    DB  0, '?'

    DB 'HIDRptDescriptor',0
    DB 'HIDRptDescr',0
    DB 'HIDRpt',0
    DB  0, 'R'

    DB 'HIDReportDescriptor',0
    DB 'HIDReportDescr',0
    DB 'HIDReport',0
    DB  0, 'R'

    DB 'HandleReboots',0
    DB 'HandleRebootRequests',0
    DB 'HandleRebootRequest',0
    DB 'HandleReboot',0
    DB  0, OptionReboot

    DB 'HandlePauses',0
    DB 'HandlePauseKeys',0
    DB 'HandlePauseKey',0
    DB 'HandlePause',0
    DB  0, OptionPause

    DB 'HandleLocks',0
    DB 'HandleLockKeys',0
    DB 'HandleLockKey',0
    DB 'HandleLock',0
    DB  0, OptionLockKeys

    DB 'H',0
    DB  0, '?'

    DB 'GenericDesktopUsagePage',0
    DB 'GenericDesktopSystemKeys',0
    DB 'GenericDesktopSystemKeyCodes',0
    DB 'GenericDesktopSystemCodes',0
    DB 'GenericDesktop',0
    DB 'Generic',0
    DB  0, 'G'

    DB 'ForceLowMemory',0
    DB 'ForceLowMem',0
    DB 'ForceLowerMemory',0
    DB 'ForceLowerMem',0
    DB 'ForceLow',0
    DB  0, 'L'

    DB 'ErrorLvlTbl',0
    DB 'ErrorLvlTable',0
    DB 'ErrorLvls',0
    DB 'ErrorLvl',0
    DB 'ErrorLevelTbl',0
    DB 'ErrorLevelTable',0
    DB 'ErrorLevels',0
    DB 'ErrorLevel',0
    DB  0, OptionErrLvl

    DB 'ErrLvlTbl',0
    DB 'ErrLvlTable',0
    DB 'ErrLvls',0
    DB 'ErrLvl',0
    DB 'ErrLevelTbl',0
    DB 'ErrLevelTable',0
    DB 'ErrLevels',0
    DB 'ErrLevel',0
    DB  0, OptionErrLvl

    DB 'ErLvlTbl',0
    DB 'ErLvlTable',0
    DB 'ErLvls',0
    DB 'ErLvl',0
    DB 'ErLevelTbl',0
    DB 'ErLevelTable',0
    DB 'ErLevels',0
    DB 'ErLevel',0
    DB  0, OptionErrLvl

    DB 'EndPointDescriptor',0
    DB 'EndPointDescr',0
    DB 'EndPoint',0
    DB  0, 'C'

    DB 'EndPtDescriptor',0
    DB 'EndPtDescr',0
    DB 'EndPt',0
    DB  0, 'C'

    DB 'Enable',0
    DB  0, 'E'

    DB 'Disable',0
    DB  0, 'D'

    DB 'DvcDescriptor',0
    DB 'DvcDescr',0
    DB 'Dvc',0
    DB  0, 'C'

    DB 'DeviceDescriptor',0
    DB 'DeviceDescr',0
    DB 'Device',0
    DB  0, 'C'

    DB 'Descriptors',0
    DB 'Descriptor',0
    DB 'Descrs',0
    DB 'Descr',0
    DB  0, 'C'

    DB 'ConfigurationDescriptor',0
    DB 'ConfigurationDescr',0
    DB 'Configuration',0
    DB  0, 'C'

    DB 'ConfigDescriptor',0
    DB 'ConfigDescr',0
    DB 'Config',0
    DB  0, 'C'

    DB 'CommandLineAliases',0
    DB 'CommandLineAlias',0
    DB  0, 'A'

    DB 'CmdLineAliases',0
    DB 'CmdLineAlias',0
    DB  0, 'A'

    DB 'Beeps',0
    DB 'Beep',0
    DB  0, OptionBeep

    DB 'BadKeyboardsList',0
    DB 'BadKeyboards',0
    DB 'BadKeybsList',0
    DB 'BadKeybs',0
    DB  0, 'B'

    DB 'BadKeyboardList',0
    DB 'BadKeyboard',0
    DB 'BadKeybList',0
    DB 'BadKeyb',0
    DB 'Bad',0
    DB  0, 'B'

    DB 'Aliases',0
    DB 'Alias',0
    DB  0, 'A'

    DB 0            ;End of list


  ;----------------------------------------------------------------------------
  ;Switches for Enable/Disable Switches
  ;----------------------------------------------------------------------------
  SwitchListKeyb:
    DB 'Global',0
    DB  0, -1,

    DB 'AllKeybs',0
    DB 'AllKeyboards',0
    DB 'All',0
    DB  0, -1,

    DB  0            ;End of list


  ;----------------------------------------------------------------------------
  ;Switches for Yes/No Options
  ;----------------------------------------------------------------------------
  SwitchListYesNo:
    DB 'Yes',0
    DB  0, 'Y'

    DB 'True',0
    DB 'T',0
    DB  0, 'Y'

    DB 'On',0
    DB  0, 'Y'

    DB 'Off',0
    DB  0, 'N'

    DB 'No',0
    DB  0, 'N'

    DB 'False',0
    DB 'F',0
    DB  0, 'N'

    DB 'Enabled',0
    DB 'Enable',0
    DB  0, 'Y'

    DB 'Disabled',0
    DB 'Disable',0
    DB  0, 'N'

    DB '1',0
    DB  0, 'Y'

    DB '0',0
    DB  0, 'N'

    DB  0 ;End of list


  ;----------------------------------------------------------------------------
  ;TABLE OF SUBROUTINE OFFSETS TO PROCESS THE VARIOUS COMMAND LINE OPTIONS
  ;----------------------------------------------------------------------------
  SwitchTbl:
    DB  '?'
       DW DoSwitchH        ;Help
    DB  'A'
       DW DoSwitchA        ;Command Line Aliases
    DB  'B'
       DW DoSwitchB        ;Bad Device Table
    DB  'C'
       DW DoSwitchC        ;Device/Config/Interface/HID/EndPoint Descriptors
    DB  'D'
       DW DoSwitchD        ;Disable
    DB  'E'
       DW DoSwitchE        ;Enable
    DB  'G'
       DW DoSwitchG        ;Generic Desktop System Key Page
    DB  'K'
       DW DoSwitchK        ;Raw Kewyboard Data
    DB  'L'
       DW DoSwitchL        ;Low Memory
    DB  'M'
       DW DoSwitchM        ;Method
    DB  'P'
       DW DoSwitchP        ;USB Keyboard Usage Page
    DB  'R'
       DW DoSwitchR        ;Report Descriptor
    DB  'S'
       DW DoSwitchS        ;Status
    DB  'T'
       DW DoSwitchT        ;Translate USB Key Code
    DB  'U'
       DW DoSwitchU        ;Uninstall
    DB  'Y'
       DW DoSwitchY        ;Translate System Key Code

    DB  OptionBeep
       DW DoSwitchBeep     ;Beep the Speaker
    DB  OptionErrLvl
       DW DoSwitchErrLvl   ;ErrorLevel Table
    DB  OptionLockKeys
       DW DoSwitchLockKeys ;Handle Lock Keys (Caps/Num/Scroll)
    DB  OptionPause
       DW DoSwitchPause    ;Handle Pause Key
    DB  OptionReboot
       DW DoSwitchReboot   ;Handle Reboot Requests
    DB  OptionRealKeyb
       DW DoSwitchRealKeyb ;Existence of Real Keyboard
    DB  OptionScanCode
       DW DoSwitchScan     ;Print the Scan Code Table

    DB  0                  ;End of Table


;ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
;PROGRAM CODE (NOT NEEDED IN TSR)
;Needed to initialize/update/show status of TSR, but not actually needed
;  in memory while TSR is running
;‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹

;------------------------------------------------------------------------------
;INITIALIZE/UPDATE THE PROGRAM
;Inputs:
;Outputs: Lots of Stuff
;Changes: Everything
;------------------------------------------------------------------------------
Main:
  CLD                         ;Go forward with string functions
  MOV  SP,LastProgByte        ;Reset Stack Pointer
  CALL ResizeMemory           ;Resize our Memory Allocation
  CALL CopyNameToMCB          ;Copy our Program name to the MCB
  CALL SetupPauseNoHdr        ;Set up the Pause
  MOV  DX,Copyright           ;Write the
  CALL WriteZPause            ;  Copyright message
  CALL SetupExtraMem          ;Set up the Extra Memory Segment (Quits if Err)
  CALL TestMemory             ;See if we're already installed in memory
                              ;QUIT if another version is installed
  CALL GetRealName            ;Get the Real Program Name
  CALL SetupExec              ;Setup Exec Parameters
  CALL GetOurPath             ;Get the Pointer to Our Path
  CALL GetEnvVars             ;Get the Environment Variable Pointers
  CALL ParseIt                ;Parse the command line
  CALL ReleaseExtraMem        ;Release the Extra Memory Segment
  CALL ReEnable               ;Re-Enable the Program, if required
  CALL DoHelp                 ;Print Help and Quit, if necessary
  CALL DoAliases              ;Print Aliases and Quit, if necessary
  CALL DoErrLvls              ;Print ErrorLevel Table and Quit, if necessary
  CALL DoKeybUsagePage        ;Print Keyboard Usage Page & Quit, if necessary
  CALL DoGenericPage          ;Print Generic Desktop Page & Quit, if necessary
  CALL DoScanCodePage         ;Print Generic Desktop Page & Quit, if necessary
  CALL DoUninstall            ;Uninstall and quit, if necessary
  CALL DoBadDevices           ;Print Bad Devices and Quit, if necessary
  CALL DoRawData              ;Print Raw Data and Quit, if necessary
  CALL DoDescriptors          ;Print USB Descriptors, Quit if Error
  CALL DoReport               ;Print Report Data, Quit if Error
  CALL DoStatus               ;Print Status, if necessary
  CALL TestCompatibility      ;Test for compatibility, Quit if not
  TEST ProgFlags,InMemory     ;Are we already installed in memory?
  JZ  >M50                    ;If not, install as a TSR
M40:                          ;Already installed
  MOV  DX,UpdateMsg           ;If so, point at Update message
  XOR  AL,AL                  ;Errorlevel = 0
  JMP  Exit                   ;QUIT

M50:                          ;First-time installation (install as TSR)
  CALL GetRebootPtr           ;Get the pointer to the reboot code
  CALL TestMethod             ;Test which ScanCode-faking Method to use
  CALL DelEnvironment         ;Delete environment space (don't need it now)
  CALL MoveProgramToUMB       ;Move Program to Upper Memory, if possible
   ;All Subroutines after this MUST assume ES is TSR Segment, NOT CS!!
  MOV  DS,ES                  ;Point DS at TSR Data Area
M60:                          ;Ready to install TSR
  CALL InitRepeatRate         ;Initialize Repeat Rate to match current
  CALL InitializeInt01        ;Initialize Int 01 so FakeIt3 will work
  CALL InitTables             ;Initialize all Tables
  CALL ChangeInts             ;Change the interrupts to point at us
  CALL InitInts               ;Initialize periodic "Search for New Device"
                              ;  (quits if there's a problem)
  MOV  DS,CS                  ;Point DS at Local Data Area

  XOR  AL,AL                  ;ErrorLevel = 0
  MOV  BX,DS                  ;Point BX at the Local Segment
  MOV  CX,ES                  ;Point CX at the TSR Segment
  MOV  DX,InstallMsg1         ;Write the first part of the
  CALL WriteZPause            ;  Install Message
  TEST ProgFlags,MemoryMoved  ;Did we move the TSR Memory?
  JZ  >M90                    ;If not, use TSR Exit
  MOV  DX,InstallMsgAuto      ;Write
  CALL WriteZPause            ;  "automatically"
  MOV  DX,InstallMsgHole      ;Assume we installed in a Low Memory Hole
  CMP  BX,CX                  ;Did we install in a UMB or a Low Memory Hole?
  JA  >M80                    ;If a Low Memory Hole, leave the message as is
  MOV  DX,InstallMsgHigh      ;If a UMB, point at Installed High message
M80:                          ;[DX] = appropriate Memory Message
  CALL WriteZPause            ;Write the Memory Message
  MOV  DX,InstallMsgLast      ;Point at the last part of the Installed Message
  JMP  Exit                   ;Done

M90:                          ;Exit Program as a TSR
  MOV  DX,InstallMsgNorm      ;Assume we're in Low Memory
  CMP  CX,0A000h              ;Are we in Low Memory?
  JB  >M95                    ;If so, continue
  MOV  DX,InstallMsgHigh      ;If not, point at the High Memory message
M95:                          ;[DX] = appropriate Memory Message to write
  CALL WriteZPause            ;Write the Memory Message
  MOV  DX,InstallMsgLast      ;Write the last part of the
  CALL WriteZPause            ;  Install Message
  MOV  DX,(LastTSRByte SHR 4) ;DX = number of TSR paragraphs
  MOV  AH,31h                 ;Function 31h (TSR), ErrorLevel in AL (0)
  INT  21h                    ;Do it

;------------------------------------------------------------------------------
;MAKE SURE THE MCB (MEMORY CONTROL BLOCK) CONTAINS OUR PROGRAM NAME
;Inputs:  DS = Local Data Area
;         DS:RealName = ASCIIZ Real Name of our program
;         CLD Already Issued
;Outputs:
;Changes: Data in MCB
;NOTES:   This makes sure that the MCB (Memory Control Block) for our
;           program contains our program name.  DOS 4+ does this
;           automatically, but DOS versions 1-3 do not.  This code
;           does not verify whihc DOS version is in use, but simply
;           fills in the MCB no matter what.
;         Our program name is needed inthe MCB to make sure other programs
;           can identify that we are installed in memory.  This code should
;           be added to all TSR's, so that memory-mapping programs
;           (like MAPMEM or ISLOADED) can tell which TSR's are installed
;           in memory.  It should also be added to all programs that
;           EXEC other programs, so that the EXEC'd program can figure out
;           who called it.
;         Programs that are not TSR's and do not EXEC other programs
;           do not need this code.
;------------------------------------------------------------------------------
CopyNameToMCB:
  PUSH CX,DI,SI,ES              ;Save used registers
  MOV  CX,DS                    ;Point ES:[DI]
  DEC  CX                       ;  at the Owners Name
  MOV  ES,CX                    ;  in the MCB
  MOV  DI,(OFFSET MCBOwnerName) ;  of our program
  MOV  SI,RealName              ;Point DS:[SI] at our Program Name
  MOV  CX,4                     ;Copy 4 words (8 bytes)
  REP  MOVSW                    ;Copy our program name to the MCB
  POP  ES,SI,DI,CX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SETUP/RELEASE AN EXTRA 64K MEMORY SEGMENT FOR OUR PROGRAM
;Inputs:  DS = Local Data Area
;Outputs: ExtraMemSegment = Segment of New Segment
;         Quits Program with Error Message if Memory Problem
;Changes:
;------------------------------------------------------------------------------
SetupExtraMem:
  PUSH AX,BX                 ;Save used registers
  MOV  BX,4096               ;Number of Paragraphs in 64k Program
  MOV  AH,4Ah                ;Service 4Ah (Modify memory allocation)
  INT  21h                   ;Do it (uses ES = Segment, BX = # Paragraphs)
  JC  >X70                   ;If Error, Quit
  MOV  AH,48h                ;Service 48h (Allocate Memory Block)
  INT  21h                   ;Do it (uses BX = # paragraphs, rtns AX = Sgmt)
  JC  >X70                   ;If Error, Quit
  MOV  CS:ExtraMemSegment,AX ;If OK, store the segment
  JMP >X90                   ;Done
X70:                         ;Error
  MOV  DX,ExtraMemoryMsg     ;Point at Error Message
  MOV  AL,ErLvlMemory        ;ErrorLevel = Memory Problem
  JMP  Exit                  ;Quit
X90:                         ;Done
  POP  BX,AX                 ;Restore used registers
  RET

ReleaseExtraMem:
  PUSH AX,BX,ES ;Save used registers
  MOV  BX,OFFSET ExtraMemSegment ;Point [BX] at the Extra Memory Segment
  CMP  W [BX],0 ;Did we already Release it?
  JE  >X90      ;If so, quit
  MOV  ES,[BX]  ;If not, ES = Segment to Remove
  MOV  AH,49h   ;Service 49h (Free Memory)
  INT  21h      ;Do it
  MOV  W [BX],0 ;Mark it as released
X90:            ;Done
  POP  ES,BX,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RE-ENABLE THE PROGRAM IF IT WAS DISABLED DUE TO A FAILED UNINSTALL
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;         DS:ProgFlags.InMemory
;         DS:ProgFlags.Uninstall
;         ES:Int08Counter (= 0 if TSR is Disabled)
;Outputs: If Installed as TSR, currently Disabled, and not Uninstalling:
;           ES:TSRFlags.Uninstalled = False
;           ES:Int08Counter = 5
;         If any other status,
;           does nothing
;Changes:
;------------------------------------------------------------------------------
ReEnable:
  PUSH DX                  ;Save used registers
  TEST ProgFlags,InMemory  ;Already installed as TSR?
  JZ  >B90                 ;If not, quit
  TEST ProgFlags,Uninstall ;User wants us to Uninstall?
  JNZ >B90                 ;If so, quit
  CMP  ES:Int08Counter,0   ;Disabled?
  JNE >B90                 ;If not, quit
  AND  ES:TSRFlags,(NOT Uninstalled) ;Mark as Installed
  MOV  ES:Int08Counter,5   ;Re-enable
  MOV  DX,ReEnabledMsg     ;Notify the user
  CALL WriteZPause         ;  about what we did
B90:                       ;Done
  POP  DX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE ADDRESS OF THE REBOOT CODE (FOR Ctrl-Alt-Del)
;Inputs:
;Outputs: RebootCS, RebootIP
;Changes:
;------------------------------------------------------------------------------
GetRebootPtr:
  PUSH AX,BX,ES      ;Save used registers
  MOV  AX,0FFFFh     ;Store the
  MOV  ES,AX         ;  default CS
  XOR  BX,BX         ;  and IP
  MOV  AL,ES:[BX]    ;Get the code
  CMP  AL,0EAh       ;Is it JMP far immediate?
  JNE >R90           ;If not, we're done
  MOV  AX,ES:[BX+03] ;If so, get the CS
  MOV  BX,ES:[BX+01] ;Get the IP
  MOV  ES,AX         ;Put CS in the right place
R90:                 ;We're done
  MOV  RebootIP,BX   ;Store the
  MOV  RebootCS,ES   ;  Reboot Address
  POP  ES,BX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY CURRENT DELAY & REPEAT RATES TO OUR TSR
;Inputs:  DS = ES = TSR Data Area
;Outputs:
;Changes: Typematic Repeat Rates in Keyboard
;------------------------------------------------------------------------------
InitRepeatRate:
  PUSH AX,BX           ;Save used registers
  MOV  AX,0306h        ;Function 03, Subfunction 06 (Get Typematic Info)
  MOV  BX,-1           ;Preset Errors
  INT  16h             ;Do it (Returns BX)
  CMP  BX,-1           ;Did it work?
  JE  >R90             ;If not, quit
  CALL CalcAndSetRates ;If so, set the Rates
R90:                   ;Done
  POP  BX,AX           ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE NEEDED BECAUSE WE ARE A TSR.  NEEDED TO FIND EXISTING PROGRAM
;  IN MEMORY, UNINSTALL FROM MEMORY, ETC.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;CHECK MEMORY FOR COPY OF CODE TO SEE IF PROGRAM IS ALREADY INSTALLED
;Inputs:  ProgFlags.InMemory = No
;Outputs: ES = TSR program segment, whether a TSR yet or not
;         InMemory  = Yes if program is already installed as TSR
;                   = No if not
;         HandleNum = Multiplex interrupt handle number for Interrupt 2F
;Changes:
;------------------------------------------------------------------------------
TestMemory:
  PUSH AX,BX,CX,DX        ;Save all registers that might change
  PUSH DI,SI,BP,DS        ;  (includes everything except SS & SP)
  MOV  AH,0C0h            ;Function C0, (first available user handle)
M10:                      ;Loop to here for each handle number
  CLD                     ;Go forward with string functions
  XOR  BX,BX              ;Make sure
  XOR  CX,CX              ;  all registers
  XOR  DX,DX              ;  are zero
  MOV  HandleNum,AH       ;Store the handle number
  MOV  AL,MuxInstallChk   ;Install Check Function
  INT  2Fh                ;Do it
  CMP  AL,0FFh            ;Is this function installed?
  JNE >M40                ;If not, our code can't be installed yet
M12:                      ;Test Program Name
  MOV  AH,HandleNum       ;Get the handle number back again
  MOV  AL,MuxGetProgName  ;Get Program Name
  XOR  DI,DI              ;  Function
  INT  2Fh                ;Do it
  MOV  SI,ProgName        ;Point at our name
  MOV  CX,ProgNameLen     ;Get the string length
  REPE CMPSB              ;Compare the two strings
  JNE >M50                ;If not the same, it's not us
M14:                      ;Test Author
  MOV  AH,HandleNum       ;Get the handle number back again
  MOV  AL,MuxGetAuthor    ;Get Author Function
  INT  2Fh                ;Do it (returns ES:[DI])
  MOV  SI,Author          ;Point at our name
  MOV  CX,AuthorLen       ;Get the string length
  REPE CMPSB              ;Compare the two strings
  JNE >M50                ;If no match, it's somebody elses TSR, not ours
M16:                      ;Test Program Version
  MOV  AH,HandleNum       ;Get the handle number back again
  MOV  AL,MuxGetProgVer   ;Get Program Version Function
  INT  2Fh                ;Do it
  CMP  AX,ProgVer         ;Is it the same version as us?
  JE  >M80                ;If so, we're already installed in memory
M30:                      ;A different version is installed in memory
  MOV  AL,ErLvlVersion    ;If not, ErrorLevel = Wrong version
  MOV  DX,WrongVerMsg     ;Point to error message
  JMP  Exit               ;Quit
M40:                      ;No function installed at this handle at all
  CMP  FirstHandle,0      ;Have we already located an available handle?
  JNE >M50                ;If so, just keep searching
  MOV  AH,HandleNum       ;If not, store this one
  MOV  FirstHandle,AH     ;  as the first available
M50:                      ;Increment the Handle number and try again
  MOV  DS,CS              ;Make sure another
  MOV  ES,CS              ;  Int 2F installation check routine
  MOV  AH,HandleNum       ;  hasn't changed things
  ADD  AH,1               ;Look at the next handle number
  JNC  M10                ;If still less than FFh, keep looking
  MOV  AH,FirstHandle     ;If we've searched them all, we're not in memory
  MOV  HandleNum,AH       ;  so go ahead and store our handle number
  JMP >M90                ;And we're done
M80:                      ;We've already been installed (ES contains segment)
  OR   ProgFlags,InMemory ;Mark as already installed
M90:                      ;We're done
  POP  DS,BP,SI,DI        ;Restore
  POP  DX,CX,BX,AX        ;  all registers
  RET

;------------------------------------------------------------------------------
;PRINT MESSAGE IN DX AND QUIT WITH ERRORLEVEL IN AL
;Inputs:  AL = Errorlevel to exit program with
;         CS:[DX] = Message to Print (to ERR)
;Outputs:
;Changes: Quits program
;------------------------------------------------------------------------------
Exit:
  MOV  DS,CS           ;Point DS at Segment where Error Message is Located
  CALL ReleaseExtraMem ;Release the Extra memory Segment
  OR   AL,AL           ;Was there an Error?
  JZ  >X80             ;If not, jump to handle a normal termination
  CALL BeepErr         ;If error, Beep Once
  CALL WriteZErr       ;Write message to ERR
  CALL WriteCrLfErr    ;Move down
  JMP >X90             ;Jump to quit
X80:                   ;No Error - Write to CON
  CALL WriteZPause     ;Write the message to CON
  CALL WriteCrLfPause  ;Write a New Line
X90:                   ;We're done!!
  MOV  AH,4Ch          ;Service 4Ch (terminate program)
  INT  21h             ;Do it

;------------------------------------------------------------------------------
;FINISH UP A "CAN'T PERFORM REQUEST BECAUSE WE'RE NOT INSTALLED YET" ERROR
;Inputs:  DS:[DX] = First message to Print
;Outputs: Writes Message pointed at by DS:[DX]
;         Sets Exit ErrorLevel (ErLvlUninst)
;         Writes Second Half of Error Message
;Changes: Terminates Program
;------------------------------------------------------------------------------
FinishDataErr:
  CALL WriteZErr      ;Write first part of Error Message
  MOV  AL,ErLvlUninst ;ErrorLevel = not installed yet
  MOV  DX,DataErrMsg  ;Point at second part of Error Message
  JUMP Exit           ;Terminate program

;------------------------------------------------------------------------------
;UNINSTALL RESIDENT PROGRAM
;Inputs:  ES = TSR Code Segment
;Outputs:
;Changes: Attempts to Uninstall Program from memory
;         If it can't be Uninstalled, it is Disabled
;------------------------------------------------------------------------------
DoUninstall:
  TEST ProgFlags,Uninstall ;Are we supposed to Uninstall?
  JZ  >U90                 ;If not, just quit
  TEST ProgFlags,InMemory  ;If so, are we even installed yet?
  JZ  >U60                 ;If not, there's an error
  MOV  ES:Int08Counter,0   ;Disable the TSR
  CALL UnconfigureDevices  ;Disable all of the Devices that are configured
  MOV  SI,IntNumTable      ;Point at the Interrupt Address Table
  CALL CompareInts         ;Can we Uninstall the Interrupt Vectors?
  JC  >U70                 ;If not, we can't Uninstall
  MOV  AH,49h              ;If not, service 49h (Release Memory, uses ES)
  INT  21h                 ;Do it
  JC  >U70                 ;If unable to do it, quit with error
U20:                       ;OK to Restore Interrupts
  CALL UnRegDvc0Owner      ;Unregister as a Device 0 Owner
  CALL StopIRQ8            ;Restore IRQ 8 back to original status
  CALL RestoreInts         ;Restore Int's back to normal
  MOV  AX,50               ;Wait a little while
  CALL DelayMSAX           ;  for things to take effect
  MOV  CX,((LastTSRByte-StackSize)/2) ;Number of Words in TSR
  XOR  DI,DI               ;Start of TSR Data Area
  XOR  AX,AX               ;Fill with Zeroes
  REP  STOSW               ;Do it
  MOV  DX,UninstallMsg     ;Point to successful uninstall message
  XOR  AL,AL               ;Errorlevel = 0
  JUMP Exit                ;QUIT
U60:                       ;Not in memory yet - can't Uninstall
  MOV  DX,UninstallErrMsg  ;Point at error message
  MOV  AL,ErLvlUninst      ;Errorlevel = Not Installed Yet
  JUMP Exit                ;QUIT
U70:                       ;Another TSR is in the way - can't Uninstall
  MOV  DX,NoUninstallMsg   ;Point at error message
  MOV  AL,ErLvlMemory      ;Errorlevel = Memory Problem
  JUMP Exit                ;QUIT
U90:                       ;No need to Uninstall
  RET

;------------------------------------------------------------------------------
;CLOSE ALL OPEN HANDLES & UNCONFIGURE DEVICES THAT WE'RE CONTROLLING
;Inputs:  ES = TSR Data Segment
;Outputs:
;Changes: Closes Open Handles, Unconfigures Devices
;------------------------------------------------------------------------------
UnconfigureDevices:
  PUSH AX,CX,DI,SI,DS           ;Save used registers
  MOV  DS,ES                    ;Point DS at TSR Data
  MOV  SI,Int14Request          ;Point at Request Structure
  MOV  DI,DeviceInfoTable       ;Point at Table
  MOV  CX,MaxDevices            ;Number of Table Entries
G10:                            ;Loop to here for each Entry
  TEST [DI].DIFlags,DIFlagInUse ;Valid Entry?
  JZ  >G30                      ;If not, skip it
  CALL RlsPendingKeys           ;Release any pending keystrokes
  CALL RlsDvcDoResetDI          ;Release & Reset the Device
G30:                            ;Done with this entry
  ADD  DI,DeviceInfoStrucSize   ;Point at next entry
  LOOP G10                      ;Keep going until we're done
G50:                            ;Done with Devices
  OR   TSRFlags,Uninstalled     ;Don't let any new keystrokes get processed
  PUSH SI                       ;Save used registers
  MOV  SI,ExternalTable         ;Mark all keystrokes in the External Table
  CALL PurgeUSBPressed          ;  as Released
  POP  SI                       ;Restore used registers
  MOV  AX,20                    ;Wait a little while for pending
  CALL DelayMSAX                ;  keystroke releases to process
  POP  DS,SI,DI,CX,AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;UNREGISTER AS A DEVICE 0 (NEW DEVICE) OWNER
;Inputs:  DS = Local Data Area
;         ES = TSR Data Segment
;Outputs:
;Changes: Unregisters as Device 0 Owner
;NOTES: We do this as a separate item from UnconfigureDevices, and perform it
;         after we've verified that we can actually Uninstall the program.
;       If we are unable to Uninstall and simply Disable ourselves, we don't
;         want to go through the bother of re-Registering as a Device 0 Owner
;         again.  We leave our Device 0 Registration in effect, but effectively
;         just ignore it until we re-Enable ourselves.
;------------------------------------------------------------------------------
UnRegDvc0Owner:
  PUSH AX,SI,DS                      ;Save used registers
  MOV  DS,ES                         ;Point DS at TSR Data
  MOV  SI,Int14Request               ;Point at Request Structure
  MOV  W [SI].I14RCallBackAddr[0],-1 ;Set CallBackAddr to nothing
  MOV  [SI].I14RRequestType,I14RRTUnRegIntfOwner ;Unregister as owner
  MOV  [SI].I14RHostIndex,-1         ;All Hosts
  MOV  [SI].I14RDeviceAddress,0      ;Address 0 (New Connects)
  MOV  AX,Reg0Handle                 ;Handle Number
  MOV  [SI].I14RRequestHandle,AX     ;  returned by Host
  CALL DoInt14CallSaveAllSI          ;Do it
  MOV  AL,UserTblHost                ;Do we have a
  CMP  AL,-1                         ;  User Interrupt?
  JE  >W90                           ;If not, we're done
  MOV  [SI].I14RHostIndex,AL         ;If so, put Host Index in Request
  MOV  AX,UserTblHandle              ;Put the Handle Number
  MOV  [SI].I14RRequestHandle,AX     ;  in the Request
  MOV  [SI].I14RRequestType,I14RRTCloseHandle ;Request = Close Handle
  CALL DoInt14CallSaveAllSI          ;Do it
W90:                                 ;Done
  POP  DS,SI,AX                      ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO COPY DATA FROM THE REDIRECTED INPUT FILE, "COMPRESSING" IT AND
;  STORING IT IN OUR LOCAL MEMORY BUFFER.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;READ THE DATA FROM STDIN (REDIRECTED INPUT) AND STORE IT IN OUR BUFFER
;Inputs:  ExtraMemSegment
;Outputs:
;Changes: Fills up StdInBuffer
;         As data is read, multiple spaces are converted to single spaces,
;           and EOL's (CR/LF) are also changed to spaces
;         Last character of buffer is a 0
;         Quits with error message if StdIn is too big for buffer
;------------------------------------------------------------------------------
FillStdInBuffer:
  PUSH AX,DI,ES             ;Save used registers
  CALL FlushKbdBuff         ;Don't let keyboard buffer mess with File Input
  MOV  ES,ExtraMemSegment   ;Point ES:DI at
  XOR  DI,DI                ;  our Buffer
  MOV  AL,' '               ;Start the buffer
  STOSB                     ;  with a space
B10:                        ;Loop to here for each character
  CALL ReadStdInChar        ;Get the next character
  JZ  >B80                  ;If end of input, we're done
B15:                        ;AL contains the next character
  CMP  AL,EOF               ;Is it End-of-File?
  JE  >B80                  ;If so, it's the end of input
B20:                        ;Test for Comment
  CMP  AL,';'               ;Is it the start of a comment?
  JNE >B30                  ;If not, try the next possibility
  CALL SkipOverStdInComment ;If so, skip over the comment
  JC  >B80                  ;If EOF, we're done
  JMP  B10                  ;If not EOF, continue
B30:                        ;Test for String
  CMP  AL,'"'               ;Double Quote?
  JE  >B35                  ;If so, handle a string
  CMP  AL,"'"               ;Single Quote?
  JE  >B35                  ;If so, handle a string
  CMP  AL,"`"               ;Left Quote?
  JNE >B40                  ;If not, try the next possibility
B35:                        ;It's a String
  CALL GetStdInString       ;Get the rest of the String
  JC  >B80                  ;If error, just quit (Error handled later)
  JMP  B10                  ;If OK, continue
B40:                        ;Test for EOL
  CMP  AL,CR                ;Carriage Return?
  JE  >B45                  ;If so, handle it
  CMP  AL,LF                ;Carriage Return?
  JNE >B50                  ;If not, it's a regular character
B45:                        ;End of Line
  CALL AddSpace2StdInBuff   ;Add a Space to the Buffer, if needed
  JMP  B10                  ;Continue
B50:                        ;Is a regular character
  CALL AddChar2StdInBuff    ;Add the character to the buffer
  JMP  B10                  ;Continue
B80:                        ;Done, no error
  XOR  AL,AL                ;Mark the end
  STOSB                     ;  of the buffer
B90:                        ;Done
  POP  ES,DI,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SKIP OVER A COMMENT IN THE REDIRECTED INPUT FILE
;Inputs:  DS = Local Data Area
;         ES:[DI] = StdInBuffer
;         AL = Semicolon (the start of the Comment)
;Outputs: CF = Clear if OK (not EOF)
;            = Set if we've reached EOF
;         Quits Program with error message if Buffer gets full
;Changes:
;NOTES: This looks for either an EOF or LF character to indicate the end of
;         the comment.  If we see a CR, we simply skip it and wait for the LF
;         that should immediately follow the CR.
;       If a line ends in a CR or CR/LF combination, this will not work
;         this will not work correctly.  However, no file we work with
;         should ever be in that format.
;------------------------------------------------------------------------------
SkipOverStdInComment:
  PUSH AX                 ;Save used registers
C10:                      ;Loop to here for each character on the line
  CALL ReadStdInChar      ;Get the next character (AL)
  JZ  >C70                ;If no characters available, EOF
  CMP  AL,EOF             ;End-of-File character?
  JE  >C70                ;If so, we're done
  CMP  AL,CR              ;Carriage Return?
  JE  >C20                ;If so, End of Comment
  CMP  AL,LF              ;Line Feed?
  JNE  C10                ;If not, keep looking
C20:                      ;End of Line
  CALL AddSpace2StdInBuff ;Add a Space to the Buffer if we need it
  JMP >C80                ;Done
C70:                      ;EOF
  STC                     ;Set EOF Flag
  JMP >C90                ;Done
C80:                      ;Not EOF
  CLC                     ;Set not EOF Flag
C90:                      ;Done
  POP  AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY A STRING FROM STDIN TO THE STDINBUFFER
;Inputs:  DS = Local Data Area
;         ES:[DI] = StdInBuffer
;         AL = Quote Characer (the start of the String)
;Outputs: CF = Clear if OK (not EOF)
;            = Set if we've reached EOF (Bad String)
;         Quits Program with error message if Buffer gets full
;Changes:
;NOTES: This looks for the matching Quote Character to indicate the end of
;         the String.
;       If we find an EOF, CR, or LF in the string, we return a CF to indicate
;         a bad String.
;------------------------------------------------------------------------------
GetStdInString:
  PUSH AX                 ;Save used registers
  MOV  AH,AL              ;Save quote character
  CALL AddSChar2StdInBuff ;Add the Quote Character to the Buffer
S10:                      ;Loop to here for each character of string
  CALL ReadStdInChar      ;Get the next character (AL)
  JZ  >S70                ;If no characters available, Error
  CMP  AL,EOF             ;End-of-File character?
  JE  >S70                ;If so, Error
  CMP  AL,CR              ;Carriage Return?
  JE  >S70                ;If so, Error
  CMP  AL,LF              ;Line Feed?
  JE  >S70                ;If so, Error
  CALL AddSChar2StdInBuff ;Add the Character to the Buffer
  CMP  AL,AH              ;Is it the end-of-string character?
  JNE  S10                ;If not, keep looking
  JMP >S80                ;Done
S70:                      ;EOF (Bad String)
  STC                     ;Set EOF Flag
  JMP >S90                ;Done
S80:                      ;String is OK
  CLC                     ;Set OK flag
S90:                      ;Done
  POP  AX                 ;Restore used registers
  RET

;------------------------------------------------------------------------------
;READ A CHARACTER FROM STDIN (REDIRECTED INPUT)
;Inputs:
;Outputs: AL = Next character from StdIn
;              ZF Clear
;            = 0 if no character to get
;              ZF Set
;Changes:
;------------------------------------------------------------------------------
ReadStdInChar:
  PUSH DX      ;Save used registers
  MOV  DH,AH   ;Save original AH
  MOV  AH,06h  ;Function 06h
  MOV  DL,0FFh ;  (Direct Console Input)
  INT  21h     ;Do it (returns AL and ZF)
  MOV  AH,DH   ;Restore original AH
  POP  DX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ADD A CHARACTER OR STRING CHARACTER TO THE END OF THE STDIN BUFFER
;Inputs:  DS = Local Data Area
;         ES:[DI] = StdInBuffer
;         AL = Character to add to end of Buffer
;         CLD already issued
;Outputs: Returns to calling program if Character was added OK
;         Quits Program with Error if Buffer is already full
;Changes: DI (maybe)
;------------------------------------------------------------------------------
AddSpace2StdInBuff:
  PUSH AX                ;Save used registers
  MOV  AL,' '            ;Add a Space to the Buffer
  CALL AddChar2StdInBuff ;  if we need it
  POP  AX                ;Restore used registers
  RET

AddChar2StdInBuff:
  CMP  AL,' '            ;Are we adding a space?
  JNE >B00               ;If not, just add it
  CMP  B ES:[DI-1],AL    ;If so, is there already a space?
  JNE >B00               ;If not, just add it
  JMP >B90               ;If so, we're done
AddSChar2StdInBuff:
B00:                     ;Add the character to the Buffer
  CMP  DI,65534          ;Is the Buffer full?
  JAE >B70               ;If so, Error
  STOSB                  ;If not, Store the Character
  JMP >B90               ;Done
B70:                     ;Buffer already Full
  MOV  DX,StdInTooBigMsg ;Point at error message
  MOV  AL,ErLvlStdIn     ;ErrorLevel = problem with StdIn
  JMP  Exit              ;Quit
B90:                     ;Done
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO INITIALIZE VARIOUS TABLES AND STRUCTURES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;INITIALIZE TABLES AND STRUCTURES TO THEIR APPROPRIATE VALUES
;Inputs:  ES = TSR Data Area
;         DS = Area where Int14Requests are stored that we want to configure
;Outputs:
;Changes: Various things
;------------------------------------------------------------------------------
InitTables:
  PUSH DI               ;Save used registers
  MOV  DI,Int14Request  ;Point at first Int 14 Request
  CALL InitInt14Req     ;Fill it up
  MOV  DI,Int14Request2 ;Point at second Int 14 Request
  CALL InitInt14Req     ;Fill it up
  POP  DI               ;Restore used registers
  RET

InitInt14Req:
  MOV  [DI].I14RDvcClass,DvcClassNone            ;Device Class
  MOV  [DI].I14RDvcSubClass,DvcSubClassNone      ;Device SubClass
  MOV  [DI].I14RDvcProtocol,DvcProtocolNone      ;Device Protocol
  MOV  [DI].I14RIntfClass,IntfClassHID           ;Interface Class
;  MOV  [DI].I14RIntfSubClass,IntfSubClassHIDBoot ;Interface SubClass
  MOV  [DI].I14RIntfSubClass,IntfSubClassAny     ;Interface SubClass
;  MOV  [DI].I14RIntfProtocol,IntfProtocolHIDKeyb ;Interface Protocol
  MOV  [DI].I14RIntfProtocol,IntfProtocolAny     ;Interface Protocol
  MOV  [DI].I14RVendorID,-1                      ;Vendor ID = Don't Care
  MOV  [DI].I14RProductID,-1                     ;Product ID = Don't Care
  MOV  W [DI].I14RDataAddress[2],ES              ;Set Segment
  MOV  W [DI].I14RCallBackAddr[2],ES             ;  Registers
  RET

;------------------------------------------------------------------------------
;INITIALIZE NECESSARY INTERRUPTS TO CHECK FOR A NEW DEVICE
;Inputs:  DS = ES = TSR Data Area
;Outputs:
;Changes:
;------------------------------------------------------------------------------
InitInts:
  PUSH CX,DI                    ;Save used registers
I10:                            ;Register Interface 0 Owner
  MOV  DI,Int14Request          ;Point at Request Structure
  MOV  [DI].I14RRequestType,I14RRTRegIntfOwner ;Register as Owner
  MOV  [DI].I14RHostIndex,-1    ;Any/All Hosts
  MOV  [DI].I14RDeviceAddress,0 ;New Device
  MOV  W [DI].I14RCallBackAddr[0],DvcOwnerFarCall ;Code to call
  MOV  [DI].I14RUserPktID,0     ;Packet ID 0
  CALL DoInt14CallCXDI          ;Do it
  JC  >I70                      ;If error, quit
  MOV  Reg0Handle,CX            ;Save Registry Handle
  CALL SetupUserInt             ;Setup the User Interrupt
  JMP >I90                      ;Done
I70:                            ;Error
  MOV  DX,HostInitErrMsg        ;If not, point at Err Msg
  MOV  AL,ErLvlHostInit         ;Error Initializing Host
  JMP  Exit                     ;Done
I90:                            ;It worked
  POP  DI,CX                    ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO SAVE/INITIALIZE/RESTORE INTERRUPT VECTORS
;THIS CODE IS NEEDED IN EVERY PROGRAM THAT INTERCEPTS INTERRUPT VECTORS.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;INITIALIZE ALL APPROPRIATE INTERRUPT VECTORS TO OUR TSR CODE
;Inputs:  ES = Data area to store Interrupt Vectors in (Presumably a UMB)
;         CS = Data Area where Interrupt Number Table is stored
;         CLD Already Issued!
;Outputs:
;Changes: Various Int vectors
;------------------------------------------------------------------------------
ChangeInts:
  PUSH AX,DI,SI,DS    ;Save used registers
  MOV  DS,ES          ;Point DS at TSR Data Area
  MOV  SI,IntNumTable ;Point at our Interrupt Nubmer Table
C10:                  ;Loop to here for each table entry
  MOV  AL,CS:[SI]     ;Get Interrupt Number
  OR   AL,AL          ;Is it the end of the table?
  JZ  >C90            ;If so, we're done
  MOV  DI,CS:[SI+1]   ;If valid, get our Code Header Offset
  CALL ChangeInt      ;Point the Interrupt at our code
  ADD  SI,3           ;Point at the next table entry
  JMP  C10            ;Keep going until we're done
C90:                  ;Done with the Interrupt Table
  CALL StartIRQ8      ;Enable IRQ 8 (INT 70h)
  POP  DS,SI,DI,AX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CHANGE INTERRUPT VECTOR TO THIS PROGRAMS INTERRUPT ROUTINE, AND SAVE THE OLD
;Inputs:  DS:[DI] = Pointer to our new interrupt header
;         AL = Interrupt number to change
;Outputs:
;Changes: Interrupt vector
;------------------------------------------------------------------------------
ChangeInt:
  PUSH AX,BX,DX,ES            ;Save used registers
  CALL InitIntHdr             ;Initialize our Interrupt Header
  MOV  AH,35h                 ;Service 35h (Get interrupt vector)
  INT  21h                    ;Do it (returns ES:BX)
  MOV  W [DI].OldVector,BX    ;Save it
  MOV  W [DI].OldVector[2],ES ;  in [DI]
  LEA  DX,[DI].CodeJmp        ;Point DS:DX at our code address
  MOV  AH,25h                 ;Service 25h (Set interrupt vector)
  INT  21h                    ;Do it
  POP  ES,DX,BX,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INITIALIZE THE DATA IN A REMOVABLE INTERRUPT VECTOR HEADER
;Inputs:  DS:[DI] = Pointer to Our Interrupt Header Structure
;Outputs:
;Changes: The Interrupt Header Data
;------------------------------------------------------------------------------
InitIntHdr:
  MOV  [DI].HdwreRst,0CBh   ;Hardware Reset Code = CBh = RETF
  MOV  [DI].CodeJmp,10EBh   ;Jump to Real Code = EBh 10h = JMP ENDS
  MOV  [DI].Signature,424Bh ;Signature for Removable Vector Header = 424Bh
  MOV  [DI].EOIFlag,0       ;We will not be issuing EOI's
  MOV  [DI].HdwreJmp,0F4EBh ;Jump to Hardware Reset = EBh F4h = JMP HdwreRst
  RET

;------------------------------------------------------------------------------
;CHECK THE INTERRUPT VECTORS TO SEE IF THEY'VE BEEN REHOOKED BY ANOTHER PROGRAM
;Inputs:  ES = TSR Data area
;         CLD Already Issued!
;Outputs: CF = Clear if Vectors are OK (We can safely Uninstall our Program)
;            = Set if at least one Vector is unchangeably rehooked
;Changes:
;------------------------------------------------------------------------------
CompareInts:
  PUSH AX,DX,SI          ;Save used registers
  MOV  SI,IntNumTable    ;Point at our interrupt number table
C10:                     ;Loop to here for each table entry
  LODSB                  ;Get the Interrupt Number
  OR   AL,AL             ;Is it the end of the table?
  JZ  >C80               ;If so, we're done
  MOV  DX,[SI]           ;If valid, get our Code Header Offset
  ADD  DX,OFFSET CodeJmp ;Add the Offset to the actual Vector Address
  CALL CompareInt        ;Has it been unchangeably rehooked?
  JC  >C70               ;If so, we can't Uninstall our Program
  INC  SI,2              ;Point at the next table entry
  JMP  C10               ;Keep going until we're done
C70:                     ;At lest one Interupt has been rehooked
  STC                    ;Set the Rehooked flag
  JMP >C90               ;We're done
C80:                     ;Vectors can be Uninstalled
  CLC                    ;Set the OK flag
C90:                     ;We're done
  POP  SI,DX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COMPARE OUR INTERRUPT ADDRESS TO MEMORY SEE IF IT'S BEEN REHOOKED
;Inputs:  ES:[DX] = Vector address to test (our TSR's address)
;         AL = Interrupt number to test
;Outputs: CF = Clear if OK to remove
;         CF = Set if rehooked and can't be removed
;Changes:
;------------------------------------------------------------------------------
CompareInt:
  PUSH BX,CX,ES ;Save used registers
  MOV  CX,ES    ;Point CX:DX at our vector
  CALL FindInt  ;Look for it (returns ES:BX and CF
  POP  ES,CX,BX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESTORE ALL INTERRUPT VECTORS BACK TO THEIR ORIGINAL STATE
;Inputs:  ES = Data Area where original Vector information is stored
;         CLD already issued!
;Outputs:
;Changes: Various Int vectors
;------------------------------------------------------------------------------
RestoreInts:
  PUSH AX,DI,SI       ;Save used registers
  MOV  SI,IntNumTable ;Point at our Interrupt Nubmer Table
R10:                  ;Loop to here for each table entry
  LODSB               ;Get the Interrupt Number
  OR   AL,AL          ;Is it the end of the table?
  JZ  >R90            ;If so, we're done
  MOV  DI,[SI]        ;If valid, get our Code Header Offset
  CALL RestoreInt     ;Restore Interrupt Vector back to original
  INC  SI,2           ;Point at the next table entry
  JMP  R10            ;Keep going until we're done
R90:                  ;We're done
  POP  SI,DI,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESTORE INTERRUPT VECTOR TO ITS ORIGINAL PLACE
;Inputs:  ES:[DI] = Pointer to our Interrupt Header
;         AL = Interrupt number to restore
;Outputs:
;Changes: Interrupt vector back to where it belongs
;Notes:   If we got to here, nothing should have intercepted
;           an interrupt that we haven't checked for.
;         We shouldn't have to worry about running into a road-block!
;------------------------------------------------------------------------------
RestoreInt:
  PUSHF                          ;Save flags
  PUSH BX,CX,DX,SI,BP,ES         ;Save used registers
  MOV  SI,W ES:[DI].OldVector    ;Put the address we'll need to store
  MOV  BP,W ES:[DI].OldVector[2] ;  in BP:SI
  MOV  CX,ES                     ;Point CX:DX
  LEA  DX,[DI].CodeJmp           ;  at our address
  CALL FindInt                   ;Search for it (returns ES:BX)
  CLI                            ;Disable interrupts
  MOV  ES:[BX],SI                ;Store the
  MOV  ES:[BX+2],BP              ;  address
  POP  ES,BP,SI,DX,CX,BX         ;Restore used registers
  POPF                           ;Restore flags
  RET

;------------------------------------------------------------------------------
;SEARCH FOR AN INTERRUPT VECTOR ADDRESS (TO SEE IF OUR CODE CAN BE REMOVED)
;Inputs:  CX:DX = Interrupt Vector address to find (address of our TSR code)
;         AL = Interrupt number to find
;Outputs: CF = Clear if OK to remove
;           ES:BX = address where it is stored
;         CF = Set if rehooked and can't be removed
;           ES:BX = unknown state
;Changes:
;------------------------------------------------------------------------------
FindInt:
  PUSH AX                                ;Save used registers
  XOR  AH,AH                             ;Point ES:BX
  ADD  AX,AX                             ;  at the
  ADD  AX,AX                             ;  main
  MOV  BX,AX                             ;  interupt
  XOR  AX,AX                             ;  vector
  MOV  ES,AX                             ;  table
  CMP  ES:[BX],DX                        ;Is the offset the same as ours?
  JNE >F20                               ;If not, it can't be ours
  CMP  ES:[BX+2],CX                      ;Is the segment the same as ours?
  JE  >F80                               ;If so, it's ours - we're done
F20:                                     ;The main interrupt vector has changed
  LES  BX,ES:[BX]                        ;Get the current vector address
F30:                                     ;Loop for each removable interrupt
  CALL TestIntHdr                        ;Is this a removable interrupt?
  JC  >F70                               ;If not, we can't be removed
  CMP  W ES:[BX-IntOfst].OldVector,DX    ;If so, is the old offset ours?
  JNE >F50                               ;If not, keep looking
  CMP  W ES:[BX-IntOfst].OldVector[2],CX ;If so, is old segment ours?
  JNE >F50                               ;If not, keep looking
  ADD  BX,(OFFSET OldVector) - IntOfst   ;If so, ES:BX = old vector pointer
  JMP >F80                               ;And we're done
F50:                                     ;Removable, but doesn't point at us
  LES  BX,ES:[BX-IntOfst].OldVector      ;Get its old vector address
  JMP  F30                               ;And keep looking for our vector
F70:                                     ;Been rehooked and can't be removed
  STC                                    ;Set the "rehooked" flag
  JMP >F90                               ;We're done
F80:                                     ;It's not rehooked, or it's removable
  CLC                                    ;Set the "OK to remove" flag
F90:                                     ;We're done
  POP  AX                                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AN INTERRUPT POINTER TO SEE IF IT'S REMOVABLE
;Inputs:  ES:BX = Interrupt Vector to test
;Outputs: CF = Set if it's not a removable vector
;            = Clear if it is removable
;Changes:
;Notes:   The references to [BX-IntOfst] instead of [BX] are because of
;           our "unusual" Interrupt Header Structure design
;         We have included the (unneeded) Hardware Reset Routine code
;           (a simple RETF) in our Header Structure for efficiency
;------------------------------------------------------------------------------
TestIntHdr:
  PUSH AX,BX,DS                      ;Save used registers
  MOV  DS,ES                         ;Point DS at the interrupt segment
  CMP  B [BX-IntOfst].CodeJmp,0EBh   ;Is the first instruction a Short JMP?
  JNE >H70                           ;If not, it's not removable
  CMP  [BX-IntOfst].Signature,0424Bh ;Is there a Removeable Interrupt Signature?
  JNE >H70                           ;If not, it's not removable
  MOV  AL,[BX-IntOfst].EOIFlag       ;Get the EOI flag
  OR   AL,AL                         ;Is it zero?
  JZ  >H10                           ;If so, continue checking
  CMP  AL,80h                        ;Is it 80h?
  JNE >H70                           ;If not, it's not removable
H10:                                 ;EOI flag is OK
  CMP  B [BX-IntOfst].HdwreJmp,0EBh  ;Is the HdwreJmp instruction a Short JMP?
  JE  >H80                           ;If so, it's removable!
H70:                                 ;Vector is not removable
  STC                                ;Set the "not removable" flag
  JMP >H90                           ;We're done
H80:                                 ;Vector is removable
  CLC                                ;Set the "removable" flag
H90:                                 ;We're done
  POP  DS,BX,AX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF AN INTERRUPT VECTOR HAS A VALID ADDRESS (other than 0)
;Inputs:  AL = Interrupt number to test
;Outputs: ZF = Set if invalid address (Segment = 0)
;            = Clear if valid address (Segment <> 0)
;Changes:
;------------------------------------------------------------------------------
TestInt:
  PUSH BX,DS      ;Save used registers
  XOR  BX,BX      ;Point DS at the
  MOV  DS,BX      ;  Interrupt Table
  MOV  BL,AL      ;Point BX
  SHL  BX,1       ;  at the Interrupt
  SHL  BX,1       ;  we're looking for
  CMP  W [BX+2],0 ;Is the Segment valid (set the return flag)?
  POP  DS,BX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;INITIALIZE INT 01 VECTOR IN OUR MEMORY TO OUR CODE
;Inputs:  DS = ES = TSR Data Area
;Outputs:
;Changes: Int01Vect
;------------------------------------------------------------------------------
InitializeInt01:
  MOV  W Int01Vect[0],Int01 ;Put our CS:IP into
  MOV  W Int01Vect[2],DS    ;  Int01Vect
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE NEEDED TO SET UP AND DO SCREEN PAUSES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;SETUP PARAMETERS FOR DOING A SCREEN PAUSE (FOR PRINTING A LARGE TABLE)
;Inputs:  DS = Local Data Area
;         DS:[DX] = ASCIIZ Header to Print at top of each screen
;                   Last character of the Header MUST be an LF
;                   If SetupPauseNoHdr, we "inject" NoMsg as the Header
;Outputs: Pauses the screen with a MORE message every time it gets full
;NOTES:   If a Screen Header is really large (almost taking up the whole
;           screen itself, with little room for data), this procedure
;           may not work correctly.  This procedure does not validate
;           the size of the Header -- it simply assumes that it is a
;           "reasonable" size compared to the size of the screen.  Most
;           anything that needs a Screen Header (a long data table) will
;           only have a few lines of Header, so this should be OK as a
;           general purpose procedure.
;         After this Setup is complete (which should be near the beginning
;           of MAIN, before anything is sent to the screen), WriteZPause
;           must be called for ALL screen writing to CON:, not WriteZCon!
;         The Pausing occurs in "real time", meaning we can send things
;           to the Pause routine a byte, line, or several screens at a
;           time for processing.  Because we do it in "real time",
;           we can end up with extra MORE's and screen Headers appearing
;           on screen than are actually needed.  During a screen
;           transition (or a transition to a new Header) whether we
;           actually need to write anything or not depends on if there
;           is actually any real data coming afterward (in time), which
;           of course we don't know (since it hasn't happened yet).
;           So, we must assume there is more data to come and process the
;           MORE's and Screen Headers accordingly.  This only causes problems
;           (in the form of extraneous MORE's and Screen Headers)
;           when things happen near the bottom of the screen.
;           DOS's MORE utiltiy (and other programs of similar ilk) do not
;           process in "real time", but rather store things in a Temporary
;           File and then process the file.
;------------------------------------------------------------------------------
SetupPauseNoHdr:
  PUSH DX         ;Save used registers
  MOV  DX,NoMsg   ;Point at 0-length Message
  CALL SetupPause ;Setup the Pause
  POP  DX         ;Restore used registers
  RET

SetupPause:
  PUSH AX,BX,CX,DI,SI     ;Save used registers
  MOV  SI,OFFSET PauseHeaderPtr ;Point [SI] at PauseHeaderPtr
  CMP  W [SI],-1          ;Has the user already cancelled us?
  JE  >S90                ;If so, just quit
  CMP  W [SI],0           ;Has the user stopped pausing already?
  JE  >S85                ;If so, just write the header
  CALL TestRedir          ;Is our output redirected?
  JNC >S10                ;If not, setup our Headers
  MOV  W [SI],0           ;Mark as Redirected or Pausing Stopped/Disabled
  JMP >S85                ;Jump to write the Header and Quit
S10:                      ;Output not redirected
  CALL GetScreenRows      ;Store the number of rows
  MOV  PauseRows,AX       ;  on the screen
  CALL CountZLinesCX      ;Calculate the number of lines
  INC  CX,2               ;  in the new Header
  MOV  DI,PauseRowCount   ;Get the Current Row count
  ADD  DI,CX              ;Add the size of the new header
  SUB  DI,3               ;Adjust for Headers
  DEC  AX                 ;Will writing the new Header
  CMP  DI,AX              ;  cause a Pause event?
  JB  >S50                ;If not, handle it
S20:                      ;New Header is too big to fit on screen
  MOV  W [SI],NoMsg       ;Point Header for second page at nothing
  MOV  PauseHeaderSize,2  ;Set Pause Header Size
  PUSH CX                 ;Save New Header Size
  SUB  AX,PauseRowCount   ;Calculate how many rows to fill up the screen
  MOV  CX,AX              ;Put number of rows in CX
  INC  CX                 ;Adjust it
S30:                      ;Loop to here to fill up the screen
  CALL WriteCrLfPause     ;Write a new line
  LOOP S30                ;Keep going until we're done
  POP  CX                 ;Restore New Header Size
  CMP  W [SI],-1          ;Did the user cancel during the header transition?
  JE  >S90                ;If so, we're done
  CMP  W [SI],0           ;Did the user stop Pausing during the transition?
  JE  >S85                ;If so, just write the Header
S50:                      ;Need to adjust current Row Count
  SUB  PauseRowCount,2    ;Adjust things for the previous Header
S80:                      ;Store new Header Info
  MOV  [SI],DX            ;Store the Header Address
  MOV  PauseHeaderSize,CX ;Store the Header Size
  ADD  PauseRowCount,CX   ;Add the Header Size to the Row Count
  MOV  AX,PauseRows       ;Compensate if
  CMP  AX,PauseRowCount   ;  the new header
  JAE >S85                ;  put us past
  DEC  AX                 ;  the end
  MOV  PauseRowCount,AX   ;  of hte screen
S85:                      ;Write Header
  CALL WriteZCon          ;Write the Header
S90:                      ;We're done
  POP  SI,DI,CX,BX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CHECK TO SEE IF STDOUT HAS BEEN REDIRECTED
;Inputs:
;Outputs: CF = Clear if STDOUT is normal (usually the screen)
;            = Set if STDOUT been redirected
;Changes:
;------------------------------------------------------------------------------
TestRedir:
  PUSH AX,BX,DX        ;Save used registers
  MOV  AX,4400h        ;Function 4400h (Get Device Info)
  MOV  BX,StdOutHandle ;Device = STDOUT
  INT  21h             ;Do it (returns DX, changes AX)
  JC  >R80             ;If error, assume not Redirected
  AND  DL,(DvcInfoIsDevice+DvcInfoIsStdOut) ;Mask out unwanted bits
  CMP  DL,(DvcInfoIsDevice+DvcInfoIsStdOut) ;Is it still the STDOUT Device?
  JE  >R80             ;If so, it's not Redirected
R70:                   ;STDOUT has been Redirected
  STC                  ;Set the Redirected flag
  JMP >R90             ;Done
R80:                   ;STDOUT is not Redirected
  CLC                  ;Set the Not-Redirected flag
R90:                   ;Done
  POP  DX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NUMBER OF VIDEO ROWS ON THE SCREEN
;Inputs:
;Outputs: AX = Number of text rows on the screen
;                (usually 25, 43, or 50)
;Changes:
;------------------------------------------------------------------------------
GetScreenRows:
  PUSH BX,CX,DS  ;Save used registers
  MOV  AX,40h    ;Point ES to
  MOV  DS,AX     ;  BIOS data area
  MOV  AH,12h    ;Function 12h (EGA Alternate Select)
  MOV  BX,0FF10h ;Subfunction (BL) 10h (Return EGA information)
                 ;  Preset unrealistic return value (BH)
  INT  10h       ;Do it (returns AX, BX, CX)
  CMP  BL,10h    ;Is the function supported (EGA or better)?
  JE  >R50       ;If not, jump to handle MDA/CGA
  CMP  BH,0FFh   ;Is the return value valid?
  JE  >R50       ;If not, jump to handle MDA/CGA
  TEST B [87h],8 ;If so, is bit 3 of the EGA information byte set?
  JNZ >R50       ;If so, EGA is not the active display
  XOR  AX,AX     ;Get # of
  MOV  AL,[84h]  ;  rows - 1
  JMP >R90       ;We're done
R50:             ;Video card is less than EGA (MDA or CGA)
  MOV  AX,24     ;Number of rows must be 25
R90:             ;We're done
  INC  AX        ;Bump the number of rows by 1
  POP  DS,CX,BX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ASCIIZ STRING(s) TO THE SCREEN, PAUSING WHEN IF NECESSARY
;Inputs:  DS:[DX] = String to write
;         PauseRows, PauseHeaderPtr, PauseHeaderSize, PauseRowCount
;         CS = Local Data Area
;Outputs: PauseRowCount
;Changes: Pauses the screen and waits for user input, if necessary
;NOTES: This should be called instead of WriteZCon every time something
;         is written during the Pausing.
;       A string can be written by WriteZCon during the pausing, as long
;         as the string does not contain a Line Feed.  Any line containing
;         a Line Feed must come through here or the Line Count will get
;         screwed up!
;------------------------------------------------------------------------------
WriteZPauseFar:
  CALL WriteZPause
  RETF

WriteZPause:
  PUSH AX,BX,CX,DX          ;Save used registers
  TEST CS:ProgFlags2,Write2Err ;Should we write to ERR instead of Pause?
  JZ  >P10                  ;If not, continue
  CALL WriteZErr            ;If so, write to ERR
  JMP >P90                  ;Done
P10:                        ;Write to Pause
  MOV  AX,CS:PauseHeaderPtr ;Put Header Pointer in AX
  CMP  AX,-1                ;Has the Output been cancelled by the user?
  JE  >P90                  ;If so, don't write anything at all
  OR   AX,AX                ;Is STDOUT Redirected?
  JZ  >P80                  ;If so, just write it with no Pausing
  CALL CountZLinesCX        ;Count how many Lines are in the string
  MOV  AX,CS:PauseRowCount  ;Add the new lines
  ADD  AX,CX                ;  to the current lines
  CMP  AX,CS:PauseRows      ;Will we be at or past the end of the screen?
  JB  >P70                  ;If not, just write it
  JE  >P20                  ;If at the end of the screen, handle it
  SUB  AX,CS:PauseRows      ;If not, find
  SUB  CX,AX                ;  the end of the String
  CALL FindEndOfLines       ;  we need to write ([BX])
  MOV  AL,[BX]              ;Save the character that's there now
  MOV  B [BX],0             ;Replace it with a 0
  CALL WriteZPause          ;Write it (will Pause correctly)
  MOV  [BX],AL              ;Restore original character
  MOV  DX,BX                ;Use the new string pointer
  CALL WriteZPause          ;Write it (Pausing if necessary)
  JMP >P90                  ;Done
P20:                        ;At end of screen
  CALL WriteZCon            ;Write the String
  CALL HandlePause          ;Handle the Pause (may change Pointers/Counters)
  JMP >P90                  ;We're done for now
P70:                        ;Store new Row Count
  MOV  CS:PauseRowCount,AX  ;Save the new Row Count
P80:                        ;Write the String
  CALL WriteZCon            ;Write the string
P90:                        ;Done
  POP  DX,CX,BX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE PAUSE LINE, AND WAIT FOR A KEYSTROKE
;Inputs:  CS = Local Data Area
;         PauseRows, PauseHeaderPtr, PauseHeaderSize, PauseRowCount
;Outputs: PauseRowCount, PauseHeaderPtr
;Changes: Pauses the screen and waits for user input, if necessary
;------------------------------------------------------------------------------
HandlePause:
  PUSH AX,BX,DX,DS        ;Save String Segment
  MOV  DS,CS              ;Point DS at our Data Segment
  MOV  BX,OFFSET PauseHeaderPtr ;Point [BX] at the Pause Header
  MOV  DX,PauseMsg        ;Write the
  CALL WriteZCon          ;  Enter a Keystroke message
  CALL FlushKbdBuff       ;Clear the keyboard buffer
L10:                      ;Loop to here to wait for a keystroke
  CALL GetKey             ;Is there a key in the keystroke buffer?
  JZ   L10                ;If not, keep waiting until there is
  MOV  DX,PauseDMsg       ;Delete the
  CALL WriteZCon          ;  MORE Message
  CMP  AL,CtrlC           ;Was the keystroke a Control-C?
  JE  >L40                ;If so, jump to handle it
  CMP  AL,Escape          ;Was the keystroke an Escape?
  JNE >L20                ;If not, just keep going
  MOV  W [BX],0           ;If so, mark us as redirected (stop Pausing)
  JMP >L90                ;And quit
L20:                      ;Continue with the Pause
  MOV  DX,PauseNMsg       ;Write the
  CALL WriteZCon          ;  MORE Replacement Line
  MOV  DX,[BX]            ;Point DX at the Header
  CALL WriteZCon          ;Write it
  MOV  AX,PauseHeaderSize ;Reset the Row Count
  MOV  PauseRowCount,AX   ;Store the new Row Count
  JMP >L90                ;We're done for now
L40:                      ;Ctrl-C (stop altogether)
  MOV  W [BX],-1          ;Mark as stopped
L90:                      ;Done
  POP  DS,DX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE NUMBER OF LINES IN AN ASCIIZ STRING (COUNT CR/LF COMBINATIONS)
;Inputs:  DS:[DX] = Pointer to String to measure
;         CLD already issued
;Outputs: CX = Number of LF's in the String (may be 0)
;         ZF = Set if CX = 0
;            = Clear if CX > 0
;Changes:
;------------------------------------------------------------------------------
CountZLinesCX:
  PUSH AX,SI ;Save used registers
  MOV  SI,DX ;Put the pointer in DI
  XOR  CX,CX ;Initialize Lines Counter
Z10:         ;Loop to here for each character
  LODSB      ;Get the next character
  OR   AL,AL ;Is it the end of the string?
  JZ  >Z90   ;If so, we're done
  CMP  AL,LF ;Is it a Line Feed?
  JNE  Z10   ;If not, it's not a new line
  INC  CX    ;If so, Increment the Line Counter
  JMP  Z10   ;Keep looking
Z90:         ;We're done
  OR   CX,CX ;Set return flag
  POP  SI,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND THE POINTER AFTER THE FIRST SEVERAL LINES OF A STRING
;Inputs:  DS:[DX] = String to use
;         CX = Number of lines to "skip"
;         CLD already issued
;Outputs: DS:[BX] = "New" String Pointer (after the last line written)
;Changes:
;NOTES: This assumes that the string actually has MORE than the number of
;         lines in AX (it does not look for the end of an ASCIIZ string).
;------------------------------------------------------------------------------
FindEndOfLines:
  PUSH AX,CX  ;Save used registers
  PUSH DI,ES  ;Save used registers
  MOV  BX,CX  ;BX = Line Counter
  MOV  ES,DS  ;Point ES:[DI] at
  MOV  DI,DX  ;  the string
  MOV  AL,LF  ;Look for Line Feeds
  MOV  CX,-1  ;Maximize counter
L10:          ;Loop to here for each new line
  REPNE SCASB ;Look for the end-of-line character
  DEC  BX     ;Decrement the Line Counter
  JNZ  L10    ;If not 0 yet, keep looking
  MOV  BX,DI  ;Store the new string beginning
L90:          ;Done
  POP  ES,DI  ;Restore used registers
  POP  CX,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FLUSH KEYBOARD BUFFER
;Inputs:
;Outputs:
;Changes: Flushes the Keyboard Buffer
;------------------------------------------------------------------------------
FlushKbdBuff:
  PUSH AX     ;Save used registers
F10:          ;Loop to here for each key
  CALL GetKey ;Get a key from the keyboard buffer
  JNZ  F10    ;If there was one, get another
  POP  AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;READ CHARACTER FROM THE KEYBOARD BUFFER
;Inputs:
;Outputs: AH = Keyboard scan code
;         AL = ASCII value of keypress (0 if extended ASCII)
;         AX = 0 if no key is waiting
;Changes: ZF = Set if no key in buffer (AX = 0)
;            = Clear if a key was found (AX = key)
;------------------------------------------------------------------------------
GetKey:
  MOV  AH,1  ;Service 1 (Keystroke waiting?)
  INT  16h   ;Do It
  JZ  >K10   ;If no key waiting, we're done
  XOR  AH,AH ;If a key is waiting, service 0 (Get keystroke)
  INT  16h   ;Do It
  JMP >K90   ;We're done
K10:         ;No keystroke waiting
  XOR  AX,AX ;Make sure AX=0
K90:         ;We're done
  OR   AX,AX ;Set the found/not found flag
  RET

;------------------------------------------------------------------------------
;WRITE A CR/LF TO THE CONSOLE WITH A PAUSE
;Inputs:
;Outputs: To Screen, Updates Pause Counters
;Changes:
;------------------------------------------------------------------------------
WriteCrLfPause:
  PUSH DX          ;Save used registers
  MOV  DX,CrLfMsg  ;Write a Cr/Lf to
  CALL WriteZPause ;  the Pause Device
  POP  DX          ;Restore used registers
  RET

WriteCrLfPause2:
  CALL WriteCrLfPause ;Move down
  CALL WriteCrLfPause ;  2 lines
  RET

WriteCrLfErr:
  PUSH DX         ;Save used registers
  MOV  DX,CrLfMsg ;Write a Cr/Lf to
  CALL WriteZErr  ;  the ERR Device
  POP  DX         ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SOME GENERIC CODE TO WRITE STRINGS, ETC.
;THIS CODE IS NEEDED IN ALMOST EVERY PROGRAM WE WRITE.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;GETS RID OF ENVIRONMENT INFORMATION - NOT NEEDED IN TSR
;Inputs:
;Outputs:
;Changes: Quits if problem releasing memory
;------------------------------------------------------------------------------
DelEnvironment:
  PUSH AX,ES            ;Save used registers
  MOV  ES,[PSPEnvirSeg] ;Point ES at the Environment Segment
  MOV  AH,49h           ;Service 49h (free up memory)
  INT  21h              ;Do it
  JNC >E90              ;If no error occurred, Quit
  MOV  DX,NoEnvironMsg  ;If error, point to message
  MOV  AL,ErLvlMemory   ;Errorlevel = Memory Problem
  JMP  Exit             ;QUIT
E90:                    ;We're done
  POP  ES,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;BEEP THE SPEAKER
;Inputs:
;Outputs: Beeps the speaker
;Changes:
;------------------------------------------------------------------------------
BeepErr:
  PUSH AX,BX    ;Save used registers
  XOR  BX,BX    ;BH = Video page = 0
  MOV  AX,0E07h ;AH = 0Eh = Function = Write TTY
                ;AL = 07h = Character to write = BEL
  INT  10h      ;Do it
  POP  BX,AX    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CAPITALIZE A CHARACTER (Byte)
;Inputs:  AL = character to be capitalized
;Outputs: AL = capitalized character
;Changes:
;------------------------------------------------------------------------------
Capitalize:
  CMP  AL,'a'     ;Is it less than 'a'?
  JB  >Z90        ;If so, quit
  CMP  AL,'z'     ;Is it more than 'z'?
  JA  >Z90        ;If so, quit
  SUB  AL,'a'-'A' ;If between 'a' and 'z', capitalize it
Z90:
  RET

;------------------------------------------------------------------------------
;WRITE A SPECIFIC CHARACTER OR SET OF CHARACTERS TO THE SCREEN
;Inputs:
;Outputs: To screen
;Changes:
;------------------------------------------------------------------------------
WriteAL:
  PUSH DX              ;Save used registers
  MOV  DL,AL           ;Write what's in AL
  JMP >C00             ;Do it
WriteBlock:
  PUSH DX              ;Save used registers
  MOV  DL,'±'          ;Write a Block Character
  JMP >C00             ;Do it
WriteHexEnd:
  PUSH DX              ;Save used registers
  MOV  DL,'h'          ;Write an h
  JMP >C00             ;Do it
WriteSpace:
  PUSH DX              ;Save used registers
  MOV  DX,SpaceMsg     ;Point at Message
  JMP >C10             ;Do it
Write2Spaces:
  PUSH DX              ;Save used registers
  MOV  DX,Space2Msg    ;Point at Message
  JMP >C10             ;Do it
Write3Spaces:
  PUSH DX              ;Save used registers
  MOV  DX,Space3Msg    ;Point at Message
  JMP >C10             ;Do it
Write4Spaces:
  PUSH DX              ;Save used registers
  MOV  DX,Space4Msg    ;Point at Message
  JMP >C10             ;Do it
Write5Spaces:
  PUSH DX              ;Save used registers
  MOV  DX,Space5Msg    ;Point at Message
  JMP >C10             ;Do it
C00:
  MOV  SingleMsg[0],DL ;Put the character in the Single Character String
  MOV  DX,SingleMsg    ;Point at Single Character String
C10:                   ;DX is pointed at String
  CALL WriteZPause     ;Write the String
  POP  DX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE SOME SPACES TO THE SCREEN
;Inputs:  CL = Number of spaces to write
;         SpaceMsg
;Outputs: To the screen
;Changes:
;------------------------------------------------------------------------------
WriteSpaces:
  PUSH CX,DX       ;Save used registers
  OR   CL,CL       ;Should we write 0 spaces?
  JZ  >S90         ;If so, we're done
  XOR  CH,CH       ;If OK, change it to a word
  MOV  DX,SpaceMsg ;Point at the message
S10:               ;Loop to here for each space
  CALL WriteZPause ;Write the space
  LOOP S10         ;Keep going until we're done
S90:               ;We're done
  POP  DX,CX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT NIBBLE, BYTE, OR WORD TO HEX CHARACTER STRING, AND WRITE IT
;Inputs:  AL/AX = Nibble/Byte/Word to be written
;         CLD must be set already!
;Outputs: Writes to the Screen
;Changes: HexString
;------------------------------------------------------------------------------
WriteNibbleHex:
  PUSH BX             ;Save used registers
  MOV  BX,3           ;Need to start of offset 3 in string
  JMP >H00            ;Jump to do it
;WriteByteHex:
;  PUSH BX             ;Save used registers
;  MOV  BX,2           ;Need to start of offset 2 in string
;  JMP >H00            ;Jump to do it
WriteWordHex:
  PUSH BX             ;Save used registers
  XOR  BX,BX          ;Need to start of offset 0 in string
;  JMP >H00            ;Jump to do it
H00:                  ;Start converting the strings
  PUSH DX,DI          ;Save used registers
  MOV  DI,HexString   ;Point DS:[DI] at HexString
  MOV  DX,DI          ;Point DS:[DX] at HexString
  CALL Word2HexString ;Convert the entire Word to a String
  ADD  DX,BX          ;Point DX at the beginning of where we write
  CALL WriteZPause    ;Write it
  POP  DI,DX          ;Restore used registers
  POP  BX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A BYTE OR WORD TO A HEXADECIMAL STRING (2 OR 4 CHARACTERS)
;Inputs:  AX = Word to Convert to a Hex String
;         DS = Local Data Area
;         CLD already issued
;Outputs: DS:[DI]
;Changes: DI
;------------------------------------------------------------------------------
Byte2HexString:
  PUSH AX,ES            ;Save used registers
  MOV  ES,DS            ;Point ES:[DI] at the String
  CALL Word2HexString10 ;Convert it
  POP  ES,AX            ;Restore used registers
  RET

Word2HexString:
  PUSH AX,BX,ES         ;Save used registers
  MOV  BX,AX            ;Save original Word
  MOV  ES,DS            ;Point ES:[DI] at
  CALL Word2HexString00 ;Convert it
  POP  ES,BX,AX         ;Restore used registers
  RET

Word2HexString00:
  MOV  AL,BH            ;Convert High Byte
  CALL Word2HexString10 ;  to ASCII
  MOV  AL,BL            ;Work with Low Byte
Word2HexString10:       ;Convert Byte to ASCII
  AAM  10h              ;Separate Low & High Nibbles
  XCHG AH,AL            ;Put High Nibble in AL
  CALL Word2HexString20 ;Convert High Nibble to ASCII
  XCHG AH,AL            ;Work with Low Nibble
Word2HexString20:       ;Convert Nibble to ASCII
  ADD  AL,90h           ;Convert BCD
  DAA                   ;  to Decimal
  ADC  AL,40h           ;Convert Decimal
  DAA                   ;  to ASCII
  STOSB                 ;Store the Nibble
  RET

;------------------------------------------------------------------------------
;WRITE A BYTE OR WORD TO THE SCREEN AS A DECIMAL
;Inputs:  AL/AX = Byte/Word to Write
;Outputs:
;Changes:
;------------------------------------------------------------------------------
WriteByteMin:
  PUSH AX,BX         ;Save used registers
  XOR  AH,AH         ;Make sure high byte is 0
  MOV  BH,1          ;Mark as doing minimum
  JMP >W00           ;Do it
;WriteWordMin:
;  PUSH AX,BX         ;Save used registers
;  MOV  BH,1          ;Mark as doing minimum
;  JMP >W00           ;Do it
ByteToString:
  PUSH AX,BX         ;Save the original word & BP
  XOR  AH,AH         ;Make sure high byte is 0
  XOR  BH,BH         ;BH = No Minimum, Byte
  JMP >W00           ;Jump to start the loop
WordToString:
  PUSH AX,BX         ;Save the original word
  MOV  BH,2          ;BP = No Minimum, Word
W00:                 ;Do a word or a byte
  PUSH CX,DX,SI      ;Save used registers
  MOV  SI,SingleMsg  ;Point at the single character message
  XOR  BL,BL         ;Test for first non-zero character is false
  MOV  CX,10000      ;First divisor is 10,000
W20:                 ;Loop to here for each character
  XOR  DX,DX         ;High word of Dividend = 0
  DIV  CX            ;Divide DX:AX by current divisor
  OR   AX,AX         ;Is this a non-zero character?
  JNZ >W30           ;If so, we need to write it
  OR   BL,BL         ;Has there already been a non-zero character?
  JNZ >W30           ;If so, we need to write it
  CMP  CX,1          ;Is this the last character?
  JE  >W30           ;If so, we need to write it
  TEST BH,1          ;Are we doing a minimum?
  JNZ >W40           ;If not, don't write anything
  MOV  AL,' '        ;Assume a space
  TEST BH,2          ;Doing a word?
  JNZ >W35           ;If so, write the space
  CMP  CX,100        ;If not, doing the hundreds character?
  JBE >W35           ;If so, write the space
  JMP >W40           ;If not, don't write anything
W30:                 ;We need to write this character
  INC  BL            ;Test for first non-zero character is true
  ADD  AL,'0'        ;Convert the Number to ASCII
W35:                 ;Write the character
  MOV  [SI],AL       ;Write the
  CALL WriteZPauseSI ;  character
W40:                 ;Skip this character - just make it a space
  CMP  CX,1          ;Was this the last division to do?
  JE  >W90           ;If so, we're done
  MOV  AX,DX         ;If not, start next loop with remainder of division
  PUSH AX            ;Save register for a second
  XOR  DX,DX         ;So dividend won't be messed up
  MOV  AX,CX         ;Want to divide divisor in CX
  MOV  CX,10         ;Want to divide by 10
  DIV  CX            ;Divide it
  MOV  CX,AX         ;Store it back in CX
  POP  AX            ;Restore register
  JMP  W20           ;And do it again
W90:                 ;We're done
  POP  SI,DX,CX      ;Restore used registers
  POP  BX,AX         ;Restore original word & BP
  RET

;------------------------------------------------------------------------------
;SKIP OVER AN ASCIIZ STRING
;Inputs:  DS:[SI] = ASCIIZ String to Skip Over
;Outputs:
;Changes: [SI] points at character after the 0
;------------------------------------------------------------------------------
SkipOverStringSI:
  PUSH CX            ;Save used registers
  CALL CalcStrSizeSI ;Calculate the size of the string
  ADD  SI,CX         ;Add it to the pointer
  INC  SI            ;Skip over the 0
  POP  CX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CALCULATE THE LENGTH OF AN ASCIIZ STRING
;Inputs:  DS:[SI] = ASCIIZ String to wrok with
;Outputs: CX = Length of String
;         ZF = Set if string is 0 length
;            = Clear if not
;Changes:
;------------------------------------------------------------------------------
CalcStrSizeSI:
  PUSH DX            ;Save used registers
  MOV  DX,SI         ;Calculate the
  CALL CalcStrSizeDX ;  length of the string
  POP  DX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE AN ASCIIZ STRING, POINTED AT BY SI, TO PAUSE
;Inputs:  DS:[SI] = ASCIIZ String to Write
;Outputs: To Screen (CON)
;Changes:
;------------------------------------------------------------------------------
WriteZPauseSI:
  PUSH DX          ;Save used registers
  MOV  DX,SI       ;Write the
  CALL WriteZPause ;  string
  POP  DX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ASCIIZ STRING TO CON OR TO ERR
;Inputs:  DS:[DX] = Pointer to string
;         CS = Local Data Area
;Outputs: Writes the string to CON or ERR
;Changes:
;------------------------------------------------------------------------------
WriteZCon:                  ;Write to CON
  CMP  CS:PauseHeaderPtr,-1 ;Should we write anything?
  JE  >Z90                  ;If not, just quit
  PUSH BX                   ;Save used register
  MOV  BX,StdOutHandle      ;Write to STDOUT
  JMP >Z00                  ;Jump to do it
WriteZErr:                  ;Write to ERR
  PUSH BX                   ;Save used register
  MOV  BX,StdErrHandle      ;Write to STDERR
Z00:
  PUSH AX,CX                ;Save used registers
  CALL CalcStrSizeDX        ;Calculate the size of the string (returns CX)
  JZ  >Z80                  ;If nothing to write, just quit
  MOV  AH,40h               ;Function 40h (Write to Device)
  INT  21h                  ;Do it
Z80:                        ;We're done
  POP  CX,AX                ;Restore used registers
  POP  BX                   ;Restore used register
Z90:                        ;We're done
  RET

;------------------------------------------------------------------------------
;CALCULATE THE LENGTH OF AN ASCIIZ STRING
;Inputs:  DS:[DX] = Pointer to the string
;Outputs: CX = Length of the string
;         ZF = Set if string is 0 length
;            = Clear if not
;Changes:
;------------------------------------------------------------------------------
CalcStrSizeDX:
  PUSH AX,DI  ;Save used registers
  PUSH ES     ;Save used registers
  MOV  ES,DS  ;Point ES:[DI]
  MOV  DI,DX  ; at the string
  XOR  AL,AL  ;Look for a 0
  MOV  CX,-1  ;Start with max count for REPNE
  REPNE SCASB ;Find the end of the string
  NOT  CX     ;Calculate the size
  DEC  CX     ;  of the string (sets ZF)
  POP  ES     ;Restore used registers
  POP  DI,AX  ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO PARSE THE COMMAND LINE FOR SWITCHES, AND PRINT ERRORS.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;PARSE THE COMMAND LINE FOR SWITCHES
;Inputs:
;Outputs: All kinds of stuff!
;Changes:
;------------------------------------------------------------------------------
ParseIt:
  CALL FixCmdLineCR    ;Replace CR at end of Command Line with a 0
  CALL FillStdInBuffer ;Copy redirected input to our buffer, if needed
                       ;  Quits if error
  MOV  ParseTest,Yes   ;Test input strings for errors
  CALL ParseThings     ;Do all input strings
  MOV  ParseTest,No    ;Parse string for real
  CALL ParseThings     ;Do all input strings
P90:
  RET

ParseThings:
  PUSH SI                       ;Save used registers
  MOV  SI,EnvVarPointer         ;Point at our Environment Variable
  CMP  SI,-1                    ;Is there an Environment Variable to parse?
  JE  >P30                      ;If no, skip it
  OR   ProgFlags2,DoEnvir       ;Mark as doing the Environment
  CMP  ParseTest,Yes            ;Just doing the Test Run?
  JE  >P20                      ;If so, don't write the variable contents yet
  MOV  DX,EnvMsg                ;Write the first part of the
  CALL WriteZPause              ;  environment message to the screen
  CALL WriteEnvCon              ;Write the environment variable contents
  CALL WriteCrLfPause2          ;Move down
P20:                            ;Do the Environment Variable
  CALL ParseCmdLine             ;Parse the Environment (quits if Error)
P30:                            ;Do StdIn
  AND  ProgFlags2,(NOT DoEnvir) ;Mark as doing Command Line
  OR   ProgFlags2,DoStdIn       ;Parse the
  XOR  SI,SI                    ;  StdIn buffer
  CALL ParseCmdLine             ;  Quit if error
  AND  ProgFlags2,(NOT DoStdIn) ;  is found
  MOV  SI,81h                   ;Assume "real" Command Line
  CMP  CmdLineVarPointer,-1     ;Have a CMDLINE Environment variable?
  JE  >P50                      ;If not, just do regular command line
  MOV  SI,CmdLineVarPointer     ;If so, point at the variable
P50:                            ;Pointed at Command Line Tail
  CALL ParseCmdLine             ;Parse Command Line
  POP  SI                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PARSE THE COMMAND LINE FOR SWITCHES
;Inputs:  ParseTest
;         [SI] = Option String to Parse
;Outputs:
;Changes: SI
;------------------------------------------------------------------------------
ParseCmdLine:
  PUSH AX             ;Save used registers
P10:                  ;Look for the next switch
  CALL IsSpaceOrEOX   ;Look for a valid character
  JZ  >P90            ;If EOL, we're done
  CMP  AL,'/'         ;Is it a slash?
  JE  >P20            ;If so, jump to handle it
  CMP  AL,'-'         ;Is it a dash?
  JE  >P20            ;If so, jump to handle it
  DEC  SI             ;If not, point back at the first character
  JMP >P30            ;Continue
P20:                  ;It's a slash or a dash
  CALL IsSpaceOrEOL   ;Look for a valid switch character
  JZ  >P70            ;If no character, there's an error
P30:                  ;Look for the switch
  CALL GetSwitch      ;See if it matches one of our switches
  JNZ  P10            ;If a match, look for the next switch
P70:                  ;Error - tell the user where it was
  CALL WriteCmdErr    ;Display the error for the user
  MOV  AL,ErLvlOption ;ErrorLevel = Bad Option on command line
  MOV  DX,NoMsg       ;Point at an empty message
  JMP  Exit           ;Print error message and quit
P90:                  ;We're done
  POP  AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE SWITCH CHARACTERS, AND DO WHATEVER IT IS THEY'RE ASKING
;Inputs:  DS:[SI] = Command line pointer
;Outputs: Lots of stuff!!!
;         ParseError
;         ZF = Set if Error
;            = Clear if OK
;Changes:
;------------------------------------------------------------------------------
GetSwitch:
  PUSH AX,BX,DI,BP         ;Save used registers
  MOV  BX,SwitchList       ;Point at the list of switch code words
  CALL GetCode             ;See if its a match
  JNC >S10                 ;If so, jump to test it
  CALL GetNextChar         ;If not, it's a single character
  CALL Capitalize          ;Capitalize it
S10:                       ;We have a Switch to test!
  MOV  BX,SwitchTbl        ;Point at the Table of Offsets
S20:                       ;Loop to here for each table entry
  MOV  AH,[BX]             ;Get the switch from our table?
  OR   AH,AH               ;Is it the end of the table?
  JZ  >S70                 ;If so, there's an error
  CMP  AL,AH               ;If a valid entry, is it a match?
  JE  >S30                 ;If so, jump to handle it
  ADD  BX,3                ;If not, point at the next table entry
  JMP  S20                 ;And keep looking
S30:                       ;It's a match from the table
  MOV  DI,OFFSET ProgFlags ;Point [DI] at ProgFlags
  MOV  BP,OFFSET TSRFlags  ;Point [BP] at TSRFlags
  MOV  AH,ParseTest        ;Pass the "Testing" flag
  OR   AH,AH               ;Set the ZF for Testing
  CALL W [BX+1]            ;Do the Switch stuff
  JMP >S90                 ;And quit
S70:                       ;There's an error
  MOV  ParseError,Yes      ;Mark the error flag
S90:                       ;We're done
  CMP  ParseError,Yes      ;Set/Clear the error flag
  POP  BP,DI,BX,AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Display Help (Syntax) Message
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchH:
  OR   B [DI+1],Help ;Set the appropriate Flag
  RET

;------------------------------------------------------------------------------
;Display ErrorLevel Table
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchErrLvl:
  OR   B [DI+1],ErrLvl ;Set the appropriate Flag
  RET

;------------------------------------------------------------------------------
;Display list of Command-line (Option) Aliases
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchA:
  OR   B [DI+1],Alias ;Set the appropriate Flag
  RET

;------------------------------------------------------------------------------
;Uninstall Program from Memory
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchU:
  OR   B [DI],Uninstall ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Install Program in Lower Memory, even if Upper Memory is available
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchL:
  PUSH AX                   ;Save used registers
  MOV  AL,UseLowMemory      ;Bit mask to use
  CALL DoSwitchWithYNPrgFwd ;Do it
  POP  AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Show Keyboard Status
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchS:
  OR   B [DI+2],Status ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Display HID Report Descriptor of Last Device found
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchR:
  OR   B [DI+2],Report ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Display list of Bad Devices
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchB:
  OR   B [DI+2],BadDevices ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Display USB Descriptors of Last Device found
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchC:
  OR   B [DI+2],Descriptors ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Display Raw Data
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchK:
  OR   B [DI+2],RawData ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Display Keyboard Usage Page
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchP:
  OR   B [DI+3],KeybUsagePage ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Display Generic Desktop System Keys Usage Page
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchG:
  OR   B [DI+3],GenericPage ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Display the Scan Code Table
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchScan:
  OR   B [DI+3],ScanCodePage ;Set the appropriate flag
  RET

;------------------------------------------------------------------------------
;Beep Speaker when "Bad" Devices are discovered
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchBeep:
  PUSH AX                   ;Save used registers
  MOV  AL,NoBeep            ;Bit mask to use
  CALL DoSwitchWithYNTsrRvs ;Do it
  POP  AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Assume Existence of Real Keyboard
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchRealKeyb:
  PUSH AX                   ;Save used registers
  MOV  AL,NoRealKeyb        ;Bit mask to use
  CALL DoSwitchWithYNTsrRvs ;Do it
  POP  AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Manually Handle Lock Keys (Caps/Num/Scroll)
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchLockKeys:
  PUSH AX                   ;Save used registers
  MOV  AL,NoHandleLocks     ;Bit mask to use
  CALL DoSwitchWithYNTsrRvs ;Do it
  POP  AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Manually Handle Pause Key
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchPause:
  PUSH AX                   ;Save used registers
  MOV  AL,NoHandlePause     ;Bit mask to use
  CALL DoSwitchWithYNTsrRvs ;Do it
  POP  AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Manually Handle Reboot Request (Ctrl-Alt-Del)
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchReboot:
  PUSH AX                   ;Save used registers
  MOV  AL,NoHandleReboot    ;Bit mask to use
  CALL DoSwitchWithYNTsrRvs ;Do it
  POP  AX                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Disable/Enable individual Devices
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchD:
  PUSH CX                                     ;Save used registers
  XOR  CL,CL                                  ;Mark as a Disable
  JMP >D00                                    ;Do it
DoSwitchE:
  PUSH CX                                     ;Save used registers
  MOV  CL,-1                                  ;Mark as an Enable
;  JMP >D00                                    ;Do it
D00:
  PUSH AX,BX,DI                               ;Save used registers
  CALL SkipColonEquals                        ;Skip Colon/Equals (if there)
  MOV  BX,SwitchListKeyb                      ;Point at the list of code words
  CALL GetCode                                ;See if its a match
  JNC >D10                                    ;If so, jump to test it
  CALL GetDecimal                             ;If not, see if it's a number
  JC  >D70                                    ;If not, error
D10:                                          ;Got a number
  CMP  AL,(MaxDevices-1)                      ;Is it valid?
  JBE >D20                                    ;If so, continue
  CMP  AL,255                                 ;If so, is it Global?
  JNE >D70                                    ;If not, Error
D20:                                          ;Valid Number
  CMP  ParseTest,Yes                          ;Is this just the Test Run?
  JE  >D90                                    ;If so, don't change anything yet
  CMP  AL,255                                 ;If so, is it Global?
  JE  >D50                                    ;If so, jump to handle it
D30:                                          ;Single Device
  MOV  BL,AL                                  ;Get the
  CALL DIIndex2OffsetBL                       ;  Info Table pointer (DI)
  OR   CL,CL                                  ;Disable?
  JNZ >D40                                    ;If not, jump to Enable
  TEST B ES:[BP],NoRealKeyb                   ;Is there a real keyboard?
  JNZ >D90                                    ;If not, don't Disable it
  CALL RlsPendingKeys                         ;Release any pending keystrokes
  OR   ES:[DI].DIFlags,DIFlagDisabled         ;Disable it
  AND  ES:[DI].DIFlags,(NOT DIFlagDisconnect) ;Mark Pending keystrokes as done
  JMP >D90                                    ;Done
D40:                                          ;Enable Single Device
  AND  ES:[DI].DIFlags,(NOT DIFlagDisabled)   ;Enable it
  JMP >D90                                    ;Done
D50:                                          ;Global (All Devices)
  MOV  DI,DeviceInfoTable                     ;Point at the Table
  MOV  CH,MaxDevices                          ;Number of Table Entries
D55:                                          ;Loop to here for each Device
  OR   CL,CL                                  ;Disable?
  JNZ >D60                                    ;If not, jump to handle Enable
  TEST B ES:[BP],NoRealKeyb                   ;Is there a real keyboard?
  JNZ >D65                                    ;If not, don't Disable it
  CALL RlsPendingKeys                         ;Release any pending keystrokes
  OR   ES:[DI].DIFlags,DIFlagDisabled         ;Disable it
  AND  ES:[DI].DIFlags,(NOT DIFlagDisconnect) ;Mark Pending keystrokes as done
  JMP >D65                                    ;Continue
D60:                                          ;Enable Single in Global Mode
  AND  ES:[DI].DIFlags,(NOT DIFlagDisabled)   ;Enable it
D65:                                          ;Done handling individual Device
  ADD  DI,DeviceInfoStrucSize                 ;Point at next table entry
  DEC  CH                                     ;Decrement Loop Counter
  JNZ  D55                                    ;Keep going until we're done
  JMP >D90                                    ;Done
D70:                                          ;Error
  MOV  ParseError,Yes                         ;Mark Error Flag
D90:                                          ;Done
  POP  DI,BX,AX                               ;Restore used registers
  POP  CX                                     ;Restoreused registers
  RET

;------------------------------------------------------------------------------
;Change ScanCode Typing Method
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchM:
  PUSH AX              ;Save used registers
  CALL SkipColonEquals ;Skip Colon/Equals (if there)
  CALL GetDecimal      ;Get the number
  JC  >M70             ;If no number, Error
  CMP  AX,3            ;Too big?
  JA  >M70             ;If so, error
  OR   AL,AL           ;Too small?
  JZ  >M70             ;If so, error
  CMP  ParseTest,Yes   ;Just the Test Run?
  JE  >M90             ;If so, don't store it yet
  MOV  ES:Method,AL    ;If for real, store it
  JMP >M90             ;Done
M70:                   ;Error
  MOV  ParseError,Yes  ;Mark as error
M90:                   ;Done
  POP  AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Add entry to User Translation Table
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchT:
  PUSH AX,BX           ;Save used registers
  XOR  BX,BX           ;Start table entry at 0
  CALL SkipColonEquals ;Skip Colon/Equals (if there)
  CALL GetDecimal      ;Get the number
  JC  >T70             ;If no number, error
  OR   AH,AH           ;Is it more than 255?
  JNZ >T70             ;If so, Error
  CMP  AL,RptKbdA      ;Is it a real USB Code?
  JB  >T70             ;If not, Error
  MOV  BL,AL           ;If OK, save it
  CALL SkipCommaDash   ;Skip Comma or Dash (if there)
  CALL GetScanCodeNums ;Get the ScanCode Code
  JC  >T70             ;If Error, quit
  MOV  BH,AL           ;If OK, put ScanCode in BH
  CMP  ParseTest,Yes   ;Is this just the test run?
  JE  >T90             ;If so, don't save it yet
  CALL PutUserEntry    ;If for real, store it
  JMP >T90             ;Done
T70:                   ;Error
  MOV  ParseError,Yes  ;Mark as an error
T90:                   ;Done
  POP  BX,AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;Add entry to User System Translation Table
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = ProgFlags
;         [SI] = Command Line Pointer
;         [BP] = TSRFlags
;          AH  = ParseTest, ZF Set if ParseTest = No
;------------------------------------------------------------------------------
DoSwitchY:
  PUSH AX,BX                ;Save used registers
  XOR  BX,BX                ;Start table entry at 0
  CALL SkipColonEquals      ;Skip Colon/Equals (if there)
  CALL GetDecimal           ;Get the number
  JC  >Y70                  ;If no number, error
  CMP  AX,RptGDSysPowerDown ;Is it valid?
  JB  >Y70                  ;If not, error
;  CMP  AX,RptGDSysMenuDown  ;Is it valid?
  CMP  AX,255               ;Is it valid?
  JA  >Y70                  ;If not, error
  MOV  BL,AL                ;If OK, save it
  CALL SkipCommaDash        ;Skip Comma or Dash (if there)
  CALL GetScanCodeNums      ;Get the ScanCode Code
  JC  >Y70                  ;If Error, quit
  MOV  BH,AL                ;If OK, put ScanCode in BH
  CMP  ParseTest,Yes        ;Is this just the test run?
  JE  >Y90                  ;If so, don't save it yet
  CALL PutUserSysEntry      ;If for real, store it
  JMP >Y90                  ;Done
Y70:                        ;Error
  MOV  ParseError,Yes       ;Mark as an error
Y90:                        ;Done
  POP  BX,AX                ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT ROUTINES FOR PROCESSING SWITCHES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;GET THE SCANCODE CODE FROM THE COMMAND LINE
;Inputs:  [SI] = Command Line Pointer
;Outputs: CF = Clear if OK (Valid ScanCode Entry)
;              AL = ScanCode (<128 if "normal", OR'd w/ 80h if 224 Prefix,
;                              225 if Pause)
;            = Set if Error
;              AL = Undefined
;Changes: SI
;------------------------------------------------------------------------------
GetScanCodeNums:
  PUSH BX            ;Save used registers
  MOV  BH,AH         ;Save original AH
  XOR  BL,BL         ;Start with 224 Prefix disabled
  CALL GetDecimal    ;Get a number
  JC  >M70           ;If no number, error
  OR   AX,AX         ;"Delete entry" Code?
  JZ  >M80           ;If so, handle it
  CMP  AX,128        ;Is it less than 128?
  JB  >M40           ;If so, handle it
  CMP  AL,225        ;Is it Pause?
  JE  >M30           ;If so, jump to handle it
  CMP  AL,224        ;Is it 224?
  JNE >M70           ;If not, error
  MOV  BL,80h        ;If so, mark it as 224
  CALL SkipCommaDash ;Skip Comma or Dash (if there)
  CALL GetDecimal    ;Get the number
  JC  >M70           ;If no number, error
  OR   AX,AX         ;Valid ScanCode?
  JZ  >M70           ;If not, Error
  CMP  AX,128        ;Is it less than 128?
  JAE >M70           ;If not, Error
  JMP >M40           ;If so, continue
M30:                 ;Is 225 (Pause)
  CALL SkipCommaDash ;Skip Comma or Dash (if there)
  CALL GetDecimal    ;Get the next number
  JC  >M70           ;If no number, error
  CMP  AX,29         ;Is it what it should be?
  JNE >M70           ;If not, error
  CALL SkipCommaDash ;Skip Comma or Dash (if there)
  CALL GetDecimal    ;Get the next number
  JC  >M70           ;If no number, error
  CMP  AX,69         ;Is it what it should be?
  JNE >M70           ;If not, error
  MOV  AL,225        ;ScanCode to store is 225
M40:                 ;AL contains ScanCode
  CMP  AL,224-80h    ;Problem ScanCode?
  JE  >M70           ;If so, Error
  CMP  AL,225-80h    ;Problem ScanCode?
  JE  >M70           ;If so, Error
  OR   AL,BL         ;Store the ScanCode
  JMP >M80           ;Done
M70:                 ;Error
  STC                ;Set Error Code
  JMP >M90           ;Done
M80:                 ;OK
  CLC                ;Set OK Code
M90:                 ;Done
  MOV  AH,BH         ;Restore original AH
  POP  BX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ADD/DELETE AN ENTRY TO THE USER OR USER SYSTEM TRANSLATION TABLE
;Inputs:  ES = TSR Data Area
;         BX = Entry to put in User Table
;              BL = USB Key Code
;              BH = ScanCode (0 = Delete existing entry)
;         CLD already issued
;Outputs: Adds/Deletes entry from UserUSBTable
;Changes:
;------------------------------------------------------------------------------
PutUserSysEntry:
  PUSH DX            ;Save used registers
  MOV  DL,-1         ;Mark as System Table
  JMP >P00           ;Do it
PutUserEntry:
  PUSH DX            ;Save used registers
  XOR  DL,DL         ;Mark as Regular USB Table
;  JMP >P00           ;Do it
P00:
  PUSH AX,DI,SI,DS   ;Save used registers
  MOV  DS,ES         ;Point DS at TSR Data Area
  MOV  AX,BX         ;Put USB/System Code in AL
  CALL FindUserEntry ;Is this code already in the Table (rtns SI)?
  JC  >P50           ;If not, put it in as a new entry
  OR   AH,AH         ;Are we deleting an entry?
  JNZ >P80           ;If not, jump to store it
P20:                 ;Delete an entry
  MOV  DI,SI         ;Point DI at the current Table entry
  INC  SI,2          ;Point SI at the next Table entry
P30:                 ;Loop to here for each Entry we're moving
  MOVSW              ;Copy the next entry to the previous entry
  CMP  W [DI],0      ;Did we just copy an empty entry?
  JNE  P30           ;If not, keep copying
  JMP >P90           ;If so, we're done
P50:                 ;Not in Table yet
  OR   AH,AH         ;Are we deleting an Entry?
  JZ  >P90           ;If so, we're done
  XOR  AL,AL         ;Look for an
  CALL FindUserEntry ;  empty table entry
  JC  >P90           ;If Table is full, quit
P80:                 ;Add the new entry to the Table
  MOV  [SI],BX       ;If OK, store the new Entry
P90:                 ;Done
  POP  DS,SI,DI,AX   ;Restore used registers
  POP  DX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND A PARTICULAR ENTRY IN THE USER TRANSLATION TABLE
;Inputs:  DS = ES = TSR Data Area
;         AL = USB Code to search for
;         DL =  0 if UserUSBTable
;            = -1 if UserSysTable
;Outputs: CF = Clear if OK (found a match)
;              [SI] = Table Entry that matches
;         CF = Set if Error (no match found)
;              SI = Undefined
;Changes:
;------------------------------------------------------------------------------
FindUserEntry:
  PUSH CX                ;Save used registers
  MOV  SI,UserUSBTable   ;Assume
  MOV  CX,UserTblEntries ;  USB Table
  OR   DL,DL             ;Is it the USB Table?
  JZ  >F10               ;If so, continue
  MOV  SI,UserSysTable   ;If not, it's the
  MOV  CX,UserSysEntries ;  System Table
F10:                     ;Loop to here for each Table Entry
  CMP  AL,[SI]           ;Does this entry match?
  JE  >F80               ;If so, we're done
  INC  SI,2              ;Point at next Table entry
  LOOP F10               ;Keep going until we're done
F70:                     ;Error (no match)
  STC                    ;Set Error flag
  JMP >F90               ;Done
F80:                     ;OK (found a match)
  CLC                    ;Set OK flag
F90:                     ;Done
  POP  CX                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET A YES/NO OPTION FOR A COMMAND-LINE SWITCH
;Inputs:  [SI] = Command Line Pointer
;Outputs: CF = Clear if OK
;              ZF = Set if No
;                   AL = 0 (No)
;                 = Clear if Yes
;                   AL = -1 (Yes)
;            = Set if Error
;              AL = 0
;Changes:
;------------------------------------------------------------------------------
GetYesNo4Switch:
  PUSH BX,CX              ;Save used registers
  MOV  CH,AH              ;Save original AH
  CALL SkipColonEquals    ;Skip Colon/Equals (if there)
  MOV  BX,SwitchListYesNo ;Point at the list of code words
  CALL GetCode            ;See if its a match
  JNC >Y20                ;If so, jump to test it
  CALL GetNextChar        ;If not, get a single character
  JZ  >Y70                ;If end-of-line, error
  CALL Capitalize         ;Capitalize it
Y20:                      ;Got a character
  CMP  AL,'Y'             ;Is it Yes?
  JE  >Y40                ;If so, handle it
  CMP  AL,'N'             ;Is it No?
  JNE >Y70                ;If not, error
Y30:                      ;No
  XOR  AL,AL              ;If so, make it No
  JMP >Y80                ;Done
Y40:                      ;Yes
  MOV  AL,Yes             ;Mark it as a Yes
  JMP >Y80                ;Done
Y70:                      ;Error
  XOR  AL,AL              ;Set AL to 0
  STC                     ;Set Error Flag
  JMP >Y90                ;Done
Y80:                      ;OK
  OR   AL,AL              ;Set Zero Flag for Return
  CLC                     ;Set OK Flag
Y90:                      ;Done
  MOV  AH,CH              ;Restore original AH
  POP  CX,BX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;HANDLE A SWITCH WITH A YES/NO OPTION
;Inputs:  [SI] = Command Line Pointer
;         ES = TSR Data Area
;         DS = Local Data Area
;         AL = Bit mask to Set/Unset
;         AH = ParseTest status
;Outputs: Sets/Unsets bit in ES:TSRFlags or DS:ProgFlags as appropriate
;Changes:
;NOTES: If we are changing the resident (TSR) part of the program
;         (ES:TSRFlags), we do not actually change anything unless
;         ParseTest is set to No.  If we are changing the transient
;         part of the program (DS:ProgFlags), we change it no matter
;         what ParseTest is set to.
;       Forward and Reverse refer to Forward and Reverse Logic.  With
;         Forward Logic, if the user says Yes, we set the particular bit
;         to 1.  With Reverse Logic, when the user says Yes, we set
;         to bit to 0.
;------------------------------------------------------------------------------
DoSwitchWithYNTsrRvs:
  PUSH CX                  ;Save used registers
  MOV  CL,-1               ;Mark as Reverse Logic
  JMP >Y000                ;Jump to do ES:TSRFlags
;DoSwitchWithYNTsrFwd:
;  PUSH CX                  ;Save used registers
;  XOR  CL,CL               ;Mark as Forward Logic
;  JMP >Y000                ;Jump to do ES:TSRFlags
;DoSwitchWithYNPrgRvs:
;  PUSH CX                  ;Save used registers
;  MOV  CL,-1               ;Mark as Reverse Logic
;  JMP >Y001                ;Jump to do DS:ProgFlags
DoSwitchWithYNPrgFwd:
  PUSH CX                  ;Save used registers
  XOR  CL,CL               ;Mark as Forward Logic
  JMP >Y001                ;Jump to do DS:ProgFlags
Y000:                      ;ES:TSRFlags
  PUSH BX                  ;Save used registers
  MOV  BX,OFFSET TSRFlags  ;Point at TSR Flags
  JMP >Y00                 ;Do it
Y001:                      ;DS:ProgFlags
  PUSH BX                  ;Save used registers
  MOV  BX,OFFSET ProgFlags ;Point at TSR Flags
;  JMP >Y00                 ;Do it
Y00:
  PUSH AX                  ;Save used registers
  MOV  CH,AL               ;Save Bit Mask to set
  CALL GetYesNo4Switch     ;Get the Yes/No parameter (AL)
  JC  >Y70                 ;If error, handle it
  OR   AL,AL               ;Is it Yes?
  JNZ >Y20                 ;If so, jump to handle it
Y10:                       ;No
  OR   CL,CL               ;Is it Forward Logic?
  JZ  >Y40                 ;If so, jump to handle it
  JMP >Y50                 ;If not, jump to handle Reverse Logic
Y20:                       ;Yes
  OR   CL,CL               ;Is it Forward Logic?
  JZ  >Y50                 ;If so, jump to handle it
Y40:                       ;Unset the Bit
  NOT  CH                  ;Need to Unset
  CMP  BX,LastTSRByte      ;Is it for ProgFlags?
  JAE >Y45                 ;If so, jump to handle it
Y42:                       ;Unset ES:TSRFlags
  OR   AH,AH               ;Just the Test Run?
  JNZ >Y90                 ;If so, quit
  AND  ES:[BX],CH          ;Unset the appropriate flag
  JMP >Y90                 ;Done
Y45:                       ;Unset DS:ProgFlags
  AND  [BX],CH             ;Unset the appropriate flag
  JMP >Y90                 ;Done
Y50:                       ;Set the Bit
  CMP  BX,LastTSRByte      ;Is it for ProgFlags?
  JAE >Y55                 ;If so, jump to handle it
Y52:                       ;Set ES:TSRFlags
  OR   AH,AH               ;Just the Test Run?
  JNZ >Y90                 ;If so, quit
  OR   ES:[BX],CH          ;Set the appropriate flag
  JMP >Y90                 ;Done
Y55:                       ;Set DS:ProgFlags
  OR   [BX],CH             ;Set the appropriate flag
  JMP >Y90                 ;Done
Y70:                       ;Error
  MOV  ParseError,Yes      ;Mark as an Error
Y90:                       ;Done
  POP  AX                  ;Restore used registers
  POP  BX                  ;Restore used registers
  POP  CX                  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;REPLACE THE CARRIAGE RETURN AT THE END OF THE CMD LINE TAIL WITH A 0
;Inputs:  CS = DS = PSP Segment
;Outputs:
;Changes: Last Byte of Command Tail
;------------------------------------------------------------------------------
FixCmdLineCR:
  PUSH AX,CX,DI,ES   ;Save used registers
  MOV  AL,CR         ;Look for a CR
  MOV  CX,7Fh        ;Maximize Byte Counter
  MOV  ES,DS         ;Point ES:[DI]
  MOV  DI,81h        ;  at the Command Line Tail
  REPNE SCASB        ;Look for the CR
  MOV  B ES:[DI-1],0 ;Replace the CR with a 0
  POP  ES,DI,CX,AX   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NEXT CHARACTER FROM THE ENVIRONMENT OR COMMAND LINE
;Inputs:  [SI] = Pointer (Command Line or Environment)
;Outputs: AL = The next character
;         ZF = Set if End-Of-Line (Character = ASCII 0)
;            = Clear if "real" character
;Changes: SI
;------------------------------------------------------------------------------
GetNextChar:
  PUSH DS                   ;Save used registers
  TEST ProgFlags2,DoStdIn   ;Are we doing StdIn?
  JNZ >N20                  ;If so, jumpto handleit
  TEST ProgFlags2,DoEnvir   ;Are we doing the Program Environment Variable?
  JNZ >N10                  ;If so, handle it
  CMP  CmdLineVarPointer,-1 ;Need to use the CMDLINE Environment variable?
  JE  >N90                  ;If not, just do the "real" command line
N10:                        ;Get next character from the Environment
  MOV  DS,[PSPEnvirSeg]     ;Point at the Environment Segment
  JMP >N90                  ;Continue
N20:                        ;StdIn
  MOV  DS,ExtraMemSegment   ;Poitn DS at the correct Segment
N90:                        ;DS:[SI] points at the next character
  LODSB                     ;Get the character from the "real" command line
  OR   AL,AL                ;Set ZF if EOL
  POP  DS                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SKIP OVER SPACES TO FIND THE NEXT LEGITIMATE CHARACTER, TESTING FOR EOL
;Inputs:  DS:[SI] = Command Line Pointer
;Outputs: ZF = Set if EOL
;               AL  = Unchanged
;              [SI] = End-of-Line Character
;            = Clear if not EOL
;               AL  = First non-space character
;              [SI] = Character AFTER the next non-space character
;Changes:
;------------------------------------------------------------------------------
IsSpaceOrEOX:
  CALL IsSpaceOrEOL ;Skip over the spaces
  JZ  >X90          ;If end-of-line, we're done
  CALL GetNextChar  ;If not, get the next character
  OR   AL,AL        ;Set return flag
X90:                ;Done
  RET

;------------------------------------------------------------------------------
;SKIP OVER SPACES TO FIND LEGITIMATE CHARACTERS, AND TEST FOR EOL
;Inputs:  DS:[SI] = Command Line Pointer
;Outputs: ZF = Set if EOL
;            = Clear if legitimate character
;              [SI] = The Next non-Space Character
;Changes:
;------------------------------------------------------------------------------
IsSpaceOrEOL:
  PUSH AX          ;Save used registers
L10:               ;Loop to here to skip over spaces
  CALL GetNextChar ;Get the next character
  CMP  AL,' '      ;Is it a space?
  JE   L10         ;If so, get the next character
  CMP  AL,Tab      ;Is it a Tab?
  JE   L10         ;If so, get the next character
  DEC  SI          ;If not, point back at the character
  OR   AL,AL       ;Set EOL flag
  POP  AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SKIP OVER A COLON OR EQUALS, IF THERE
;Inputs:  DS:[SI] = Command Line Pointer
;Outputs: CF = Clear if Colon or Equals was found (and skipped)
;              [SI] = First non-Space Character after the Colon/Equals
;            = Set if No Colon or Equals was found
;              [SI] = First non-Space Character after where we were looking
;Changes:
;------------------------------------------------------------------------------
SkipColonEquals:
  PUSH AX           ;Save used registers
  CALL IsSpaceOrEOX ;Skip over the Spaces
  JZ  >Q75          ;If End-of-Line, nothing to get
  CMP  AL,':'       ;Is it a Colon?
  JE  >Q80          ;If so, we're done
  CMP  AL,'='       ;Is it an equals?
  JE  >Q80          ;If so, we're done
Q70:                ;No Colon/Equals Found
  DEC  SI           ;Point back at the character
Q75:                ;[SI] correct
  STC               ;Set return flag
  JMP >Q90          ;Done
Q80:                ;Colon/Equals Found
  CALL IsSpaceOrEOL ;Go to the next character
  CLC               ;Set return flag
Q90:                ;Done
  POP  AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SKIP OVER A COMMA OR DASH, IF THERE
;Inputs:  DS:[SI] = Command Line Pointer
;Outputs: SI = Pointer to spot after the Comma, if there
;Changes:
;------------------------------------------------------------------------------
SkipCommaDash:
  PUSH AX           ;Save used registers
  CALL IsSpaceOrEOX ;Skip over the Spaces
  JZ  >M20          ;If EOL, go back
  CMP  AL,','       ;Is it a Comma?
  JE  >M40          ;If so, we're done
  CMP  AL,'-'       ;Is it a Dash?
  JE  >M40          ;If so, we're done
M20:                ;Need to move back to previous character
  DEC  SI           ;Point back at previous character
  JMP >M90          ;Done
M40:                ;Skip over spaces after the colon/equals
  CALL IsSpaceOrEOL ;Skip over the Spaces
M90:                ;Done
  POP  AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CONVERT A CODE WORD FROM THE COMMAND LINE TO A BYTE FROM THE LOOKUP TABLE
;Inputs:  DS:[SI] = Command Line Pointer
;         DS:[BX] = List to Test
;Outputs: CF = Clear if a match was found
;              AL = Entry from Table
;              [SI] = Next character after the Code Match
;         CF = Set if no match found (error)
;              AL = Unchanged
;              SI = Unchanged
;Changes: SI if valid match found
;------------------------------------------------------------------------------
GetCode:
  PUSH BX,DX         ;Save used registers
  MOV  DX,AX         ;Save AX in case there's no match
C10:                 ;Loop to here for each list of words
  CMP  B [BX],0      ;Are we at the end of our table?
  JE  >C80           ;If so, we couldn't find a match
  XOR  AH,AH         ;Assume it's a match
  PUSH SI            ;Save our command line pointer for a second
C20:                 ;Loop to here for each character in a word
  CALL GetNextChar   ;Get the next character
  CALL Capitalize    ;Capitalize it
  CALL CmpALBXNoCase ;Is it a match?
  JZ  >C30           ;If so, handle it
  INC  AH            ;If not, mark us as no match
C30:                 ;The character is tested
  INC  BX            ;Point at the next character in our test word
  CMP  B [BX],0      ;Are we at the end of the word?
  JNE  C20           ;If not, keep going until we're done
  INC  BX            ;Point at the next word or code list
  OR   AH,AH         ;Was it a match?
  JZ  >C50           ;If so, jump to handle it
  POP  SI            ;If not, restore our command line pointer
  CMP  B [BX],0      ;Is this the end of our word list?
  JNE  C10           ;If not, just test the next word
  INC  BX,2          ;If so, skip over the codes
  JMP  C10           ;Keep going until we're done with our list
C50:                 ;We've found a match!
  POP  AX            ;Lose our original command line pointer
  DEC  BX            ;Point back at the end-of-word marker
C60:                 ;Loop to here to find the end-of-list
  MOV  AX,[BX]       ;Get the next two characters in our list
  INC  BX            ;Point at the next character for next time
  OR   AX,AX         ;Is this the start of our code list?
  JNE  C60           ;If not, keep looking
  INC  BX            ;If so, point at the character we're looking for
  MOV  DL,[BX]       ;Get the character from the table
  CLC                ;Mark our OK flag
  JMP >C90           ;And we're done
C80:                 ;No match found
  STC                ;Mark us as no match
C90:                 ;We're done
  MOV  AX,DX         ;Set AX to the correct value
  POP  DX,BX         ;Restore used registers
  RET

CmpALBXNoCase:
  PUSH AX         ;Save used registers
  CALL Capitalize ;Capitalize AL
  MOV  AH,AL      ;Store it in AH
  MOV  AL,[BX]    ;Get [BX]
  CALL Capitalize ;Capitalize it
  CMP  AL,AH      ;Compare AL & [BX]
  POP  AX         ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE NEXT SERIES OF NUMERIC CHARACTERS, AND CONVERT THEM TO A NUMBER
;Inputs:  [SI] = Command Line Pointer
;Outputs: AX = decimal character string converted to a number, ?? if not
;         CF = Clear if AX is OK
;            = Set if no decimal found
;Changes:
;------------------------------------------------------------------------------
GetDecimal:
  PUSH BX,CX,DX     ;Save used registers
  XOR  AX,AX        ;Start with zero
  XOR  BX,BX        ;  "    "    "   - accumulator
  MOV  CX,10        ;CX = multiplier & digit limit comparer
  CALL IsSpaceOrEOX ;Skip over the spaces
  JZ  >D70          ;If EOL, Error
  SUB  AL,'0'       ;If not, convert it to a number
  CMP  AL,9         ;Is it really a number?
  JA  >D70          ;If not, there's an error
  DEC  SI           ;If so, step back to the number
D10:                ;Loop to here for each character
  CALL GetNextChar  ;Get the next character
  SUB  AL,'0'       ;Change it to 0-9 range
  XOR  AH,AH        ;Extend byte to word
  CMP  AX,CX        ;Is it a digit?
  JAE >D80          ;If not, we're done
  CMP  BX,6553      ;Is our number getting too big?
  JB  >D20          ;If not, jump to store it
  CMP  AL,5         ;If so, will this number make it too big?
  JA  >D70          ;If so, there's an error
D20:                ;Add the digit to our number
  XCHG AX,BX        ;Swap accumulation into AX, new digit into BX
  MUL  CX           ;Multiply the previous accumulation by 10
  ADD  BX,AX        ;Add in the new digit
  JMP  D10          ;Jump to get next character
D70:                ;There was an error
  STC               ;Mark the error flag
  JMP >D90          ;And quit
D80:                ;We have a good number
  DEC  SI           ;Point back at the non-number
  MOV  AX,BX        ;Put the value where it belongs
  CLC               ;Mark the OK flag
D90:                ;We're done
  POP  DX,CX,BX     ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE THE TELL THE USER WHERE THE COMMAND LINE ERROR OCCURRED
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;WRITE THE COMMAND LINE OR ENVIRONMENT ERROR INFORMATION TO THE SCREEN
;Inputs:  [SI] = Command line Pointer (if Command Line)
;              = StdIn Buffer Pointer (if StdIn String)
;              = Environment Pointer (if Environment Variable)
;         DoEnvir, DoStdIn
;Outputs:
;Changes: Writes information to screen
;------------------------------------------------------------------------------
WriteCmdErr:
  PUSH AX,BX,CX,DX        ;Save used registers
  PUSH DI,SI,BP           ;Save used registers
  CALL FindBadChar        ;Find the actual bad character in the string (SI)
  CALL SetupCmdErrStrings ;Set up the String Pointers and Sizes
                          ;DI:[AX] = Command Line String
                          ;DS:[BX] = Program name at beginning of String
                          ;    CX  = Size of BX String
                          ;DS:[DX] = Header String
                          ;DS:[BP] = Footer String
  CALL WriteZErr          ;Write the Header
  CALL WriteCrLfErr       ;Move
  CALL WriteCrLfErr       ;  down
  SUB  SI,AX              ;Calculate the number
  ADD  CX,SI              ;  of spaces
  DEC  CX                 ;  to write
  CALL WriteCmdString     ;Write the Command-line String (may modify CX)
  CALL WriteCrLfErr       ;Move down
  MOV  B SingleMsg[0],' ' ;Want to write spaces
  MOV  DX,SingleMsg       ;Point at the string
E60:                      ;Loop to here to write each space (number in CX)
  CALL WriteZErr          ;Write the space
  LOOP E60                ;Keep writing them until we're done
  MOV  DX,ParseErrMsg     ;Write the Pointer Part
  CALL WriteZErr          ;  of the Error Message
  MOV  DX,BP              ;Write the last part
  CALL WriteZErr          ;  of the message
  POP  BP,SI,DI           ;Restore used registers
  POP  DX,CX,BX,AX        ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GO BACKWARDS IN AN ERRORED OPTION STRING TO INDICATE TO USER WHERE ERROR WAS
;Inputs:  SI = Option String Pointer (Environment, StdIn, or Command Line)
;                where error was found
;Outputs: SI = Options String Pointer, adjusted to point at a "Real" character
;Changes:
;------------------------------------------------------------------------------
FindBadChar:
  PUSH AX          ;Save used registers
  DEC  SI          ;Go back 1 character to start
B10:               ;Loop to here to find a legitimate character
  CALL GetNextChar ;Get the character
  JZ  >B40         ;If end-of-line, keep going back
  CMP  AL,' '      ;Is it a space?
  JNE >B90         ;If not, we're done
B40:               ;Need to keep going back
  SUB  SI,2        ;Go back to the previous character
  JMP  B10         ;Keep looking
B90:               ;Done
  POP  AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SET UP THE STRING POINTERS AND SIZES TO BE ABLE TO WRITE THE COMMAND ERROR
;Inputs:  DS = Local Data Area
;Outputs: DI:[AX] = Command-line String to write
;         DS:[DX] = First Error Message (Header) to write
;         DS:[BX] = Second message to write (first part of Command string)
;             CX  = Number of Bytes to add to String Size
;         DS:[BP] = Third message to write (Footer)
;Changes:
;------------------------------------------------------------------------------
SetupCmdErrStrings:
  TEST ProgFlags2,DoEnvir   ;Working with the Environment?
  JNZ >S40                  ;If so, handle it
  TEST ProgFlags2,DoStdIn   ;Working with StdIn?
  JNZ >S50                  ;If so, handle it
S10:                        ;Command Line
  MOV  AX,81h               ;DI:[AX] =
  MOV  DI,DS                ;  Command-line Tail
  MOV  BX,RealName          ;DS:[BX] = Program Name
  MOV  CX,RealNameSz        ;CX = Size of [BX] String
  CMP  CmdLineVarPointer,-1 ;Real Command Line?
  JE  >S30                  ;If so, continue
S20:                        ;CMDLINE Environment Variable
  MOV  DI,[PSPEnvirSeg]     ;DI:[AX] =
  MOV  AX,CmdLineVarPointer ;  CMDLINE
  SUB  AX,CmdLineVarSize    ;  Environment Variable
S30:                        ;Have Command-line parameters set up
  MOV  DX,ParseCmdMsg       ;DS:[DX] = Header String
  MOV  BP,ParseErrMsg2      ;DS:[BP] = Footer String
  JMP >S90                  ;Done
S40:                        ;Environment
  MOV  DI,[PSPEnvirSeg]     ;DI:[AX] =
  MOV  AX,EnvVarPointer     ;  USBKEYB
  SUB  AX,EnvVarSize        ;  Environment Variable
  MOV  BX,NoMsg             ;DS:[BX] = Second message to write
  XOR  CX,CX                ;CX = Size of [BX] String
  MOV  DX,ParseEnvMsg       ;DS:[DX] = Header String
  MOV  BP,ParseEnvMsg2      ;DS:[BP] = Footer String
  JMP >S90                  ;Done
S50:                        ;StdIn
  MOV  DI,ExtraMemSegment   ;DI:[AX] =
  XOR  AX,AX                ;  StdIn Buffer
  MOV  BX,NoMsg             ;DS:[BX] = Second message to write
  XOR  CX,CX                ;CX = Size of [BX] String
  MOV  DX,ParseStdInMsg     ;DS:[DX] = Header String
  MOV  BP,ParseErrMsg2      ;DS:[BP] = Footer String
S90:                        ;Done
  RET

;------------------------------------------------------------------------------
;WRITE THE CONTENTS OF THE COMMAND STRING, WITH MORE MESSAGES AS NEEDED
;Inputs:  CS = DS = Local Data Area
;         DS:[BX] = First String to write (may not be needed!)
;         DI:[AX] = Second String (main part) to write
;             CX  = Number of Spaces to write at beginning (if normal)
;Outputs: CX = Adjusted number of spaces to write
;Changes:
;------------------------------------------------------------------------------
WriteCmdString:
  PUSH AX,BX,DX,DI,SI      ;Save used registers
  PUSH BP,DS,ES            ;Save used registers
  MOV  BP,CX               ;Save the original Space Counter in BP
  MOV  ES,DI               ;Save the second string Pointer
  MOV  SI,AX               ;  in ES:[SI]
  MOV  DX,BX               ;Save the length
  CALL CalcStrSizeDX       ;  of the first string
  MOV  DI,CX               ;  in DI
  MOV  DS,ES               ;Save the length
  CALL CalcStrSizeSI       ;  of the second string
  MOV  AX,CX               ;  in AX
  CMP  BP,70               ;Are there too many spaces to fit on one line?
  JBE >G20                 ;If not, continue
G10:                       ;Need to lop off the beginning
  SUB  BP,DI               ;We will not be
  XOR  DI,DI               ;  writing the
  MOV  BX,NoMsg            ;  first string
  CMP  BP,70               ;Are there still too many spaces to fit?
  JBE >G20                 ;If not, continue
  MOV  BX,MoreLeftMsg      ;Point at the More Message
  ADD  BP,MoreMsgSize      ;Compensate number of spaces for More Message
  MOV  DI,60               ;We want the number of spaces to be 60
  SUB  DI,BP               ;Calculate how far into the Second string
  NEG  DI                  ;  we need to start to accomplish that
  MOV  BP,59               ;BP = New Number of Spaces
  ADD  SI,DI               ;  where we need to start writing
  SUB  AX,DI               ;  of second string
  MOV  DI,MoreMsgSize      ;DI = Size of new first string (More Message)
G20:                       ;Beginning of line is accounted for
  MOV  DS,CS               ;Write the
  MOV  DX,BX               ;  first
  CALL WriteZErr           ;  string
  MOV  DS,ES               ;Point DS:[DX] at the
  MOV  DX,SI               ;  second string
  ADD  DI,AX               ;Calculate total length of both strings
  CMP  DI,79               ;Will it fit on one line?
  JBE >G40                 ;If so, continue
  MOV  BX,(80-MoreMsgSize) ;Calculate how many characters
  SUB  BX,DI               ;  of the second string
  ADD  BX,AX               ;  we need to write
  MOV  AL,[SI+BX]          ;Save the old character in the string
  MOV  B [SI+BX],0         ;Convert it to an end-of-string character
  CALL WriteZErr           ;Write the truncated string
  MOV  [SI+BX],AL          ;Restore the original character of the string
  MOV  DS,CS               ;Write the
  MOV  DX,MoreRightMsg     ;  More Message
G40:                       ;Write last message
  CALL WriteZErr           ;Write it
G90:                       ;Done
  MOV  CX,BP               ;Return CX = number of spaces to write
  POP  ES,DS,BP            ;Restore used registers
  POP  SI,DI,DX,BX,AX      ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;MISCELLANEOUS COMMAND-LINE RELATED STUFF
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;GET OUR REAL PROGRAM NAME
;Inputs:
;Outputs: RealName, RealNameSz
;Changes:
;------------------------------------------------------------------------------
GetRealName:
  PUSH AX,CX,DI,SI      ;Save used registers
  PUSH DS,ES            ;Save used registers
  MOV  DS,[PSPEnvirSeg] ;Point DS and ES
  MOV  ES,DS            ;  at the environment segment
  XOR  DI,DI            ;Point at the beginning of Environment variable list
  MOV  CX,-1            ;Max out the count limiter
  XOR  AX,AX            ;Need to look for a double 0
N10:                    ;Loop to here to skip over environment variables
  REPNE SCASB           ;Look for the end of this environment variable
  CMP  B [DI],0         ;Is it the end of the variable list (double zero)?
  JNE  N10              ;If not, keep skipping over environment variables
  CMP  W [DI+1],0       ;If so, is there at least one string after the env?
  JE  >N90              ;If not, we're done
  LEA  SI,[DI+3]        ;If so, point DS:[SI] at the True Name
  MOV  ES,CS            ;Point ES (for ES:[DI]) at our local data
N20:                    ;Loop to here to skip over drive/path info
  MOV  DI,RealName      ;Point at the beginning of our data area
  XOR  CX,CX            ;Start the length counter at 0
N30:                    ;Loop to here for each character in the name
  LODSB                 ;Get the next character of the name
  CMP  AL,'.'           ;Is it a dot?
  JE  >N40              ;If so, we may have the name
  CMP  AL,BackSlash     ;Is it a path separator?
  JE   N20              ;If so, start looking for the name again
  CALL Capitalize       ;If part of a name, capitalize the character
  STOSB                 ;Store it in our data area
  INC  CX               ;Increment the size counter
  JMP  N30              ;And keep looking for more characters
N40:                    ;We may have the name
  LODSB                 ;Get the next character of the name
  OR   AL,AL            ;End of the name?
  JZ  >N50              ;If so, it really was our program name
  CMP  AL,BackSlash     ;Was it a Directory with a dotted name?
  JE   N20              ;If so, keep looking for a file name
  JMP  N40              ;If not, keep looking for the end of the name
N50:                    ;Have the name
  XOR  AL,AL            ;Store
  STOSB                 ;  a 0
  MOV  CS:RealNameSz,CX ;Store the Size
N90:                    ;We're done
  POP  ES,DS            ;Restore used registers
  POP  SI,DI,CX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE POINTERS TO THE ENVIRONMENT VARIABLES WE NEED
;Inputs:  CS = DS = Local Data Area (also PSP Data Area)
;Outputs: Various Environment Pointers
;Changes:
;------------------------------------------------------------------------------
GetEnvVars:
  PUSH BX,CX,SI                    ;Save used registers
  MOV  SI,PathVarString1           ;Get
  MOV  BX,OFFSET PathVarPointer    ;  the
  MOV  CX,PathVarSize              ;  PATH
  CALL GetEnvVarPointer            ;  Pointer
  JNZ >V20                         ;If OK, continue
  MOV  SI,PathVarString2           ;If no, try
  CALL GetEnvVarPointer            ;  "Path" instead of "PATH"
V20:                               ;Get Program Variable
  MOV  SI,EnvVarString             ;Get
  MOV  BX,OFFSET EnvVarPointer     ;  our
  MOV  CX,EnvVarSize               ;  Program Variable
  CALL GetEnvVarPointer            ;  Pointer
V50:                               ;Get CMDLINE string
  CMP  B [80h],7Eh                 ;Is command line size maxed out?
  JB  >V90                         ;If not, don't worry about CMDLINE Env Var
  MOV  SI,CmdLineVarString         ;Get
  MOV  BX,OFFSET CmdLineVarPointer ;  the
  MOV  CX,CmdLineVarSize           ;  CMDLINE
  CALL GetEnvVarPointer            ;  Pointer
  CALL AdjustCmdLine               ;Compensate CMDLINE Pointer for Program Name
V90:                               ;Done
  POP  SI,CX,BX                    ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE POINTER TO AN ENVIRONMENT VARIABLE
;Inputs:   CS = DS = Local Data Area (also contains PSP)
;         [BX] = Where to store the Pointer at
;          CX  = Length of String
;         [SI] = Environment Variable String to Look for (ends in =)
;Outputs: ZF = Set if Error (Variable not found)
;               [BX] = -1
;             = Clear if OK (variable was found)
;               [BX] = Pointer to String (in Environment Segment, NOT PSP!!)
;Changes:
;------------------------------------------------------------------------------
GetEnvVarPointer:
  PUSH AX,CX,SI,BP      ;Save used registers
  PUSH DS,ES            ;Save used registers
  MOV  W [BX],-1        ;Default = -1 (does not exist)
  MOV  ES,[PSPEnvirSeg] ;ES:[DI] =
  XOR  DI,DI            ;  Environment Variable List
  MOV  DX,CX            ;Save the Size
  MOV  BP,SI            ;Save the original Pointer
  XOR  AL,AL            ;Need to look for 0's
V10:                    ;Loop to here for each Environment variable
  MOV  CX,DX            ;CX = Number of bytes to test
  MOV  SI,BP            ;DS:[SI] = String to Test for
  REPE CMPSB            ;Is it a match?
  JZ   >V30             ;If so, continue
  MOV  CX,-1            ;Max out the count limiter
  REPNE SCASB           ;Look for the end of this environment variable
  CMP  B ES:[DI],AL     ;End of Environment?
  JNE  V10              ;If not, keep looking
  JMP >V90              ;If so, no variable
V30:                    ;Found it!
  MOV  [BX],DI          ;Store the Pointer
V90:                    ;Done
  CMP  W [BX],-1        ;Set return flag
  POP  ES,DS            ;Restore used registers
  POP  BP,SI,CX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;ADJUST THE CMDLINE ENVIRONMENT VARIABLE POINT TO POINT AT THE COMMAND TAIL
;Inputs:  DS = Local Data Area (and PSP Segment)
;         CmdLineVarPtr (-1 if does not exist)
;           Unadjusted for Program Path/Name
;Outputs: CmdLineVarPtr
;           Adjusted (Program Path/Name skipped over to leave Command Tail)
;Changes:
;NOTES: The CMDLINE environment variable, which is only set by SOME
;         versions of DOS, contains the entire contents of the command
;         line.  The "entire contents" includes our executable file name
;         (including the path, if it was provided), but does not include
;         the redirection and/or piping parameters.
;       This routine skips over the executable file name part and simply
;         points at the command tail (the "Options" part of the command line).
;       The CMDLINE variable is used by some versions of DOS (such as 4DOS/NDOS
;         and DOS 95) to allow the command-line to be longer than the 126
;         characters normally allowed by DOS.
;------------------------------------------------------------------------------
AdjustCmdLine:
  PUSH AX,DX,SI,DS             ;Save used registers
  MOV  SI,CmdLineVarPointer    ;[SI] = CMDLINE environment variable contents
  CMP  SI,-1                   ;Anything there?
  JE  >J90                     ;If not, no need for changes
  MOV  DL,"/"                  ;Assume Get SwitchChar function is unsupported
  MOV  AX,3700h                ;Function 3700h (Get DOS SwitchChar)
  INT  21h                     ;Do it (returns DL)
  MOV  DS,[PSPEnvirSeg]        ;DS:[SI] = CMDLINE contents
J10:                           ;Loop to here to skip initial spaces & tabs
  LODSB                        ;Get the next character
  CMP  AL,' '                  ;Space?
  JE   J10                     ;If so, keep skipping
  CMP  AL,Tab                  ;Tab?
  JE   J10                     ;If so, keep skipping
J20:                           ;Skipped initial Tabs & Spaces
  DEC  SI                      ;Point back at the first character
  XOR  AH,AH                   ;Assume no quotes
  CMP  AL,Quote2               ;Double Quote (part of LFN Path & File Name)?
  JNE >J30                     ;If not, continue
  MOV  AH,AL                   ;If so, mark as a quote
  INC  SI                      ;Update the Pointer
J30:                           ;Loop to here for each character
  LODSB                        ;Get next character
  OR   AH,AH                   ;Are we looking for a Quoted Path/File Name?
  JZ  >J40                     ;If not, continue
J35:                           ;Looking for the Closing Quote
  CMP  AL,AH                   ;Is it the Closing Quote?
  JNE >J50                     ;If not, keep looking
  JMP >J85                     ;If so, we're done
J40:                           ;Not a Quoted Path/File Name
  OR   AL,AL                   ;End of variable?
  JE  >J80                     ;If so, handle it
  CMP  AL,' '                  ;Space?
  JE  >J80                     ;If so, we're done
  CMP  AL,Tab                  ;Tab?
  JE  >J80                     ;If so, we're done
  CMP  AL,'/'                  ;Slash?
  JE  >J80                     ;If so, we're done
  CMP  AL,DL                   ;SwitchChar?
  JE  >J80                     ;If so, we're done
J50:                           ;Not end-of-name
  JMP  J30                     ;Keep looking
J80:                           ;[SI-1] = CMDLINE Pointer
  DEC  SI                      ;Point at beginning of string
J85:                           ;[SI] = New CMDLINE Pointer
  MOV  CS:CmdLineVarPointer,SI ;Store it
J90:                           ;Done
  POP  DS,SI,DX,AX             ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE ENVIRONMENT VARIABLE CONTENTS TO THE SCREEN
;Inputs:  EnvVarPointer (-1 if no Environment variable exists)
;Outputs:
;Changes: Writes to CON or ERR
;------------------------------------------------------------------------------
WriteEnvCon:
  CMP  EnvVarPointer,-1 ;Is there even an Environment variable to write?
  JE  >W90              ;If not, we're done
  PUSH DX,DS            ;Save used registers
  MOV  DX,EnvVarPointer ;Point at the
  SUB  DX,EnvVarSize    ;  beginning of the Variable
  MOV  DS,[PSPEnvirSeg] ;Point at the Environment Segment
  CALL WriteZPause      ;Write it
  POP  DS,DX            ;Restore used registers
W90:                    ;We're done
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO WRITE SPECIAL MESSAGES TO THE SCREEN (HELP, STATUS, ETC.)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
;Write Program Help Message
;ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ

;------------------------------------------------------------------------------
;PRINT THE SYNTAX HELP MESSAGE AND QUIT
;Inputs:  DS:[SI] = Current command line pointer
;Outputs: Writes Help Message to the screen
;Changes: Quits program
;------------------------------------------------------------------------------
DoHelp:
  TEST ProgFlags2,Help ;Does the user want help?
  JZ  >H90             ;If not, we're done
  MOV  DX,SyntaxMsgHdr ;Write the first part
  CALL WriteZPause     ;  of the Help Message
  MOV  DX,RealName     ;Write the
  CALL WriteZPause     ;  Real Program Name
  CALL WriteSpace      ;Write a space
  MOV  DX,SyntaxMsg    ;Point at the last part of the Help Message
  XOR  AL,AL           ;ErrorLevel = 0
  JMP  Exit            ;Quit
H90:                   ;No need to do help
  RET


;ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
;WRITE BAD DEVICE LIST
;ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ

;------------------------------------------------------------------------------
;PRINT THE BAD DEVICE TABLE AND QUIT
;Inputs:  DS:[SI] = Current command line pointer
;         ES = TSR Data Area
;Outputs: Writes contents of Bad Device Table to the screen
;Changes: Quits program
;         Lots of Registers
;------------------------------------------------------------------------------
DoBadDevices:
  TEST StatusFlags,BadDevices ;Does the user want the Bad Device List?
  JZ  >B000                   ;If not, we're done
  TEST ProgFlags,InMemory     ;Are we installed in memory yet?
  JNZ >B00                    ;If so, continue
  MOV  DX,BadDvcErrMsg        ;If not, point at the first part of Error Message
  JMP  FinishDataErr          ;Terminate program
B000:
  RET

B00:                               ;Write it
  MOV  DX,BadBeepMsg               ;Write the
  CALL WriteZPause                 ;  Beep Header
  MOV  DX,YesMsg                   ;Assume Yes
  TEST ES:TSRFlags,NoBeep          ;Is it Yes?
  JZ  >B05                         ;If so, continue
  MOV  DX,NoMsgS                   ;If not, point at No Message
B05:                               ;Have Beep Status Message
  CALL WriteZPause                 ;Write the Beep Status
  CALL WriteCrLfPause2             ;Move down
  MOV  DX,BadDeviceHdr             ;Write the
  CALL WriteZPause                 ;  Header
  CALL TestSupportFile             ;Look for the Support File in the Path
  XOR  BL,BL                       ;Start Bad Counter at 0
  MOV  SI,BadDeviceTable           ;Point at Bad Table
  MOV  CX,MaxBadDevices            ;Number of Table Entries
B10:                               ;Loop to here for each table entry
  TEST ES:[SI].BDFlags,BDFlagInUse ;Valid Entry?
  JZ  >B40                         ;If not, skip it
  INC  BL                          ;Increment Bad Counter
  CALL WriteSpace                  ;Write
  MOV  AL,ES:[SI].BDHostIndex      ;  the
  CALL ByteToString                ;  Host Index
  CALL Write3Spaces                ;Write
  MOV  AL,ES:[SI].BDDvcAddress     ;  the
  CALL ByteToString                ;  Device Address
  CALL Write3Spaces                ;Write
  MOV  AL,ES:[SI].BDInterfaceNum   ;  the
  CALL ByteToString                ;  Interface Number
  CALL WriteBadStage               ;Write the Stage details
B40:                               ;Go to next entry
  ADD  SI,BadDeviceStrucSize       ;Point at next Entry
  LOOP B10                         ;Keep going until we're done
  OR   BL,BL                       ;Were there any Bad Devices?
  JNZ >B70                         ;If so, we're done
  MOV  DX,NoneFoundMsg             ;If not, write
  CALL WriteZPause                 ;  "None Found" Message
B70:                               ;Done
  MOV  DX,NoMsg                    ;Write nothing when done
  XOR  AL,AL                       ;ErrorLevel=0
  JMP  Exit                        ;And QUIT

;------------------------------------------------------------------------------
;WRITE THE BAD STAGE INFORMATION TO THE SCREEN
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [SI] = Bad Device Table Entry
;                Already checked for Validity (BDFlagInUse = True)
;                Host Index, Device Address, & Interface Number alread written
;Outputs: Write Try, Stage, and Error Code Numbers to the Table
;Changes:
;------------------------------------------------------------------------------
WriteBadStage:
  PUSH AX,CX                       ;Save used registers
  CALL Write2Spaces                ;Move over
  XOR  AH,AH                       ;Write the
  MOV  AL,ES:[SI].BDNewDeviceStage ;  Stage
  CALL WordToString                ;  Number
  CALL Write2Spaces                ;Move over
  MOV  CX,ES:[SI].BDNewDeviceError ;Write the
  CALL WriteBadError               ;  Error Code
  CALL WriteCrLfPause              ;Move down
  POP  CX,AX                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE ERROR CODE ND APPROPRIATE DESCRIPTION TO THE SCREEN
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;         AL = Stage Number
;         CX = Error Code to write
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteBadError:
  PUSH AX,DX            ;Save used registers
  XCHG AX,CX            ;AX = Error Code, CL = Stage
  CALL WriteWordHex     ;Write the Error Code
  CALL WriteHexEnd      ;Write an h
  CMP  CL,200           ;Is the stage more than 200?
  JAE >E90              ;If so, the Error Code is meaningless
  CALL WriteSpace       ;Move over
  TEST ProgFlags,FoundSuptFile ;Is there a Support File in the Path?
  JNZ >E20              ;If so, continue
E10:                    ;No Support File
  MOV  DX,NoSuptFileMsg ;If not, write first part
  CALL WriteZPause      ;  of Error Message
  MOV  DX,SupportFile   ;Write the Support
  CALL WriteZPause      ;  File Name
  JMP >E90              ;Done
E20:                    ;OK to call support File
  TEST CL,1             ;Is it even (TD Status) or odd (Int 14h Error)?
  JZ  >E50              ;If Even, jump to handle it
E40:                    ;Int 14h Error Code (Stage is Odd)
  CALL WriteInt14Err    ;Write the Int 14h Error Code
  JMP >E90              ;Done
E50:                    ;TD Status Code (Stage is Even)
  CALL WriteTDStsErr    ;Write the TD Status Error Code
E90:                    ;Done
  POP  DX,AX            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE TD STATS OR INT 14H ERROR DESCRIPTION TO THE SCREEN
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;         AX = TD Status Code to write
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
WriteTDStsErr:
  PUSH BX,CX,DX           ;Save used registers
  MOV  BX,TDStatusCode    ;[BX] = Where to write Code Number
  MOV  CX,TDStatusCallBk  ;[CX] = Where to write Screen-writing Address
  MOV  DX,TDStatusMsg     ;[DX] = Start of command-tail string
  JMP >R00                ;Do it
WriteInt14Err:
  PUSH BX,CX,DX           ;Save used registers
  MOV  BX,Int14ErrCode    ;[BX] = Where to write Code Number
  MOV  CX,Int14ErrCallBk  ;[CX] = Where to write Screen-writing Address
  MOV  DX,Int14ErrMsg     ;[DX] = Start of command-tail string
;  JMP >R00               ;Do it
R00:
  PUSH AX                 ;Save used registers
  CALL WriteWordToString  ;Write the Error Code to our string
  MOV  BX,CX              ;Write our
  MOV  AX,CS              ;  screen-writing
  MOV  CX,WriteZPauseFar  ;  code address
  CALL WriteSegmentOffset ;  to the string
  MOV  BX,DX              ;Copy our String
  CALL CopyToCmdTail      ;  to the Command Tail String
  CALL DoExec             ;Write the Description
  POP  AX                 ;Restore used registers
  POP  DX,CX,BX           ;Restore used registers
  RET


;ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
;WRITE RAW KEYBOARD DATA
;ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ

;------------------------------------------------------------------------------
;PRINT THE RAW DATA TO THE SCREEN AND QUIT
;Inputs:  DS:[SI] = Current command line pointer
;         ES = TSR Data Area
;         TSRFlags
;Outputs: Writes Raw Data to Screen
;Changes: Quits program
;         Lots of Registers
;------------------------------------------------------------------------------
DoRawData:
  TEST StatusFlags,RawData ;Does the user want the Raw Data?
  JZ  >W000                ;If not, we're done
  TEST ProgFlags,InMemory  ;If so, are we installed in memory yet?
  JNZ >W00                 ;If so, show the data
  MOV  DX,RawDataErrMsg    ;Point at first part of Error Message
  JMP  FinishDataErr       ;Termiante Program
W000:
  RET

W00:
  MOV  AL,ErLvlNoDevice             ;Assume no
  MOV  DX,NoDeviceMsg               ;  Devices installed yet
  CALL TestKeybFoundES              ;Any USB Keyboards installed?
  JC  >W80                          ;If not, error
W05:                                ;Have at least one keyboard
  CALL ChangeFunkyInts              ;Change Ctrl-Break, Ctrl-C, and PrtScr
  OR   ProgFlags2,Write2Err         ;Write to Error instead of CON/Pause
  OR   ES:TSRFlags,DisableAll       ;Don't allow keystrokes to be typed
  CALL HideCursor                   ;Hide the Cursor
  MOV  DX,RawDataHdr                ;Write the
  CALL WriteZErr                    ;  Header
  CALL GetCursor                    ;Get Cursor Position (BH=Row,BL=Col)
  SUB  BH,MaxDevices                ;Go
  CALL PutCursor                    ;  back up
  MOV  BP,BX                        ;Save starting Cursor position
  CALL FlushKbdBuff                 ;Flush the Keyboard Buffer
W10:                                ;Loop to here to write keyboards
  XOR  CL,CL                        ;Start with Index 0
  MOV  BX,BP                        ;Put the Cursor
  CALL PutCursor                    ;  at the top of the Table
W20:                                ;Loop to here for each Keyboard
  CALL DIIndex2Offset               ;Convert Index to Offset (DI)
  CALL WriteRawKeyb                 ;Write the Data for this keyboard
  INC  CL                           ;Increment Index
  CMP  CL,MaxDevices                ;Done all of the keyboards yet?
  JB   W20                          ;If not, continue
  CALL Write2Spaces                 ;Overwrite possible ^C
W60:                                ;Loop to here to flush keystrokes
  CALL GetKey                       ;Any Keys from real Keyboard?
  JZ  >W65                          ;If not, continue
  CMP  AL,Escape                    ;If so, is it the Escape key?
  JNE  W60                          ;If not, keep looking for real keystrokes
  CALL FlushKbdBuff                 ;If so, get rid of the rest ofthe keystrokes
  JMP >W70                          ;Done
W65:                                ;No Escape key from real keyboard
  TEST StatusFlags,RawEscRelease    ;Esc Key pressed and released?
  JZ   W10                          ;If not, keep writing
W70:                                ;Done
  CALL ShowCursor                   ;Show the Cursor
  CALL RestoreFunkyInts             ;Restore Ctrl-Break, Ctrl-C, and PrtScr
  AND  ES:TSRFlags,(NOT DisableAll) ;Allow keystroke typing again
  AND  ProgFlags2,(NOT Write2Err)   ;Write to Pause again
  XOR  AL,AL                        ;ErrorLevel=0
  MOV  DX,NoMsg                     ;Write nothing
W80:                                ;Done, quit program
  JMP  Exit                         ;And QUIT
W90:                                ;No need to do help
  RET

;------------------------------------------------------------------------------
;WRITE RAW DATA FOR A SINGLE KEYBOARD
;Inputs:  ES = TSR Data Area
;         CL = Device Info Index
;         [DI] = Device Info Entry
;         ProgFlags.Write2Err already set
;Outputs:
;Changes: StatusFlags.RawEscPress, StatusFlags.RawEscRelease
;------------------------------------------------------------------------------
WriteRawKeyb:
  PUSH AX,CX,DI                      ;Save used registers
  TEST ES:[DI].DIFlags,DIFlagInUse   ;A valid keyboard?
  JZ  >K901                          ;If not, quit
;  CALL WriteSpace                    ;Move over
  MOV  AL,CL                         ;Write the
;  CALL ByteToString                  ;  Keyboard Index
  CALL WriteByteMin                  ;  Keyboard Index
;  CALL Write2Spaces                  ;Move over
  CALL WriteSpace                    ;Move over
  MOV  AL,ES:[DI].DIHostIndex        ;Get the Host Index
  CMP  AL,10                         ;More than 10?
  JAE >K10                           ;If so, continue
  CALL WriteSpace                    ;If not, write a space
K10:                                 ;Spacing handled
  CALL WriteByteMin                  ;Write the Host Index
;  CALL ByteToString                  ;  Host Index
  CALL WriteSpace                    ;Move over
  MOV  AL,ES:[DI].DIDvcAddress       ;Write the
  CALL ByteToString                  ;  Device Address
  CALL WriteSpace                    ;Move over
  MOV  AL,ES:[DI].DIInterfaceNum     ;Write the
;  CALL ByteToString                  ;  Interface Number
  CALL WriteByteMin                  ;  Interface Number
  CALL Write3Spaces                  ;Move over
;  CALL WriteSpace                    ;Move over
  MOV  CX,MaxKeybDataSize            ;CX = Number of keystrokes to write
  ADD  DI,(OFFSET DIStsData)         ;Point SI at Raw Status Data
  TEST StatusFlags,RawEscPress       ;Escape key pressed?
  JNZ >K20                           ;If so, handle it
  CMP  B ES:[DI],0                   ;Any shift keys pressed?
  JNE >K50                           ;If so, continue
  CMP  B ES:[DI+2],RptKbdEscape      ;Escape Key?
  JNE >K50                           ;If not, continue
  CMP  B ES:[DI+3],0                 ;Lone Escape Key?
  JNE >K50                           ;If not, continue
  OR   StatusFlags,RawEscPress       ;If so, make it as pressed
  JMP >K50                           ;Continue
K901:                                ;To avoid JMP > 128
  JMP >K90                           ;Done
K20:                                 ;Escape Key already pressed
  CMP  B ES:[DI],0                   ;Any shift keys pressed?
  JNE >K30                           ;If so, handle it
  CMP  B ES:[DI+2],RptKbdEscape      ;Still pressed?
  JE  >K25                           ;If so, handle it
  CMP  B ES:[DI+2],0                 ;Released?
  JNE >K30                           ;If not, handle it
  OR   StatusFlags,RawEscRelease     ;If so, mark it as released
  JMP >K50                           ;Continue
K25:                                 ;Still pressed
  CMP  B ES:[DI+3],0                 ;Any other keys pressed now?
  JE  >K50                           ;If not, keep waiting
K30:                                 ;Other keys pressed!
  AND  StatusFlags,(NOT RawEscPress) ;Mark Esc as not pressed any more
K50:                                 ;Loop to here for each raw key
  CALL WriteSpace                    ;Move over
  MOV  AL,ES:[DI]                    ;Get the Keystroke
  INC  DI                            ;Increment Pointer
;  CMP  CX,(MaxKeybDataSize-1)        ;Second Byte (the one to skip)?
;  JE  >K55                           ;If so, don't write it
  CALL ByteToString                  ;Write the Keystroke Value
;K55:                                 ;Done writeng keystroke
  LOOP K50                           ;Keep writing until we're done
  CALL WriteCrLfPause                ;Start a new line
K90:                                 ;Done
  POP  DI,CX,AX                      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CHANGE INTERRUPTS 05h (PrintScreen), 1Bh (Ctrl-Break), AND 23h (Ctrl-C)
;  TO OUR CODE
;Inputs:
;Outputs:
;Changes: Interrupt 05h, 1Bh, and 23h to our code
;------------------------------------------------------------------------------
ChangeFunkyInts:
  PUSH AX,DI          ;Save used registers
  MOV  AL,05h         ;Work with Interrupt 05h (PrtScr)
  MOV  DI,Int05RawHdr ;Point to the storage area
  CALL ChangeInt      ;Change it to ours
  MOV  AL,1Bh         ;Work with Interrupt 1Bh (Ctrl-Break)
  MOV  DI,Int1BRawHdr ;Point to the storage area
  CALL ChangeInt      ;Change it to ours
  MOV  AL,23h         ;Work with Interrupt 23h (Ctrl-C)
  MOV  DI,Int23RawHdr ;Point to the storage area
  CALL ChangeInt      ;Change it to ours
  POP  DI,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;RESTORE INTERRUPTS 05h (PrintScreen), 1Bh (Ctrl-Break), AND 23h (Ctrl-C)
;  TO ORIGINAL CODE
;Inputs:
;Outputs:
;Changes: Interrupt 05h, 1Bh, and 23h back to original code
;------------------------------------------------------------------------------
RestoreFunkyInts:
  PUSH AX,DI,ES       ;Save used registers
  MOV  ES,DS          ;Make sure ES = Local Data Area
  MOV  AL,23h         ;Work with Interrupt 23h
  MOV  DI,Int23RawHdr ;Point to the storage area
  CALL RestoreInt     ;Change it back to original
  MOV  AL,1Bh         ;Work with Interrupt 1Bh
  MOV  DI,Int1BRawHdr ;Point to the storage area
  CALL RestoreInt     ;Change it back to original
  MOV  AL,05h         ;Work with Interrupt 05h
  MOV  DI,Int05RawHdr ;Point to the storage area
  CALL RestoreInt     ;Change it back to original
  POP  ES,DI,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET CURRENT VIDEO PAGE
;Inputs:
;Outputs: BH = Current video Page
;Changes: VPage, if not already calcualted done yet
;------------------------------------------------------------------------------
GetVideoPage:
  PUSH AX           ;Save used registers
  MOV  AL,VideoPage ;Get the current stored page number
  CMP  AL,-1        ;Have we already calculated the Video Page?
  JNE >V90          ;If so, we're done
  PUSH BX           ;If not, save used registers
  MOV  AH,0Fh       ;Service 0F (Get current video state)
                    ;Returns AH = Screen Width, AL = Display Mode, BH = Active Page
  INT  10h          ;Do It
  MOV  AL,BH        ;Store the video page number
  POP  BX           ;Restore used registers
V90:                ;DOne
  MOV  BH,AL        ;Set the value
  POP  AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;READ CURSOR POSITION
;Inputs:
;Outputs: BH = Cursor Row
;         BL = Cursor Column
;Changes:
;------------------------------------------------------------------------------
GetCursor:
  PUSH AX,CX,DX     ;Save used register
  CALL GetVideoPage ;Get the Video Page (BH)
  MOV  AH,3         ;Service 3 (Get Cursor Position & Size)
                    ;Returns DX = Cursor Position, CX = Cursor Size
  INT  10h          ;Do it
  MOV  BX,DX        ;Put cursor info in BX where we want it
  POP  DX,CX,AX     ;Restore used register
  RET

;------------------------------------------------------------------------------
;SET CURSOR POSITION
;Inputs:  BH = Cursor Row
;         BL = Cursor Column
;Outputs:
;Changes:
;------------------------------------------------------------------------------
PutCursor:
  PUSH AX,BX,DX     ;Save used register
  MOV  DX,BX        ;Put cursor position in DX where it belongs
  CALL GetVideoPage ;Get the Video Page (BH)
  MOV  AH,2         ;Service 2 (Set Cursor Position)
  INT  10h          ;Do It
  POP  DX,BX,AX     ;Restore used register
  RET

;------------------------------------------------------------------------------
;SAVE CURSOR SIZE, HIDE THE CURSOR
;Inputs:
;Outputs: DS:CursorSize
;Changes:
;------------------------------------------------------------------------------
HideCursor:
  PUSH AX,BX,CX,DX   ;Save used register
  CALL GetVideoPage  ;Get the Video Page (BH)
  MOV  AH,3          ;Service 3 (Get Cursor Position & Size)
                     ;Returns DX = Cursor Position, CX = Cursor Size
  INT  10h           ;Do it
  MOV  CursorSize,CX ;Put cursor info in BX where we want it
  MOV  CX,-1         ;Hide Cursor
  MOV  AH,1          ;Function 1 (Set Cursor Size)
  INT  10h           ;Do it
  POP  DX,CX,BX,AX   ;Restore used register
  RET

;------------------------------------------------------------------------------
;RESTORE ORIGINAL CURSOR SIZE
;Inputs:  DS:CursorSize
;Outputs:
;Changes:
;------------------------------------------------------------------------------
ShowCursor:
  PUSH AX,BX,CX      ;Save used register
  CALL GetVideoPage  ;Get the Video Page (BH)
  MOV  CX,CursorSize ;CX = Cursor Size
  MOV  AH,1          ;Service 1 (Set Cursor Size)
  INT  10h           ;Do it
  POP  CX,BX,AX      ;Restore used register
  RET


;ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
;WRITE COMMAND-LINE ALIASES
;ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ

;------------------------------------------------------------------------------
;PRINT THE COMMAND LINE ALIASES AND QUIT
;Inputs:  DS:[SI] = Current command line pointer
;Outputs: Writes Aliases to the screen
;Changes: Quits program
;------------------------------------------------------------------------------
DoAliases:
  TEST ProgFlags2,Alias   ;Does user want to see the Aliases?
  JZ  >A95                ;If not, we're done
  PUSH BX,DX,SI           ;Save used registers

  CALL WriteCrLfPause     ;Move down
  MOV  DX,AliasHdrMsg     ;Set up
  CALL SetupPause         ;  the Header
  MOV  SI,SwitchList      ;Point at Tbl of Aliases
  MOV  BX,'?'+('Z' SHL 8) ;BL = Min Value, BH = Max Value to look for
  CALL DoAliasesGoNoNum   ;Write the Aliases
  MOV  BX,1+(31 SHL 8)    ;BL = Min Value, BH = Max Value to look for
  CALL DoAliasesGoNoNum   ;Write the Aliases
  CALL WriteCrLfPause2    ;Move down

  MOV  DX,KeybHdrMsg      ;Set up
  CALL SetupPause         ;  the Header
  MOV  SI,SwitchListKeyb  ;Point at Tbl of Aliases
  MOV  BX,255+(255 SHL 8) ;BL = Min Value, BH = Max Value to look for
  CALL DoAliasesGoNum     ;Write the Aliases
  CALL WriteCrLfPause2    ;Move down

  MOV  DX,YesNoHdrMsg     ;Set up
  CALL SetupPause         ;  the Header
  MOV  SI,SwitchListYesNo ;Point at Table of Aliases
  MOV  BX,'N'+('Y' SHL 8) ;BL = Min Value, BH = Max Value to look for
  CALL DoAliasesGoNoNum   ;Write the Aliases

A90:                      ;Done
  POP  SI,DX,BX           ;Restore used registers
  MOV  DX,NoMsg           ;Don't write anything
  XOR  AL,AL              ;ErrorLevel = 0
  JMP  Exit               ;Quit
A95:                      ;No need to write Aliases
  RET

;------------------------------------------------------------------------------
;WRITE THE LIST OF SWITCH CHARACTERS TO THE SCREEN
;Inputs:  DS = Local Data Area
;         ES = TSR Data Area
;         BL = Minimum Value to look for in the Table
;         DH = Maximum Value to look for in the Table
;         SI = Switch List ("Code Word") Table
;Outputs: Writes List of Switch Characters to the Screen
;Changes:
;NOTES:   Sets CH =  0 if we write Blocks for Switches < " "
;                 = -1 if we write numbers for the all Switches (0-255)
;                 = -2 if we subtract 128 from the numbers (128-255)
;------------------------------------------------------------------------------
;DoAliasesGoNum80h:
;  PUSH CX               ;Save used registers
;  MOV  CH,2             ;Mark as writing Numbers, needing to subtract 128
;  JMP >G00              ;Continue
DoAliasesGoNum:
  PUSH CX               ;Save used registers
  MOV  CH,1             ;Mark as writing Numbers, not needing to modify
  JMP >G00              ;Continue
DoAliasesGoNoNum:
  PUSH CX               ;Save used registers
  XOR  CH,CH            ;Mark as not writing Numbers
;  JMP >G00              ;Continue
G00:
  PUSH AX,DI            ;Save used registers
  MOV  DI,AliasSortTbl  ;Point at the Alias Sort Table
  MOV  AL,BL            ;Start with the Lower Limit
G10:                    ;Loop to here for each Alias
  CALL GetAliasPointers ;Get the Alias Pointers
  JZ  >G60              ;If none for this entry, go to the next one
G20:                    ;Have at least one valid Alias
  CALL WriteCrLfPause   ;If valid, move down
  OR   CH,CH            ;Writing Single characters?
  JNZ >G40              ;If not, handle full numbers
  MOV  CL,78            ;Write this many characters per line
  CMP  AL,' '           ;Is there a valid single-character equivalent?
  JB  >G30              ;If not, don't write it
  CALL WriteAL          ;If so, write it
  JMP >G50              ;Continue
G30:                    ;Not a writable character
  CALL WriteBlock       ;Write a Block Character
  JMP >G50              ;Continue
G40:                    ;Need to write Numbers
  MOV  CL,76            ;Write this many characters per line
  PUSH AX               ;Save the number for a second
  CMP  CH,2             ;Do we need to modify the Number?
  JNE >G45              ;If not, continue
  AND  AL,(NOT 80h)     ;Subtract 128 from it
G45:                    ;Write the Number
  CALL ByteToString     ;Write the Switch as a Number
  POP  AX               ;Restore the Number
G50:                    ;Done writing single character
  CALL WriteAliases     ;Write the Alias List
G60:                    ;Done with this Code
  CMP  AL,BH            ;Have we done the whole list yet?
  JE  >G90              ;If so, we're done
  INC  AL               ;If not, go to the next possibility
  JMP  G10              ;Keep going until we're done
G90:                    ;Done
  POP  DI,AX            ;Restore used registers
  POP  CX               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET STRING POINTERS FOR ALL ALIASES FOR A SINGLE CHARACTER OPTION
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;          AL  = Switch Table entry to look for (not 0)
;         [SI] = Switch Table to look through, sorted backwards
;         [DI] = Alias Sort Table
;Outputs:  ZF = Clear if OK
;               [DI] = Filled with String Pointers, sorted backwards
;                      Last Entry is always a 0
;             = Set if no matches found
;                      First Entry is 0
;Changes:
;------------------------------------------------------------------------------
GetAliasPointers:
  PUSH AX,BX,CX,DX      ;Save used registers
  PUSH DI,SI            ;Save used registers
  MOV  CX,DI            ;Sve original pointer
P10:                    ;Loop to here for each Table Entry
  MOV  DX,SI            ;Save beginning Alias Pointer
P20:                    ;Loop to here to find the end of an Alias List Entry
  CMP  B [SI],0         ;End of Alias List?
  JE  >P30              ;If so, handle it
  CALL SkipOverStringSI ;If not, skip over the string
  JMP  P20              ;Keep looking
P30:                    ;End of Alias List Entry
  MOV  BX,SI            ;Save End-of-Entry Pointer
  CMP  AL,[SI+1]        ;Is this entry a match?
  JNE >P50              ;If not, go to the next one
  MOV  SI,DX            ;Point at Alias String
P40:                    ;Loop to here for each Alias String
  CMP  B [SI],0         ;End of the entry?
  JE  >P50              ;If so, we're done
  MOV  [DI],SI          ;If not, store it in the sort table
  INC  DI,2             ;Update the Table Pointer
  CALL SkipOverStringSI ;Skip over the string
  JMP  P40              ;Keep going until we have all of the strings
P50:                    ;Done with this entry
  MOV  SI,BX            ;Get End-of-Entry Pointer
  INC  SI,2             ;Skip over End-of-Entry stuff
  CMP  B [SI],0         ;End of Table?
  JNE  P10              ;If not, keep looking
P90:                    ;Done
  MOV  W [DI],0         ;Make sure last entry is a 0
  CMP  CX,DI            ;Set return flag
  POP  SI,DI            ;Restore used registers
  POP  DX,CX,BX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE ALL ALIAS STRINGS FOR A SINGLE CHARACTER OPTION
;Inputs:   DS  = Local Data Area
;          ES  = TSR Data Area
;         [DI] = Alias String Pointer Table (Sorted backwards)
;                  Last Entry is a 0
;          CL  = Number of characters left available to write on first line
;                 (76 if Writing Numbers, 78 if Writing Characters)
;         CLD already issued
;Outputs:
;Changes:
;------------------------------------------------------------------------------
WriteAliases:
  PUSH AX,BX,CX,DX    ;Save used registers
  PUSH DI,SI,ES       ;Save used registers
  MOV  ES,DS          ;Point ES at the Local Data Area
  MOV  BL,CL          ;BL = Character Countdown Measurer
  MOV  BH,CL          ;BH = Original Counter
  MOV  DX,DI          ;Save start-of-table Pointer
  MOV  CX,-1          ;Maximize counter
  XOR  AX,AX          ;Find the last
  REPNE SCASW         ;  entry in
  SUB  DI,4           ;  the Table
W10:                  ;Loop to here for each Alias String
  CMP  DI,DX          ;Are we done writing?
  JB  >W90            ;If so, quit
  MOV  SI,[DI]        ;Get the next string
  DEC  DI,2           ;Update the table pointer
  CALL CalcStrSizeSI  ;See how long the string is
  OR   BL,BL          ;Is the character counter down to 0?
  JZ  >W20            ;If so, we need to reset it
  CMP  CL,BL          ;Is this string too long to fit on this line?
  JB  >W40            ;If not, go ahead and write it
W20:                  ;Need to start a new line
  CALL WriteCrLfPause ;Start a new line
  PUSH CX             ;Save String Size for a second
  MOV  CL,79          ;Calculate how many
  SUB  CL,BH          ;  spaces to write
  CALL WriteSpaces    ;Write the spaces
  POP  CX             ;Restore String Size
  MOV  BL,BH          ;Reset the character counter
W40:                  ;Write the Alias String
  SUB  BL,CL          ;Update the
  DEC  BL             ;  character counter
  CALL WriteSpace     ;Write a Space
  CALL WriteZPauseSI  ;Write the string
  JMP  W10            ;Keep writing
W90:                  ;Done
  CALL WriteCrLfPause ;Move down
  POP  ES,SI,DI       ;Restore used registers
  POP  DX,CX,BX,AX    ;Restore used registers
  RET


;ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
;WRITE THE ERRORLEVEL TABLE
;ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ

;------------------------------------------------------------------------------
;WRITE ERRORLEVEL TABLE TO THE SCREEN AND QUIT
;Inputs:  CS = DS = Local Data Area
;Outputs: Writes ErrorLevel Table to the Screen
;Changes: Quits Program
;         Several registers
;------------------------------------------------------------------------------
DoErrLvls:
  TEST ProgFlags2,ErrLvl    ;Does the user want to see the ErrorLevels?
  JZ  >V95                  ;If not quit
  MOV  DX,ErrLvlHdr         ;Write the
  CALL SetupPause           ;  Table Header
  MOV  AL,1                 ;Start with ErrorLevel 1
V10:                        ;Loop to here for each table entry
  MOV  BX,ErrLvlTbl         ;Table to search
  CALL SearchByte2StringTbl ;Valid ErrorLevel?
  JC  >V50                  ;If not, keep looking
  CALL WriteSpace           ;Move Over
  CALL ByteToString         ;If valid, write the Number
  CALL WriteSpace           ;Write a space
  MOV  DX,BX                ;Write the
  CALL WriteZPause          ;  Description String
  CALL WriteCrLfPause       ;Write a New Line
V50:                        ;Done with this entry
  INC  AL                   ;Increment ErrorLevel
  JNZ  V10                  ;If not rolled over yet, keep looking
V90:                        ;Done
  MOV  DX,NoMsg             ;Don't write anything
  XOR  AL,AL                ;ErrorLevel = 0
  JMP  Exit                 ;Quit
V95:                        ;No need to write Aliases
  RET


;ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
;WRITE PROGRAM/KEYBOARD STATUS
;ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ

;------------------------------------------------------------------------------
;WRITE THE CURRENT STATUS TO THE SCREEN
;Inputs:  ES = TSR Data Area
;         Status (Flag)
;Outputs: Writes a bunch of stuff to the screen if Status Flag is True
;Changes:
;------------------------------------------------------------------------------
DoStatus:
  TEST StatusFlags,Status ;Need to to anything?
  JZ  >S000               ;If not, quit
  TEST ProgFlags,InMemory ;Are we installed in memory yet?
  JNZ >S00                ;If so, go ahead and do it
  MOV  DX,StatusErrMsg    ;If not, point at the first part of Error Message
  JMP  FinishDataErr      ;Terminate program
S000:
  RET

S00:
  PUSH AX,BX,DX,SI,BP          ;Save used registers
  MOV  DX,RealKeybMsg          ;Write Real Keyboard Status
  CALL WriteZPause
  MOV  DX,RealKeybYesMsg
  TEST ES:TSRFlags,NoRealKeyb
  JZ  >S05
  MOV  DX,RealKeybNoMsg
S05:
  CALL WriteZPause
  CALL WriteCrLfPause2
  MOV  DX,StatusMsg1           ;Write Typing Method
  CALL WriteZPause
  MOV  AL,ES:Method
  CALL ByteToString
  MOV  DX,StatusMsg2           ;Write Initial Delay
  CALL WriteZPause
  MOV  AL,ES:DelayFactor
  MOV  AH,10
  MUL  AH
  CALL WordToString
  MOV  DX,StatusMsg3           ;Write Repeat Rate
  CALL WriteZPause
  MOV  AL,ES:RepeatFactor
  MOV  BX,100
  XOR  AH,AH
  XCHG BX,AX
  DIV  BL
  CMP  AH,50
  JB  >S10
  INC  AL
S10:
  CALL ByteToString
  MOV  BX,0500h                ;BL = Index (0), BH = indent size
  CALL DoIndividualStatus      ;Do Individual Status for Index 0

  MOV  DX,StatusMsg4           ;Write Lock Key Processing Status
  CALL WriteZPause
  MOV  DX,NoMsgS
  TEST ES:TSRFlags,NoHandleLocks
  JNZ >S20
  MOV  DX,YesMsg
S20:
  CALL WriteZPause
  CALL DoIndividualStatus      ;Do Individual Status for Index 1

  MOV  DX,StatusMsg5           ;Write Pause Key Processing Status
  CALL WriteZPause
  MOV  DX,NoMsgS
  TEST ES:TSRFlags,NoHandlePause
  JNZ >S30
  MOV  DX,YesMsg
S30:
  CALL WriteZPause
  CALL DoIndividualStatus      ;Do Individual Status for Index 2

  MOV  DX,StatusMsg6           ;Write Reboot Request Processing Status
  CALL WriteZPause
  MOV  DX,NoMsgS
  TEST ES:TSRFlags,NoHandleReboot
  JNZ >S40
  MOV  DX,YesMsg
S40:
  CALL WriteZPause
  CALL DoIndividualStatus      ;Do Individual Status for Index 3

  MOV  DX,Status1EndMsg        ;Write last line
  CALL WriteZPause             ;  of Combined Table

  MOV  SI,UserUSBTable         ;Write the contents
  MOV  BP,USBCodeTable         ;  of the
  CALL WriteTranslations       ;  User Translation Table
  MOV  DX,Status3EndMsg        ;Write the
  CALL WriteZPause             ;  next Header
  MOV  SI,UserSysTable         ;Write the contents
  MOV  BP,GenericDesktopTbl    ;  of the
  CALL WriteTranslations       ;  User System Translation Table
S80:                           ;Done with User Table
  CALL WriteCrLfPause          ;Move down
S90:                           ;Done
  POP  BP,SI,DX,BX,AX          ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE CONTENTS OF A USER TRANSLATION TABLE TO THE SCREEN
;Inputs:  ES = TSR Data Area
;         [SI] = Translation Table to write
;         [BP] = Description Table to use for First Code
;Outputs: Writes Translations to Screen, with Translations
;Changes:
;------------------------------------------------------------------------------
WriteTranslations:
  PUSH AX,BX,CX,DX,SI       ;Save used registers
  CMP  W ES:[SI],0          ;Is it empty?
  JNE >T10                  ;If not, continue
  MOV  DX,NoXlatMsg         ;If so, write the
  CALL WriteZPause          ;  Empty Message
  CALL WriteCrLfPause       ;Move down
  JMP >T90                  ;Done
T10:                        ;User Table is not empty
  MOV  AX,ES:[SI]           ;Get the next
  INC  SI,2                 ;  Table Entry
  OR   AX,AX                ;End of Table?
  JZ  >T90                  ;If so, we're done
  CALL WriteSpace           ;If valid, move over
  CALL ByteToString         ;Write the USB/System Code
  CALL WriteSpace           ;Move over
  MOV  DX,UnknownMsg        ;Assume unrecognized Code
  MOV  BX,BP                ;Look for
  CALL SearchByte2StringTbl ;  the Description
  JC  >T20                  ;If not, in table, use Unknown
  MOV  DX,BX                ;Point DX at the Description String
T20:                        ;DX points at Description String
  CALL WriteZPause          ;Write the String
  CALL CalcStrSizeDX        ;Figure out how many
  SUB  CX,36                ;  Spaces we
  NEG  CX                   ;  need to write
  CALL WriteSpaces          ;Write them
  TEST AH,80h               ;Scancode prefixed with 224?
  JZ  >T40                  ;If not, handle it
  CMP  AH,225               ;Is it the Pause Key?
  JNE >T30                  ;If not, it's a 224 key
  MOV  DX,Msg225            ;If so, write the
  CALL WriteZPause          ;  Description
  JMP >T70                  ;Done
T30:                        ;Is a 224 Key
  MOV  DX,Msg224            ;Write the
  CALL WriteZPause          ; 224-
  JMP >T50                  ;Continue
T40:                        ;Not prefixed with 224
  CALL Write4Spaces         ;Move over
T50:                        ;Done with prefix
  MOV  AL,AH                ;Put ScanCode in AL
  MOV  DX,UnknownMsg        ;Assume unrecognized Code
  MOV  BX,ScanCodeTable     ;Look for
  CALL SearchByte2StringTbl ;  the Description
  JC  >T60                  ;If not, in table, use Unknown
  MOV  DX,BX                ;Point DX at the Description String
T60:                        ;DX points at Description String
  AND  AL,(NOT 80h)         ;Get rid of 224 Prefix Code (if there)
  CALL ByteToString         ;Write the ScanCode
  CALL Write5Spaces         ;Move Over
  CALL WriteZPause          ;Write the Description
T70:                        ;Done writing Description
  CALL WriteCrLfPause       ;Go to the next line
  JMP  T10                  ;Keep gong until we're done
T90:                        ;Done with the Table
  POP  SI,DX,CX,BX,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE THE STATUS OF AN INDIVIDUAL DEVICE TO THE SCREEN
;Inputs:  BL = Device Index to write
;         BH = Number of spaces to write at beginning of line (Indent)
;         ES = TSR Data Area
;Outputs: To Screen
;Changes: BL is incremented
;------------------------------------------------------------------------------
DoIndividualStatus:
  PUSH AX,CX,DX,DI                    ;Save used registers
  MOV  CL,BH                          ;Do the
  CALL WriteSpaces                    ;  Indent
  MOV  AL,BL                          ;Write the Index Number
  CALL WriteSpace
  CALL WriteNibbleHex
  CALL WriteSpace
  CALL DIIndex2OffsetBL               ;Convert Index to Offset (DI)

  CALL Write2Spaces                   ;Write Enabled Status
  MOV  DX,YesMsg
  TEST ES:[DI].DIFlags,DIFlagDisabled
  JZ  >I15
  MOV  DX,NoMsgS
I15:
  CALL WriteZPause

  TEST ES:[DI].DIFlags,DIFlagInUse    ;Valid Table Entry?
  JZ  >I90                            ;If not, we're done with this one

  CALL Write2Spaces                   ;Write Host Index
  MOV  AL,ES:[DI].DIHostIndex
  CALL ByteToString

  CALL Write2Spaces                   ;Write Device Address
  MOV  AL,ES:[DI].DIDvcAddress
  CALL ByteToString

  CALL Write2Spaces                   ;Write Interface Number
  MOV  AL,ES:[DI].DIInterfaceNum
  CALL ByteToString

I90:                                  ;Done
  CALL WriteCrLfPause                 ;Start a new line
  INC  BL                             ;Increment Index
  POP  DI,DX,CX,AX                    ;Restore used registers
  RET


;ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
;WRITE KEYBOARD USAGE TABLE (USB "SCANCODE" TABLE)
;ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ

;------------------------------------------------------------------------------
;WRITE THE TABLE OF "USB SCANCODES" TO THE SCREEN, AND QUIT PROGRAM
;Inputs:  ES = TSR Data Area
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoKeybUsagePage:
  TEST StatusFlags2,KeybUsagePage ;Does the user want to see the Usage Page?
  JZ  >U90                        ;If not, we're done
  MOV  BX,USBCodeTable            ;Point at the Table
  MOV  DX,USBTableHdr             ;Point at the Header
  MOV  CL,1                       ;Number of Spaces at beginning of line
  CALL WriteByte2StringTbl        ;Write it
  XOR  AL,AL                      ;ErrorLevel 0
  MOV  DX,NoMsg                   ;Write nothing
  JMP  Exit                       ;Quit
U90:                              ;Done
  RET


;ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
;WRITE GENERIC DESKTOP SYSTEM KEYS USAGE TABLE
;ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ

;------------------------------------------------------------------------------
;WRITE THE TABLE OF "USB SCANCODES" TO THE SCREEN, AND QUIT PROGRAM
;Inputs:  ES = TSR Data Area
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoGenericPage:
  TEST StatusFlags2,GenericPage ;Does the user want to see the Page?
  JZ  >G90                      ;If not, we're done
  MOV  BX,GenericDesktopTbl     ;Point at the Table
  MOV  DX,GenericDesktopTblHdr  ;Point at the Header
  MOV  CL,1                     ;Number of Spaces at beginning of line
  CALL WriteByte2StringTbl      ;Write it
  XOR  AL,AL                    ;ErrorLevel 0
  MOV  DX,NoMsg                 ;Write nothing
  JMP  Exit                     ;Quit
G90:                            ;Done
  RET


;ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
;WRITE SCANCODE TABLE
;ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ

;------------------------------------------------------------------------------
;WRITE THE TABLE OF SCANCODES TO THE SCREEN, AND QUIT PROGRAM
;Inputs:  ES = TSR Data Area
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoScanCodePage:
  TEST StatusFlags2,ScanCodePage ;Does the user want to see the Page?
  JZ  >S90                       ;If not, we're done
  MOV  BX,ScanCodeTable          ;Point at the Table
  MOV  DX,ScanCodeTableHdr       ;Point at the Header
  XOR  CL,CL                     ;Number of Spaces at beginning of line
  CALL WriteByte2StringTbl224    ;Write it
  XOR  AL,AL                     ;ErrorLevel 0
  MOV  DX,NoMsg                  ;Write nothing
  JMP  Exit                      ;Quit
S90:                             ;Done
  RET


;ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
;WRITE DEVICE/CONFIG DESCRIPTORS
;ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ

;------------------------------------------------------------------------------
;WRITE THE DESCRIPTORS OF THE LAST DEVICE TO THE SCREEN, IF NECESSARY
;Inputs:  ES:DescriptorData
;Outputs: To Screen
;Changes:
;------------------------------------------------------------------------------
DoDescriptors:
  TEST StatusFlags,Descriptors ;Does the user want to see the Descriptors?
  JZ  >D000                    ;If not, quit
  TEST ProgFlags,InMemory      ;Are we installed in memory yet?
  JNZ >D00                     ;If so, go ahead and do it
  MOV  DX,DescrErrMsg          ;If not, point at first part of Error Message
  JMP  FinishDataErr           ;Terminate program
D000:
  RET

D00:
  CALL TestLastDevice          ;Anything to do (quits if not)?
  MOV  DI,ES:LastDeviceFound   ;Get Info Table Pointer
  MOV  AX,ES                   ;Write the address
  MOV  CX,DvcDescrData         ;  of the Descriptor Data
  MOV  BX,DescriptorMsgAddr    ;  to the
  CALL WriteSegmentOffset      ;  Command Line Parameters
  MOV  BX,DescriptorMsgHost    ;Write
  MOV  AL,ES:[DI].DIHostIndex  ;  the
  CALL WriteByteToString       ;  Host Index
  INC  BX                      ;  and the
  MOV  AL,ES:[DI].DIDvcAddress ;  Device Address
  CALL WriteByteToString       ;  to the string
  MOV  AX,CS                   ;Write our
  MOV  CX,WriteZPauseFar       ;  Call-Back Address
  MOV  BX,DescriptorCallBk     ;  to the
  CALL WriteSegmentOffset      ;  Command Tail String
  MOV  BX,DescriptorMsg        ;Copy our String
  CALL CopyToCmdTail           ;  to the Command Tail String
  CALL DoExec                  ;Write the Descriptors
  MOV  DX,NoMsg                ;Write nothing
  XOR  AL,AL                   ;ErrorLevel = 0
  JMP  Exit                    ;Quit


;ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
;WRITE REPORT DESCRIPTOR
;ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ

;------------------------------------------------------------------------------
;PRINT OUT THE REPORT DESCRIPTOR DATA, IF NECESSARY
;Inputs:  ES:ReportData
;Outputs:
;Changes:
;------------------------------------------------------------------------------
DoReport:
  TEST StatusFlags,Report ;Does the user want to see the Descriptors?
  JZ  >R000               ;If not, quit
  TEST ProgFlags,InMemory ;Are we installed in memory yet?
  JNZ >R00                ;If so, go ahead and do it
  MOV  DX,ReportErrMsg    ;If not, point at the first part of Error Message
  JMP  FinishDataErr      ;Terminate program
R000:
  RET

R00:
  CALL TestLastDevice        ;Anything to do (quits if not)?
  MOV  DI,ES:LastDeviceFound ;Get Info Table Pointer
  MOV  AX,ES                 ;Write the address
  MOV  CX,ReportData         ;  of the Report Data
  MOV  BX,ReportDescrMsgAddr ;  to the
  CALL WriteSegmentOffset    ;  Command Tail String
  MOV  AX,CS                 ;Write our
  MOV  CX,WriteZPauseFar     ;  Call-Back Address
  MOV  BX,ReportDescrCallBk  ;  to the
  CALL WriteSegmentOffset    ;  Command Tail String
  MOV  BX,ReportDescrMsg     ;Copy our String
  CALL CopyToCmdTail         ;  to the Command Tail String
  CALL DoExec                ;Call the Support Program
  MOV  DX,NoMsg              ;Write nothing
  XOR  AL,AL                 ;ErrorLevel = 0
  JMP  Exit                  ;Quit


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SUPPORT CODE NEEDED TO WRITE USB DESCRIPTORS
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;TEST AND SEE IF WE CAN PRINT A DESCRIPTOR (LASTDEVICEFOUND & SUPPORTFILE)
;Inputs:  ES = TSR Data Area
;         LastDeviceFound
;Outputs: Quits program if error
;         Initializes PathToUse, Prints Header if OK
;Changes:
;------------------------------------------------------------------------------
TestLastDevice:
  PUSH AX,DX,SI                    ;Save used registers
  MOV  SI,ES:LastDeviceFound       ;Get the Device Pointer that this is for
  TEST ES:[SI].DIFlags,DIFlagInUse ;Device still there?
  JNZ >L10                         ;If so, continue
  MOV  DX,NoDescrDataMsg           ;Point at Error Message
  MOV  AL,ErLvlNoData              ;ErrorLevel = No Data
  JMP  Exit                        ;Quit
L10:                               ;Have some Data
  CALL TestSupportFile             ;Look for the Support File in the Path
  JNZ >L20                         ;If found, continue
  MOV  DX,NoSuptFileMsg            ;If not, write first part
  CALL WriteZErr                   ;  of Error Message
  MOV  DX,SupportFile              ;Write the
  CALL WriteZErr                   ;  File Name
  JMP  Exit                        ;Quit

L20:                               ;Everything is OK
  MOV  DX,HostIndexMsg             ;Write
  CALL WriteZPause                 ;  the
  MOV  AL,ES:[SI].DIHostIndex      ;  Host
  CALL ByteToString                ;  Index
  CALL WriteCrLfPause              ;Write a new line
  MOV  DX,DvcAddressMsg            ;Write
  CALL WriteZPause                 ;  the
  MOV  AL,ES:[SI].DIDvcAddress     ;  Device
  CALL ByteToString                ;  Address
  CALL WriteCrLfPause2             ;Write 2 new lines
L90:                               ;Done
  POP  SI,DX,AX                    ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO DELAY FOR A LITTLE WHILE
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;DELAY FOR A GIVEN NUMBER OF MILLISECONDS
;Inputs:  AX = number of milliseconds to wait (0-65,535)
;Outputs:
;Changes:
;------------------------------------------------------------------------------
DelayMSAX:
  PUSH AX,BX,DX  ;Save used registers
  OR   AX,AX     ;Is there anything to do?
  JZ  >D90       ;If not, just quit
  MOV  DX,1000   ;Convert
  MUL  DX        ;  to
  MOV  BX,AX     ;  microseconds (DX:BX)
D10:             ;Loop to here for each 65535 uS
  OR   DX,DX     ;Counted down high word yet?
  JZ  >D30       ;If so, handle it
  DEC  DX        ;Decrement high word
  MOV  AX,-1     ;Maximum microseconds
  JMP >D50       ;Do it
D30:             ;Counted down high word
  OR   BX,BX     ;Anything to do?
  JZ  >D90       ;If not, we're done
  MOV  AX,BX     ;Get Low Word
  XOR  BX,BX     ;Make sure it's zero next time
D50:             ;AX = Microseconds to wait
  CALL DelayUSAX ;Delay the number of microseconds specified
  JMP  D10       ;See if we need to wait some more
D90:             ;We're done
  POP  DX,BX,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;DELAY FOR A GIVEN NUMBER OF MICROSECONDS
;Inputs:  AX = number of microseconds to wait (0-65535)
;Outputs:
;Changes:
;   NOTE: Delays will be slightly longer than what's asked for, never shorter.
;         Accuracy decreases with small delays or slow computers!
;------------------------------------------------------------------------------
DelayUSAX:
  PUSH AX,BX           ;Save used registers
  OR   AX,AX           ;Is there anything to do?
  JZ  >D90             ;If not, just quit
  MOV  BX,AX           ;Put it in BX
  MOV  AX,(0FFFFh/3)+1 ;Maximum time for each sub-delay
D10:                   ;Loop to here for each sub-delay
  CMP  BX,AX           ;Is it more than the maximum?
  JA  >D40             ;If so, just do the sub-delay
  MOV  AX,BX           ;If not, just do the remainder that's left
D40:                   ;Do the delay
  CALL DoDelayUS       ;Do the US Delay
  SUB  BX,AX           ;SUbtract out how long we just waited
  JNZ  D10             ;If not 0 yet, do the sub-delay again
D90:                   ;We're done
  POP  BX,AX           ;Restore used registers
  RET

DoDelayUS:
  PUSH AX,BX,CX,DX ;Save used registers
  PUSHF            ;Save Flags
  SHL  AX,1        ;Multiply by 2
  MOV  BX,11932    ;Compensate for the fact
  MUL  BX          ;  that the clock frequency
  MOV  BX,10000    ;  is actually
  DIV  BX          ;  1.19318 MHz
  MOV  DX,AX       ;Save it
  CLI              ;Disable interrupts
  CALL GetTimer    ;Get the starting timer tick counter
  MOV  CX,AX       ;Save it
D20:               ;Keep looping to here until we've waited long enough
  MOV  BX,CX       ;Get the starting timer tick counter
  CALL GetTimer    ;Get the current timer tick counter
  SUB  BX,AX       ;Calculate the elapsed time
  CMP  BX,DX       ;Has it been long enough?
  JB   D20         ;If not, keep waiting
D90:               ;We're done
  POPF             ;Restore Flags
  POP  DX,CX,BX,AX ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET CURRENT TIMER COUNTER FROM PORT 40h (THE CLOCK INTERRUPT)
;Inputs:
;Outputs: AX = Current timer counter word
;Changes:
;------------------------------------------------------------------------------
GetTimer:
  PUSHF       ;Save flags
  CLI         ;DIsable interrupts
  MOV  AL,06h ;Bits 7:6 =  00 = Timer 0
              ;Bits 5:4 =  00 = Latch Counter
              ;Bits 3:1 = 011 = Mode 3 (Square Wave)
              ;Bit    0 =   0 = Binary Counter (16 bits)
  OUT  43h,AL ;Tell the PIT what wer'e going to do
  IN   AL,40h ;Get LSB of timer counter
  MOV  AH,AL  ;Save it
  IN   AL,40h ;Get MSB of timer counter
  XCHG AH,AL  ;Put things in the right order
  POPF        ;Restore flags
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO TEST AND SEE IF THE COMPUTER IS COMPATIBLE OR NOT.
;TESTS DOS VERSION, HARDWARE INSTALLED, ETC. AS APPROPRIATE TO MAKE SURE
;  WE DON'T DO SOMETHING THAT COULD CRASH THE COMPUTER.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;TEST THE COMPUTER TO SEE IF IT'S COMPATIBLE (CPU, DOS VERSION, WHATEVER)
;Inputs:  InMemory
;Outputs: Quits the program if Computer is Incompatible
;         Returns if Computer is OK
;         Stores all kinds of values in memory variables
;Changes:
;------------------------------------------------------------------------------
TestCompatibility:
  PUSH AX,DX              ;Save used registers
  TEST ProgFlags,InMemory ;Are we already installed?
  JNZ >C90                ;If so, no need to test again
  MOV  AL,ErLvlBadCPU     ;Assume incorrect
  MOV  DX,BadCPUMsg       ;  CPU type
  CALL Test8086           ;Is the CPU at least an 80286?
  JNC >C70                ;If not, quit
  MOV  AL,ErLvlDOSVer     ;Assume incorrect
  MOV  DX,DOSVerMsg       ;  DOS Version
  CALL TestDOSVer         ;  new enough?
  JC  >C70                ;If not, quit
  MOV  AL,ErLvlNoHost     ;Assume Host Driver
  MOV  DX,NoHostMsg       ;  is not installed
  CALL TestUSBHost        ;Is there a USB Host Driver installed?
  JNC >C90                ;If not, we're OK
C70:                      ;The computer is incompatible for some reason
  JMP  Exit               ;Quit!
C90:                      ;The computer is compatible!
  POP  DX,AX              ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF THE CPU IS AN 8086/8088
;Inputs:
;Outputs: CF = Clear if the CPU is an 8086/8088
;            = Set if 80286+
;Changes:
;------------------------------------------------------------------------------
Test8086:
  PUSH AX,BX     ;Save used registers
  PUSHF          ;Save flags
  MOV  BX,0F000h ;Flags mask for testing (these bits always set on 8086/8088)
  PUSHF          ;Put the current flags
  POP  AX        ;  in AX
  AND  AX,0FFFh  ;Try to clear the
  PUSH AX        ;  four high bits
  POPF           ;  of the flags
  PUSHF          ;Put the current flags
  POP  AX        ;  in AX
  AND  AX,BX     ;Are the four high bits
  CMP  AX,BX     ;  of the flags set?
  JE  >E80       ;If so, it's an 8086/8088
  POPF           ;Restore flags
E70:             ;It is not an 8086/8088
  STC            ;Set the not 8086/8088 flag
  JMP >E90       ;We're done
E80:             ;It is an 8086/8088
  POPF           ;Restore flags
  CLC            ;Set the 8086/8088 flag
E90:             ;We're done
  POP  BX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST THE CURRENT DOS VERSION
;Inputs:  MinDOSVer (EQUate)
;Outputs: CF = Clear if DOS version >= MinDOSVer
;         CF = Set if DOS version < MinDOSVer
;Changes:
;------------------------------------------------------------------------------
TestDOSVer:
  PUSH AX,BX,CX     ;Save used registers
  MOV  AX,3000h     ;Service 30h (get DOS version number)
                    ;  DOS 5.0 requires AL = 00h, may change BX and CX
  INT  21h          ;Do it (Returns AL= Major, AH = Minor)
  XCHG AL,AH        ;Swap Major and Minor versions for testing
  CMP  AX,MinDOSVer ;Is the version new enough?
  JAE >D80          ;If so, it's OK
D70:                ;DOS is older than the minimum
  STC               ;Set the "too old" flag
  JMP >D90          ;We're done
D80:                ;DOS is >= the minimum
  CLC               ;Set the OK flag
D90:                ;We're done
  POP  CX,BX,AX     ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST AND SEE IF A COMPATIBLE USB HOST DRIVER IS INSTALLED
;Inputs:
;Outputs: CF = Set if error (No Host Driver Installed)
;            = Clear if OK
;Changes:
;------------------------------------------------------------------------------
TestUSBHost:
  PUSH AX,BX,CX ;Save used registers
  MOV  AX,5000h ;Function 5000h (Install Check)
  MOV  BX,'US'  ;Set
  MOV  CX,'B!'  ;  registers
  STC           ;Preset Error Flag
  INT  14h      ;Do it
  JC  >U70      ;If Error, USB Host can't be installed
  OR   AX,AX    ;Is AX Correct?
  JNZ >U70      ;If not, Error
  CMP  BX,'B!'  ;Is BX correct?
  JNE >U70      ;If not, Error
  CMP  CX,'US'  ;Is CX correct?
  JE  >U80      ;If so, it's installed
U70:            ;Not installed
  STC           ;Set Error Flag
  JMP >U90      ;Done
U80:            ;Installed
  CLC           ;Set OK flag
U90:            ;Done
  POP  CX,BX,AX ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO TEST AND SEE WHICH TYPING METHOD TO USE.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;TEST TO SEE WHICH SCAN CODE METHOD TO USE
;Inputs: CS = DS = ES = Local Data Area
;        (Program is not installed yet as TSR,
;           and we haven't yet copied ourselves into a UMB)
;Outputs: Method = 1, 2, or 3 (picks the lowest number that works OK)
;Changes:
;NOTES: This does not test the Method if the Method is already known (<> 0)
;------------------------------------------------------------------------------
TestMethod:
  PUSH DI               ;Save used registers
  MOV  DI,OFFSET Method ;Point [DI] at the Method
  CMP  B [DI],0         ;Did the user provide us a Method to use?
  JNE >M90              ;If so, we don't need a Test
  MOV  B [DI],1         ;Use Method 1
  CALL TestMethodGo     ;Test it
  JZ  >M90              ;If it worked, we're done
  INC  B [DI]           ;If not, use Method 2
  CALL TestMethodGo     ;Test it
  JZ  >M90              ;If it worked, we're done
  INC  B [DI]           ;If not, use Method 3
M90:                    ;We've calculated a Method to use
  POP  DI               ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TEST A PARTICULAR SCAN CODE METHOD
;Inputs:  Method = 1 or 2 (The method to test)
;Outputs: ZF = Set if it worked
;            = Clear if it didn't
;Changes:
;------------------------------------------------------------------------------
TestMethodGo:
  PUSH AX,BX        ;Save used registers
  XOR  BH,BH        ;Initialize the "it worked" flag
  CALL FlushKbdBuff ;Flush the keyboard buffer
  MOV  BL,1         ;Send an
  CALL FakeItTest   ;  <Escape> press
  ADD  BL,80h       ;Send an
  CALL FakeItTest   ;  <Escape> release
  CALL GetKey       ;Is there a key in the keyboard buffer?
  JZ  >T90          ;If not, it didn't work
  CMP  AX,011Bh     ;If so, is it an <Esc>?
  JNE >T90          ;If not, it didn't work
  INC  BH           ;If so, increment our counter
T10:
  CALL GetKey       ;See if there's another key
  JZ  >T90          ;If not, we're done
  INC  BH           ;If so, increment the counter
  JMP  T10          ;And keep going until we flush the keyboard buffer
T90:
  CMP  BH,1         ;Did the <Escape> test work?
  POP  BX,AX        ;Restore used registers
  RET

FakeItTest:
  PUSH CX     ;Save used registers
  MOV  CX,200 ;Delay for 200 loops
  CALL FakeIt ;Do it
F90:          ;Delay a little bit
  LOOP F90    ;Delay for a little while
  POP  CX     ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO SAVE/RESTORE IRQ 8 (INT 70H)
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;ENABLE IRQ 8 (INT 70h)
;Inputs:  ES = TSR Data Area
;Outputs: OldA1
;Changes: Enables IRQ 8 (INT 70h), if not already enabled
;------------------------------------------------------------------------------
StartIRQ8:
  PUSH AX           ;Save used registers
  PUSHF             ;Save flags
  CLI               ;Disable Interrupts
  IN   AL,0A1h      ;Get the PIC2 IRQ Mask
  MOV  ES:OldA1,AL  ;Save it
  AND  AL,(NOT 01h) ;Enable IRQ8
  OUT  0A1h,AL      ;  (Int 70h)
  POPF              ;Restore flags
  POP  AX           ;Restore used registers
  RET

;------------------------------------------------------------------------------
;DISABLE IRQ 8 (INT 70h) IF WE ENABLED IT
;Inputs:  ES = TSR Data Area
;         OldA1
;Outputs:
;Changes: Restores IRQ 8 Enabled status to its original state
;------------------------------------------------------------------------------
StopIRQ8:
  PUSH AX           ;Save used registers
  PUSHF             ;Save flags
  CLI               ;Disable Interrupts
  TEST ES:OldA1,01h ;Was IRQ 8 Enabled when we started?
  JZ  >Q90          ;If so, we're done
  IN   AL,0A1h      ;Get the current PIC2 status
  OR   AL,01h       ;Disable IRQ8
  OUT  0A1h,AL      ;  (Int 70h)
Q90:                ;Done
  POPF              ;Restore flags
  POP  AX           ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO SEARCH THROUGH/WRITE TABLES
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;WRITE THE ENTIRE CONTENTS OF A BYTE-TO-STRING TABLE TO THE SCREEN
;Inputs:  DS:[BX] = Table to write
;         DS:[DX] = Header to write at top of each screen
;             CL  = Number of spaces to write at beginning of each line
;Outputs: To the Screen
;Changes:
;------------------------------------------------------------------------------
WriteByte2StringTbl224:
  PUSH DI                   ;Save used registers
  MOV  DI,-1                ;Mark as caring about 224's
  JMP >W00                  ;Do it
WriteByte2StringTbl:
  PUSH DI                   ;Save used registers
  XOR  DI,DI                ;Mark as not writing 224's
;  JMP >W00                  ;Do it
W00:
  PUSH AX,BX,DX,SI          ;Save used registers
  MOV  SI,BX                ;Save Table Pointer
  XOR  AH,AH                ;Start with Index 0
  CALL SetupPause           ;Initialize the Pause
W10:                        ;Loop to here for each Table Entry
  MOV  AL,AH
  MOV  BX,SI                ;Is there a matching entry
  CALL SearchByte2StringTbl ;  in the Table?
  JC  >W80                  ;If not, skip it
  CALL WriteSpaces          ;Wrie the Indent
  OR   DI,DI                ;Do we care about 224's?
  JZ  >W70                  ;If not, just write the plain number
W20:                        ;We care about 224's
  TEST AL,80h               ;Is there a 224 prefix?
  JZ  >W40                  ;If not, handle it
  MOV  DX,Msg224            ;If so, write the
  CALL WriteZPause          ;  224 message
  JMP >W60                  ;Continue
W40:                        ;Not a 224 prefix
  CALL Write4Spaces         ;Just write spaces
W60:                        ;Done writing 224 Prefix
  AND  AL,(NOT 80h)         ;Get rid of the 224 Prefix
W70:                        ;Done handling 224 Prefix
  CALL ByteToString         ;Write the Number
  OR   DI,DI                ;Do we care about 224's?
  JZ  >W75                  ;If not, just write one space
  CALL Write4Spaces         ;Move over
W75:                        ;Number is already written
  CALL WriteSpace           ;Move over
  MOV  DX,BX                ;Write the
  CALL WriteZPause          ;  Description
  CALL WriteCrLfPause       ;Start a new line
W80:                        ;Done with this one
  ADD  AH,1                 ;Increment the Index
  JC  >W85                  ;If done, continue
  OR   DI,DI                ;Do we care about 224's?
  JZ   W10                  ;If not, continue
  CMP  AH,225               ;If so, is it the Pause Key Code?
  JNE  W10                  ;If not, continue
  INC  AH                   ;If so, skip the Pause Key
  JMP  W10                  ;Keep writing
W85:                        ;Done with Table
  OR   DI,DI                ;Do we care about 224's?
  JZ  >W90                  ;If not, we're done
  MOV  DX,Msg2252           ;If so, write
  CALL WriteZPause          ;  the Description
  CALL WriteCrLfPause       ;Start a new line
W90:                        ;Done
  POP  SI,DX,BX,AX          ;Restore used registers
  POP  DI                   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEARCH A BYTE-TO-STRING LOOKUP TABLE FOR A MATCHING ENTRY
;Inputs:  DS:[BX] = Table to search
;         AL      = Byte to search for
;         CLD already issued
;Outputs: CF = Clear if a byte match as found in table
;              BX = Pointer to the String
;            = Set if no match found in table
;              BX = unchanged
;Changes:
;NOTES: Last Entry in Table (end-of-table marker) = DW -1
;------------------------------------------------------------------------------
SearchByte2StringTbl:
  PUSH AX,SI            ;Save used registers
  CLD                   ;Go forward with string functions
  MOV  SI,BX            ;Put pointer in SI
  MOV  AH,AL            ;Put byte to check in AH
S10:                    ;Loop to here for each table entry
  LODSB                 ;Get the next table entry
  CMP  AL,-1            ;Is it possibly the end of the table?
  JNE >S20              ;If not, continue
  CMP  B [SI],-1        ;Is it actually the end of the table?
  JE  >S70              ;If so, there's no match
S20:                    ;Not end of table
  CMP  AL,AH            ;Is it a match?
  JE  >S80              ;If so, handle it!
  CALL SkipOverStringSI ;If not, skip over the string
  JMP  S10              ;And keep looking
S70:                    ;No entry found
  STC                   ;Set the not found flag
  JMP >S90              ;Quit
S80:                    ;Entry found [SI]
  MOV  BX,SI            ;Point BX at the String
  CLC                   ;Set the found flag
S90:                    ;Done
  POP  SI,AX            ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO SET UP COMMAND TAIL WITH PROPER PARAMETERS FOR EXEC CALL
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;WRITE A SEGMENT:OFFSET COMBINATION TO A STRING VARIABLE
;Inputs:   AX  = Segment to Write
;          CX  = Offset to Write
;         [BX] = String to Write to
;Outputs: Converts AX:CX to a Hex String and stores at [BX]
;Changes:
;------------------------------------------------------------------------------
WriteSegmentOffset:
  PUSH AX,DI,ES       ;Save used registers
  MOV  ES,DS          ;Point ES at Local Data Area
  MOV  DI,BX          ;Point DI at String
  CALL Word2HexString ;Store the Segment
  MOV  AL,':'         ;Store the
  STOSB               ;  Colon
  MOV  AX,CX          ;Store
  CALL Word2HexString ;  the Offset
  POP  ES,DI,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A WORD AS HEX TO A STRING
;Inputs:   AX  = Word to Write
;         [BX] = String to write to
;Outputs:
;Changes: BX
;------------------------------------------------------------------------------
WriteWordToString:
  PUSH AX,DI,ES       ;Save used registers
  MOV  ES,DS          ;Point ES at Local Data Area
  MOV  DI,BX          ;Point DI at String
  CALL Word2HexString ;Store the Word
  MOV  AL,'h'         ;Write the
  STOSB               ;  'h'
  ADD  BX,5           ;Update Pointer
  POP  ES,DI,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;WRITE A BYTE AS HEX TO A STRING
;Inputs:   AL  = Byte to Write
;         [BX] = String to write to
;Outputs:
;Changes: BX
;------------------------------------------------------------------------------
WriteByteToString:
  PUSH AX,DI,ES       ;Save used registers
  MOV  ES,DS          ;Point ES at Local Data Area
  MOV  DI,BX          ;Point DI at String
  CALL Byte2HexString ;Store the Byte
  MOV  AL,'h'         ;Write the
  STOSB               ;  'h'
  ADD  BX,3           ;Update Pointer
  POP  ES,DI,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;COPY A STRING INTO THE COMMAND TAIL
;Inputs:  [BX] = ASCIIZ String to Copy
;Outputs: To CmdTail
;Changes:
;------------------------------------------------------------------------------
CopyToCmdTail:
  PUSH AX,CX,DX,DI,SI,ES ;Save used registers
  MOV  ES,DS             ;Point ES at Local Data Area
  MOV  CX,(CmdTailMax/2) ;Number of Words to Copy
  MOV  AX,CR+(CR SHL 8)  ;Fill with CR's
  MOV  DI,CmdTail        ;Point at Command Tail
  PUSH DI                ;Save Pointer
  REP  STOSW             ;Fill the Command Tail
  POP  DI                ;Restore Pointer
  MOV  DX,BX             ;Calculate number of bytes
  CALL CalcStrSizeDX     ;  to copy
  MOV  CmdTailSize,CL    ;Store the Command Tail Size
  MOV  SI,BX             ;Copy the string
  REP  MOVSB             ;  to the Command Tail
  POP  ES,SI,DI,DX,CX,AX ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO EXEC ANOTHER PROGRAM
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;SETUP PARAMETERS TO BE ABLE TO PERFORM THE EXEC FUNCTION
;Inputs:
;Outputs:
;Changes: Lots of stuff
;------------------------------------------------------------------------------
SetupExec:
  PUSH AX,SI                       ;Save used registers
  MOV  SI,ParamBlock               ;Point at Parameter Block
  MOV  AX,CS                       ;Use our data segment
  MOV  [SI].PBEnvirSegment,0       ;Use Copy of our Environment
  MOV  W [SI].PBCmdTailPtr[0],OFFSET CmdTailSize
  MOV  W [SI].PBCmdTailPtr[2],AX   ;Command Tail Pointer
  MOV  W [SI].PBFCB1Offset[0],FCB1
  MOV  W [SI].PBFCB1Offset[2],AX   ;FCB #1 Pointer
  MOV  W [SI].PBFCB2Offset[0],FCB2
  MOV  W [SI].PBFCB2Offset[2],AX   ;FCB #2 Pointer
  POP  SI,AX                       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;PERFORM THE EXEC FUNCTION
;Inputs:  ParamBlock set up with appropriate data
;         CmdTail/CmdTailSize set up with appropriate Info
;         PathToUse contains Child Program to Call
;         DS = Our data Area
;Outputs: CF = Clear if Program Returned ErrorLevel 0
;Changes: Performs EXEC Function
;------------------------------------------------------------------------------
DoExec:
  PUSH ES            ;Save used register
  MOV  ES,DS         ;Point ES at our Data Area
  PUSH AX,BX,CX,DX   ;Save all registers
  PUSH DI,SI,BP      ;Save all registers
  MOV  OldSPExec,SP  ;Save the Stack Pointer (may be destroyed by Call)
  MOV  DX,PathToUse  ;DS:[DX] = Child Program to Run
  MOV  BX,ParamBlock ;ES:BX = Parameter Block
  MOV  AX,4B00h      ;Function 4B00h (Load and Execute child program)
  INT  21h           ;Do it (May Destroy BX & DX)
  JC  >X70           ;If Error, quit
X00:                 ;When the Child Program Exits, here we are!
  CLD                ;Go forward with string functions
  CLI                ;Disable interrupts
  MOV  DS,CS         ;Restore
  MOV  ES,DS         ;  all
  MOV  SS,CS         ;  Segments
  MOV  SP,OldSPExec  ;Restore Stack Pointer
  STI                ;Enable interrupts
  MOV  AH,4Dh        ;Function 4Dh (Get ErrorLevel)
  INT  21h           ;Do it (Returns AH = Term Type, AL = ErrorLevel)
  OR   AL,AL         ;ErrorLevel 0?
  JZ  >X80           ;If so, it was OK
X70:                 ;Error
  STC                ;Set Error Flag
  JMP >X90           ;Done
X80:                 ;OK
  CLC                ;Set OK Flag
X90:                 ;Done
  POP  BP,SI,DI      ;Restore all registers
  POP  DX,CX,BX,AX   ;Restore all registers
  POP  ES            ;Restore used registers
  RET

;------------------------------------------------------------------------------
;LOOK FOR THE SUPPORT FILE SOMEWHERE IN THE PATH
;Inputs:  DS = Local Data Area
;         SupportFile
;         ProgFlags.FoundSuptFile = False
;Outputs: ZF = Clear if Support File Found
;              ProgFlags.FoundSuptFile = True
;Outputs: ZF = Set if Support File Not Found
;              ProgFlags.FoundSuptFile = False
;Changes:
;------------------------------------------------------------------------------
TestSupportFile:
  PUSH DI,SI                ;Save used registers
  MOV  SI,OFFSET ProgFlags  ;Point [SI] at ProgFlags
  MOV  DI,SupportFile       ;Look for the
  CALL FindSupportFile      ;  Support File
  JC  >S90                  ;If not found, quit
  OR   B [SI],FoundSuptFile ;If found, mark it as found
S90:                        ;Done
  TEST B [SI],FoundSuptFile ;Set return flag
  POP  SI,DI                ;Restore used registers
  RET

;------------------------------------------------------------------------------
;FIND THE LOCATION OF THE SUPPORT FILE
;Inputs:  [DI] = FIleName to Look for
;Outputs: CF = Clear if OK (File Found)
;              PathToUse = Path & FileName Concatenated Together
;            = Set if Error (File not Found)
;              PathToUse = Undefined
;Changes: Various Path pointer Registers (OurPathPointer, PathVarPointer, etc.)
;------------------------------------------------------------------------------
FindSupportFile:
  PUSH AX,SI,DS,ES       ;Save used registers
F10:                     ;Do Our Path
  MOV  SI,OurPathPointer ;Point SI at our Path pointer
  CMP  SI,-1             ;Valid?
  JE  >F20               ;If not, skip it
  MOV  AX,[PSPEnvirSeg]  ;Point ES at
  MOV  ES,AX             ;  Environment Segment
  CALL CopyPathName      ;Copy it
  CALL FindFile          ;File exists?
  JNC >F80               ;If so, we're done
F20:                     ;Do Current Path
  MOV  ES,CS             ;Point ES at us
  MOV  SI,CurrentPath    ;If not, try the Current Path
  CALL CopyPathName      ;Copy it
  CALL FindFile          ;File exists?
  JNC >F80               ;If so, we're done
F30:                     ;Do Environment PATH
  MOV  SI,PathVarPointer ;SI = Environment PATH Pointer
  CMP  SI,-1             ;Is it valid?
  JE  >F70               ;If not, we're done
  MOV  AX,[PSPEnvirSeg]  ;Point ES at Path
  MOV  ES,AX             ;  (Environment) Segment
F35:                     ;Loop to here for each element in PATH
  CALL CopyPathName      ;Copy the PATH element
  JC  >F70               ;If End of Path, we're done
  CALL FindFile          ;File exists?
  JNC >F80               ;If so, we're done
F40:                     ;Loop to here to skip over PATH Element
  MOV  AL,ES:[SI]        ;Get next character
  INC  SI                ;Increment Pointer
  OR   AL,AL             ;End of PATH?
  JZ  >F70               ;If so, we're done
  CMP  AL,';'            ;End of PATH Element?
  JNE  F40               ;If not, Keep looking
  JMP  F35               ;Try the next Element
F70:                     ;Error
  STC                    ;Set Error Flag
  JMP >F90               ;Done
F80:                     ;Found our File
  CLC                    ;Set OK flag
F90:                     ;Done
  POP  ES,DS,SI,AX       ;Restore used registers
  RET

;------------------------------------------------------------------------------
;SEE IF THE SUPPORT FILE EXISTS
;Inputs:  PathToUse
;Outputs: CF = Clear if OK (File Found)
;            = Set if Error (File not Found)
;Changes:
;------------------------------------------------------------------------------
FindFile:
  PUSH AX,BX,CX,DX   ;Save used registers
  PUSH DS,ES         ;Save used registers
  MOV  AH,2Fh        ;Function 2Fh (Get DTA Address)
  INT  21h           ;Do it (returns ES:BX)
  MOV  AH,1Ah        ;Function 1Ah (Set DTA Address)
  MOV  DX,FCB1       ;DS:DX = New DTA Address
  INT  21h           ;Do it
  MOV  AX,4E00h      ;Function 4Eh (Find First Matching File)
  MOV  CX,FAttrToUse ;Search for any file, including Hidden
  MOV  DX,PathToUse  ;DS:DX = ASCIIZ FileName to search for
  INT  21h           ;Do it (returns CF)
  PUSHF              ;Save return flag
  MOV  DS,ES         ;Point DS:DX
  MOV  DX,BX         ;  at the old DTA
  MOV  AH,1Ah        ;Function 1Ah (Set DTA Address)
  INT  21h           ;Do it
  POPF               ;Restore return flag
  POP  ES,DS         ;Restore used registers
  POP  DX,CX,BX,AX   ;Restore used registers
  RET

;------------------------------------------------------------------------------
;CREATE A COMPLETE PATH NAME GIVEN A PATH AND A FILE NAME
;Inputs:  ES:[SI] = Path name to Copy
;         DS:[DI] = FileName to Append to the Path
;Outputs: PathToUse = Path & File Concatenated Together
;NOTES: The Path String can either end with a 0 (ASCIIZ String) or a SemiColon
;         (the way strings are stored in the PATH Environment variable).
;       This code will properly handle an empty Path String, which will
;         simply set PathToUse to the FileName.
;       The FileName must be an ASCIIZ String.
;------------------------------------------------------------------------------
CopyPathName:
  PUSH AX,BX,CX,DI,SI,DS,ES  ;Save used registers
  PUSH DS                    ;Point ES
  PUSH ES                    ;  at our data,
  POP  DS                    ;  DS at
  POP  ES                    ;  Path Data
  MOV  BX,DI                 ;Save File Name Pointer
  XOR  AX,AX                 ;Fill with Zeroes
  MOV  CX,(MaxPathSize/2)    ;Number of Words to Write
  MOV  DI,PathToUse          ;Where to write them
  PUSH DI                    ;Save Pointer
  REP  STOSW                 ;Reset the Buffer
  POP  DI                    ;Restore Pointer
  XOR  CL,CL                 ;Start String Length Counter at 0
N10:                         ;Loop to here for each character in Path
  LODSB                      ;Get next character
  OR   AL,AL                 ;End of Path?
  JZ  >N20                   ;If so, do Filename
  CMP  AL,';'                ;End of Path (Environment PATH)?
  JE  >N20                   ;If so, do FileName
  INC  CL                    ;Increment String Length Counter
  STOSB                      ;If not, store the character
  JMP  N10                   ;Keep going
N20:                         ;Done with Path
  OR   CL,CL                 ;Any characters at all in the Path?
  JZ  >N30                   ;If so, is Current Path, and don't want backslash!
  CMP  B ES:[DI-1],Backslash ;Path ends in a Backslash?
  JE  >N30                   ;If so, it's OK
  MOV  AL,Backslash          ;If not, store
  STOSB                      ;  a Backslash
N30:                         ;Path is OK
  MOV  DS,ES                 ;Point DS:[SI]
  MOV  SI,BX                 ;  at the File Name
N40:                         ;Loop to here for each character in File name
  LODSB                      ;Get next character
  OR   AL,AL                 ;End of File Name?
  JZ  >N90                   ;If so, we're done
  STOSB                      ;If not, store it
  JMP  N40                   ;Keepgoing
N90:                         ;Done
  POP  ES,DS,SI,DI,CX,BX,AX  ;Restore used registers
  RET

;------------------------------------------------------------------------------
;GET THE PATH THAT OUR PROGRAM IS IN
;Inputs:
;Outputs: OurPathPointer = Pointer to Our Path String (in Environment Segment)
;                        = -1 if we couldn't find our own Path
;Changes:
;------------------------------------------------------------------------------
GetOurPath:
  PUSH AX,CX,DI,SI,DS,ES    ;Save used registers
  MOV  AX,[PSPEnvirSeg]     ;Point DS & ES
  MOV  DS,AX                ;  at the
  MOV  ES,AX                ;  Environment segment
  XOR  DI,DI                ;Point at the beginning of Environment list
  MOV  CX,-1                ;Max out the count limiter
  XOR  AX,AX                ;Need to look for a double 0
U10:                        ;Loop to here to skip over Environment vars
  REPNE SCASB               ;Look for the end of this environment variable
  CMP  [DI],AL              ;Is it the end of the variable list (double 0)?
  JNE  U10                  ;If not, keep skipping over Environment vars
  CMP  [DI+1],AX            ;If so, is there a string after the Envir?
  JE  >U70                  ;If not, we're done
  ADD  DI,3                 ;Point DI and SI at the
  MOV  SI,DI                ;  True Name
  MOV  CS:OurPathPointer,DI ;Store the Pointer
U20:                        ;Loop to here to find the end of the PATH
  LODSB                     ;Get the next character of the name
  CMP  AL,':'               ;Is it a Colon?
  JE  >U30                  ;If so, possible end-of-path
  CMP  AL,Backslash         ;Is it backslash?
  JE  >U30                  ;If so, possible end-of-path
  OR   AL,AL                ;End of File Name?
  JZ  >U50                  ;If so, we're done
  JMP >U40                  ;If not, keep looking
U30:                        ;Update end-of-path Pointer
  MOV  DI,SI                ;Save possible end-of-path pointer
U40:                        ;Not end-of-path yet
  JMP  U20                  ;Keep looking
U50:                        ;At end of Path
  CMP  DI,CS:OurPathPointer ;Was there a real path?
  JE  >U70                  ;If not, error
  MOV  B [DI],0             ;If OK, put 0 at end of Path
  JMP >U90                  ;Done
U70:                        ;No Path
  MOV  CS:OurPathPointer,-1 ;Set Pointer
U90:                        ;Done
  POP  ES,DS,SI,DI,CX,AX    ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;CODE TO AUTOMATICALLY MOVE THE PROGRAM INTO UPPER MEMORY
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;TRY TO ALLOCATE A UMB, AND COPY THE PROGRAM TO THE UMB SEGMENT
;Inputs:  DS = ES = Current Data Segment
;Outputs: ES = New Data Segment (in UMB or Low Memory Hole)
;              If no UMB or Low Memory Hole is available, ES remains unchanged
;         Entire TSR Portion of Program is copied to new Segment
;Changes:
;------------------------------------------------------------------------------
MoveProgramToUMB:
  PUSH AX,BX,CX,DX,DI,SI      ;Save used registers
  MOV  AX,DS                  ;Save original Data Segment
  CMP  AX,0A000h              ;Already in Upper Memory?
  JAE >U90                    ;If so, just quit
  TEST ProgFlags,UseLowMemory ;Does user want us in Low Memory?
  JNZ >U90                    ;If so, just quit
  MOV  BX,(LastTSRByte SHR 4) ;Number of Paragraphs to Allocate
  CALL AllocateUMBDOS         ;Try to get a UMB from DOS (Returns ES)
  JZ  >U90                    ;If it didn't work, quit
  MOV  DX,ES                  ;Save new Segment
  PUSH DS                     ;Save data Segment
  MOV  AX,DS                  ;Point DS
  DEC  AX                     ;  at current
  MOV  DS,AX                  ;  MCB
  MOV  AX,ES                  ;Point ES
  DEC  AX                     ;  at new
  MOV  ES,AX                  ;  MCB
  MOV  SI,OFFSET MCBOwnerName ;Copy
  MOV  DI,SI                  ;  the
  MOV  CX,4                   ;  Owner
  REP  MOVSW                  ;  Name
  POP  DS                     ;Restore Data Segment
  MOV  ES:[MCBOwnerID],DX     ;Make itself the Owner
  MOV  AH,26h                 ;Function 26h (Create new PSP, DX = Segment)
  INT  21h                    ;Do it
  MOV  ES,DX                  ;Point ES at new Segment again
  ADD  DX,BX                  ;Calculate where next Segment will be
  MOV  ES:[PSPNextSegment],DX ;Store it in the PSP
  MOV  CL,3                   ;Calculate
  SHL  BX,CL                  ;  number
  MOV  CX,BX                  ;  of words
  SUB  CX,(PSPStrucSize/2)    ;  to Copy
  MOV  SI,PSPStrucSize        ;SI = Old Data
  MOV  DI,SI                  ;DI = New Data
  REP  MOVSW                  ;Copy Program to new Segment
  OR   ProgFlags,MemoryMoved  ;Mark memory as having been moved
U90:                          ;Done
  POP  SI,DI,DX,CX,BX,AX      ;Restore used registers
  RET

;------------------------------------------------------------------------------
;TRY TO ALLOCATE A UMB THROUGH DOS
;Inputs:  BX = Number of Paragraphs to Allocate
;Outputs: ZF = Clear if OK
;              ES = Segment of Allocated UMB
;            = Set if Error
;              ES = Unchanged
;Changes:
;NOTES: Allocating USB's through DOS normally requires a
;         DOS=HIGH,UMB line in CONFIG.SYS
;------------------------------------------------------------------------------
AllocateUMBDOS:
  PUSH AX,BX,CX,DX   ;Save used registers
  PUSH DI,SI         ;Save used registers
  MOV  CX,ES         ;Save original ES
  MOV  DI,BX         ;Save Number of Paragraphs to Allocate
  MOV  AX,5800h      ;Function 5800h (Get Memory Allocation Strategy)
  INT  21h           ;Do it (returns AX)
  JC  >D90           ;If error, quit
  MOV  SI,AX         ;If OK, save it
  MOV  AX,5802h      ;Function 5802h (Get UMB Link State - DOS 5+ Only)
  INT  21h           ;Do it (Returns AL)
  JC  >D90           ;If error, quit
  MOV  DL,AL         ;If OK, Save it
  MOV  BX,UMBLinkYes ;Enable USB's in DOS Memory Chain
  MOV  AX,5803h      ;Function 5803h (Set UMB Link State)
  INT  21h           ;Do it
  JC  >D90           ;If error, quit
  MOV  BX,StrategyHighLowBest ;Strategy = Try High, then Low, Best Fit
  MOV  AX,5801h      ;Do
  INT  21h           ;  it
  JC  >D80           ;If error, quit
D20:                 ;Strategy is set
  MOV  BX,DI         ;BX = # of Paragraphs to Allocate
  MOV  AH,48h        ;Function 48h (Allocate Memory)
  INT  21h           ;Do it (returns AX = Segment)
  JC  >D80           ;If error, quit
  MOV  ES,AX         ;If OK, put Segment in ES
  CMP  AX,0A000h     ;Is it really a UMB?
  JAE >D80           ;If so, continue
  MOV  DI,CS         ;If not, is it a memory "hole" lower in memory
  CMP  AX,DI         ;  than we are (from a previously removed TSR)?
  JB  >D80           ;If so, continue
  MOV  AH,49h        ;Function 49h (Free Memory, Segment in ES)
  INT  21h           ;Do it
  MOV  ES,CX         ;Restore original ES
D80:                 ;Restore original UMB Link State & Strategy
  XOR  BH,BH         ;Restore
  MOV  BL,DL         ;  original
  MOV  AX,5803h      ;  USB
  INT  21h           ;  Link State
  MOV  BX,SI         ;Restore original
  MOV  AX,5801h      ;  Memory Allocation
  INT  21h           ;  Strategy
D90:                 ;Done
  MOV  AX,ES         ;Set
  CMP  CX,AX         ;  Return Flag
  POP  SI,DI         ;Restore used registers
  POP  DX,CX,BX,AX   ;Restore used registers
  RET


;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
;SPACE AND CODE TO PROCESS OUR PROGRAM STACK
;  This code and must be physically at the END of the Program,
;    but must be one of the FIRST procedures called by the Program.
;  In addition, the Stack Pointer (SP) must be set properly
;    (to LastProgByte - 2) BEFORE this code is called.
;±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

;------------------------------------------------------------------------------
;RESIZE OUR MEMORY ALLOCATION TO THE MINIMUM SIZE NEEDED
;Inputs:  SP = LastProgByte - 2
;         ES = Local Segment
;Outputs: Rellocates Memory to the minimum size required to run the program
;Changes:
;------------------------------------------------------------------------------
ResizeMemory:
  PUSH AX,BX  ;Save used registers
  MOV  AH,4Ah ;Function 4Ah (Resize Memory Block pointed at by ES)
  MOV  BX,(LastProgByte SHR 4) ;BX = Number of Paragraphs to Resize to
  INT  21h    ;Do it
  POP  BX,AX  ;Restore used registers
  RET

  EVEN 16
  DB (ProgStackSize/8) DUP ('PrgStack')

LastProgByte:
