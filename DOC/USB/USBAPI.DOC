

                              BIOS-LEVEL USB API 0.05
                              อออออออออออออออออออออออ

                                  Bret E Johnson
                                   June 30, 2009



                                 TABLE OF CONTENTS
                                 อออออออออออออออออ


     OVERVIEW  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4

     GENERAL NOTES ABOUT USB . . . . . . . . . . . . . . . . . . . . . . .  6

     OWNERSHIP REGISTRATION  . . . . . . . . . . . . . . . . . . . . . . .  7
       NOTIFICATION CODES  . . . . . . . . . . . . . . . . . . . . . . . . 10

     IMMEDIATE, SCHEDULE, AND LARGE TRANSACTIONS . . . . . . . . . . . . . 11
       STATUS CODES  . . . . . . . . . . . . . . . . . . . . . . . . . . . 14

     CALL BACK ADDRESSES & USER PACKET ID's  . . . . . . . . . . . . . . . 15

     INTERACTION BETWEEN MULTIPLE HOST DRIVERS . . . . . . . . . . . . . . 17

     IRQ's . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20

     HUBS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

     DEVICE ENUMERATION  . . . . . . . . . . . . . . . . . . . . . . . . . 23

     POWER DISTRIBUTION  . . . . . . . . . . . . . . . . . . . . . . . . . 26

     ROOT HUBS AND DEVICE ADDRESS 1  . . . . . . . . . . . . . . . . . . . 29

     MEMORY ADDRESSES  . . . . . . . . . . . . . . . . . . . . . . . . . . 31

     INT 14h API EXTENSIONS  . . . . . . . . . . . . . . . . . . . . . . . 33
       Install Check . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
       Transaction Request . . . . . . . . . . . . . . . . . . . . . . . . 34
       ERROR CODES . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35

     64-BYTE REQUEST STRUCTURE . . . . . . . . . . . . . . . . . . . . . . 37

     TRANSACTION REQUEST TYPES . . . . . . . . . . . . . . . . . . . . . . 42
       Get Host Software Information . . . . . . . . . . . . . . . . . . . 43
       Get Host Hardware Information . . . . . . . . . . . . . . . . . . . 44
       Get Host Vendor Information . . . . . . . . . . . . . . . . . . . . 46
       Get Host Status . . . . . . . . . . . . . . . . . . . . . . . . . . 47
       Host Run  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48


                 BIOS-LEVEL USB API 0.05            Page 1 of 168

       Host Stop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
       Host Reset  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
       Host Suspend (Global Suspend) . . . . . . . . . . . . . . . . . . . 53
       Host Resume (Global Resume) . . . . . . . . . . . . . . . . . . . . 55
       Register As Frame Timing Owner  . . . . . . . . . . . . . . . . . . 57
       Unregister as Frame Timing Owner  . . . . . . . . . . . . . . . . . 59
       Increment Frame Timing Factor (Slow Down Bus) . . . . . . . . . . . 60
       Decrement Frame Timing Factor (Speed Up Bus)  . . . . . . . . . . . 62
       Change Frame Timing Factor (By a Large Amount)  . . . . . . . . . . 64
       Get Device Hub Information  . . . . . . . . . . . . . . . . . . . . 66
       Notify Host Driver of New Device Connection . . . . . . . . . . . . 67
       Notify Host Driver of Device Disconnection  . . . . . . . . . . . . 69
       Send Hub Characteristics to Host Driver . . . . . . . . . . . . . . 71
       Enable Device Given Hub Address and Port  . . . . . . . . . . . . . 72
       Disable Device Given Hub Address and Port . . . . . . . . . . . . . 74
       Reset Device Given Hub Address and Port . . . . . . . . . . . . . . 76
       Suspend Device Given Hub Address and Port (Selective Suspend) . . . 78
       Resume Device Given Hub Address and Port (Selective Resume) . . . . 80
       Power On Device Given Hub Address and Port  . . . . . . . . . . . . 82
       Power Off Device Given Hub Address and Port . . . . . . . . . . . . 84
       Power Reset Device Given Hub Address and Port . . . . . . . . . . . 86
       Get Device Power Information  . . . . . . . . . . . . . . . . . . . 88
       Get Hub Power Draw  . . . . . . . . . . . . . . . . . . . . . . . . 89
       Power On Device Given Device Address  . . . . . . . . . . . . . . . 90
       Power Off Device Given Device Address . . . . . . . . . . . . . . . 92
       Power Reset Device Given Device Address . . . . . . . . . . . . . . 94
       Get Device Class Information  . . . . . . . . . . . . . . . . . . . 96
       Get Device Vendor Information . . . . . . . . . . . . . . . . . . . 97
       Get Device Status Information . . . . . . . . . . . . . . . . . . . 98
       Enable Device Given Device Address  . . . . . . . . . . . . . . .  100
       Disable Device Given Device Address . . . . . . . . . . . . . . .  102
       Reset Device Given Device Address . . . . . . . . . . . . . . . .  104
       Suspend Device Given Device Address . . . . . . . . . . . . . . .  107
       Resume Device Given Device Address (Selective Resume) . . . . . .  109
       Configuring Interface . . . . . . . . . . . . . . . . . . . . . .  111
       Configuring Interface Complete  . . . . . . . . . . . . . . . . .  113
       Reset Device and Set New Configuration  . . . . . . . . . . . . .  114
       Find Registered Interface . . . . . . . . . . . . . . . . . . . .  117
       Find Unregistered Interface . . . . . . . . . . . . . . . . . . .  119
       Register As Interface Owner . . . . . . . . . . . . . . . . . . .  121
       Register As Device 0 (New Interface) Owner  . . . . . . . . . . .  123
       Unregister As Interface Owner . . . . . . . . . . . . . . . . . .  126
       Unregister As Device 0 (New Interface) Owner  . . . . . . . . . .  127
       Unregister Current Interface Owner and Don't Look . . . . . . . .  128
       Get Alternate Interface Information . . . . . . . . . . . . . . .  130
       Get Current DataX Value . . . . . . . . . . . . . . . . . . . . .  131
       Increment (Toggle) DataX Value  . . . . . . . . . . . . . . . . .  132
       Schedule Isochronous Transaction  . . . . . . . . . . . . . . . .  134
       Schedule Periodic Interrupt Transaction . . . . . . . . . . . . .  137
       Schedule Control (Setup) Transaction  . . . . . . . . . . . . . .  139
       Schedule Bulk Transaction . . . . . . . . . . . . . . . . . . . .  143


                 BIOS-LEVEL USB API 0.05            Page 2 of 168

       Schedule One-Time Interrupt Transaction . . . . . . . . . . . . .  145
       Close Transaction Handle  . . . . . . . . . . . . . . . . . . . .  147
       Change Periodicity of Periodic Interrupt  . . . . . . . . . . . .  149
       Get Status of Packet Transaction  . . . . . . . . . . . . . . . .  150
       Large Call Completed  . . . . . . . . . . . . . . . . . . . . . .  154
       Beep the Speaker  . . . . . . . . . . . . . . . . . . . . . . . .  155
       A New Host Driver Has Been Installed  . . . . . . . . . . . . . .  157
       An Existing Host Driver Has Been Removed  . . . . . . . . . . . .  158
       InterHost Register As Device 0 Owner  . . . . . . . . . . . . . .  159
       InterHost Unregister As Device 0 Owner  . . . . . . . . . . . . .  162
       Copy the New Device Ownership Table . . . . . . . . . . . . . . .  163
       Put Host In Debug Mode  . . . . . . . . . . . . . . . . . . . . .  165
       Single Step Host (Debug Mode) . . . . . . . . . . . . . . . . . .  167








































                 BIOS-LEVEL USB API 0.05            Page 3 of 168

     OVERVIEW
     ออออออออ

     This document is a technical description of a BIOS-level USB API
     (Application Programming Interface) for an IBM-compatible computer.  The
     first actual implementation of this API is with a DOS TSR (Terminate-
     but-Stay-Resident) program, called USBUHCI.  Although the first
     implementation of this API is both operating system-specific (the OS
     being DOS) and USB hardware-specific (the hardware being UHCI), it is in
     fact intended to be a general-purpose, BIOS-level API.  The API (or
     something very similar to it) could, and in my opinion should, be
     implemented natively in the BIOS of all computers.  This would allow USB
     devices to be used in virtually any operating environment.

     This API is implemented as an extension to the BIOS serial services
     interrupt (INT 14h).  The API allows for control, monitoring, and
     scheduling of USB host resources, including device attachments and
     detachments, frame timing, transaction scheduling, hub control, and
     interaction between multiple host drivers.  The API is also designed to
     operate almost completely as a background operation.  This allows for
     true plug-and-play capabilities, even in single-tasking operating
     systems like DOS.

     This scope of this API includes control and monitoring of the host
     controller(s), the USB root hub(s), and the extension of the bus(ses) to
     external devices (including remote hubs).  The API specifically does not
     cover the multitude of different types of devices that may attach to the
     bus(ses), other than hubs.  This API will typically be implemented as a
     host driver, and there will then be one or more device/interface drivers
     for each bus-attached device/interface that the PC user wishes to
     use/control/monitor.  A remote hub is a special type of USB device, in
     that it is both a bus-attached device and also the mechanism that allows
     the physical and logical extension of the bus to other devices.  This
     API includes functions that allow the host driver(s) and hub driver(s)
     to communicate and provide that logical Bus extension.

     There can be multiple USB host controllers installed on a single
     computer.  The API addresses that situation, and allows up to 16 host
     controllers to be functioning on the same computer at the same time. 
     Host drivers can be installed in several different ways: natively (and
     permanently) in the BIOS, with permanent (non-removable) host drivers
     (usually loaded at boot time, e.g., via DOS's CONFIG.SYS or MS-Windows
     registry/WIN.INI/SYSTEM.INI), or with removable host drivers (e.g., a
     DOS TSR like USBUHCI).  It is desirable for the user to have complete
     control of if and when a particular USB host controller will be enabled. 
     This API includes functions that allow communication between different
     host drivers, and between host drivers and device/interface drivers, to
     allow individual host drivers to be added/removed/disabled/enabled at
     any time by the user.




                 BIOS-LEVEL USB API 0.05            Page 4 of 168

     This particular version of the API is written with intimate knowledge of
     only one particular type of USB host controller, specifically UHCI
     (Universal Host Controller Interface).  There are two other major types
     of host controllers currently in mass production: OHCI (Open Host
     Controller Interface) and EHCI (Enhanced Host Controller Interface, for
     USB 2.0 hosts).  There are also two types of Host Controllers under
     development, but not yet in mass production: WHCI (Wireless Host
     Controller Interface, for USB 2.5 (USB Certified Wireless) hosts), and
     XHCI (Extensible Host Controller Interface, for USB 3.0 hosts).  As
     actual programs are developed to control those particular types of
     hosts, this API will be modified accordingly.  It is expected that the
     changes needed in this API to be able to accommodate OHCI hosts will be
     relatively minor.  Changes required to accommodate other types of hosts,
     however, are expected to be significant.

     This document is written assuming the reader has a basic knowledge of
     USB architecture, which, to be perfectly frank, is pretty complicated. 
     If you don't understand the relationship between USB terms like host,
     frame, device, interface, alternate interface, end point, configuration,
     class, subclass, protocol, vendor, product, descriptor, isochronous,
     bulk, control, interrupt, report, in, out, etc., you'll need to read a
     USB specification or other similar document.  At times in this document,
     certain of these items will be described superfluously, but definitely
     not in enough detail for you to understand USB just by reading this API
     specification.  In fact, reading this document without some pre-existing
     knowledge of the USB architecture may frustrate and confuse your
     understanding of USB more than it helps you.


























                 BIOS-LEVEL USB API 0.05            Page 5 of 168

     GENERAL NOTES ABOUT USB
     อออออออออออออออออออออออ

     The USB architecture is a master/slave (polled), tree-shaped, packet-
     based architecture.  Packets of data are scheduled to get transferred
     across the bus, to be sent/received by an end point on a
     device/interface.  The scheduling request is issued to the host driver,
     which will attempt to transfer the packet across the bus hardware at the
     next available polling interval.  The host driver is in complete control
     of when and how everything happens on the bus.  Devices attached to the
     bus, and the device/interface drivers that control those devices, can
     only do things with the bus when the host driver lets them.

     One concept in USB that can be quite confusing is the difference between
     a device and an interface.  What most people would commonly think of as
     a "device" is usually (but not always) called an "interface" in USB. 
     For example, a keyboard and a mouse that are separate from each other
     are considered two separate devices, and each one has a single
     interface.  A combination keyboard/mouse is considered a single device,
     but has two different interfaces, which must be controlled separately. 
     A USB modem has two interfaces, one for the actual transfer of data and
     one for control of the modem (usually, control is performed with AT
     commands similar to a regular modem).  With a regular modem, though, you
     "toggle" back and forth between the data and control modes (usually with
     a "+++" command).  In the USB architecture, the "things" you control are
     usually called interfaces, not devices.

     Another thing that be quite confusing is the distinction (or lack
     thereof) between a piece of hardware (a host controller or a bus-
     attached device, like a remote hub or a mouse), and the software (host
     driver or device/interface driver) that enables a device to actually be
     used for something.  In this document, we will mostly be addressing the
     software (driver) that "enables" a particular hardware device.  However,
     because it takes both hardware and software to be able to do something
     useful, in this document we may at times use terms like "host
     controller" (the hardware) and "host driver" (the software)
     interchangeably.  We will generally try to use the appropriate terms at
     the appropriate times, so hopefully things will not get too confusing.

     The USB architecture, and USB devices in general, is notoriously
     unreliable.  There are some things that simply don't work correctly the
     first time you try them, and you need to just keep trying over and over
     again until it finally works.  Host drivers will, by default,
     automatically repeat (several times) processes that are known to be
     unreliable.  For example, all devices must go though a complicated
     initialization and enumeration process after they are first attached to
     the bus.  The initialization and enumeration process is unreliable, and
     the host driver will automatically repeat the entire process for a
     device up to 5 times before finally giving up.  This is discussed in
     detail below for the various situations where it applies.



                 BIOS-LEVEL USB API 0.05            Page 6 of 168

     OWNERSHIP REGISTRATION
     ออออออออออออออออออออออ

     At the core of this API is a concept called "ownership registration." 
     Understanding ownership registration is absolutely fundamental to
     understanding how the API works -- if you don't get a grasp of ownership
     registration, the API will make no sense at all.

     A host driver controls and monitors a particular USB bus and everything
     attached to that bus.  However, there are certain aspects (entities) of
     a bus that can be "owned" by a piece of software external to the host
     driver.  There are three different entities that can be owned by
     external software under this API: devices newly attached to the bus
     (also called device 0's), interfaces, and frame timing.

     The purpose of registering as the owner of an entity under the API is
     two-fold.  First of all, it provides a mechanism for the host driver to
     notify the entity owner when something has happened to the entity
     itself, or when something has happened on the bus that indirectly
     affects the entity.  For example, if a piece of software has registered
     as the owner of a particular interface on a device, the interface owner
     is notified by the host driver when the user disconnects the device from
     the bus.  The interface owner is also notified by the host driver if the
     user disconnects an upstream device (hub) that (indirectly) results in
     the owned interface also being disconnected from the bus.  The
     NOTIFICATION CODES table below (page 10) lists all of the different
     reasons a registered owner might be notified.

     The second reason for ownership registration is that it provides a form
     of "protection".  That is, only the owner of any particular entity is
     allowed to do things to control that entity.  For instance, only the
     registered owner of the frame timing is allowed to do anything that
     changes the frame timing.  Other software is allowed to monitor what the
     registered frame timing owner does to the frame timing, but only the
     owner is allowed to actually make changes.

     Having more than one piece of software own (control) an entity on the
     bus would almost guarantee disaster, so this API does not allow that to
     happen.  However, because of limitations in the way the bus is designed,
     it is possible for pieces of software (or the user) to do things that
     directly or indirectly affect entities that they do not own.  The
     ownership registration process minimizes those kinds of "protection
     violations", but, unfortunately, cannot eliminate them completely.










                 BIOS-LEVEL USB API 0.05            Page 7 of 168

     An entity owner registers by issuing an appropriate INT 14h request,
     which must include a call back address and a user packet ID.  The INT
     14h request will return with the carry flag indicating success or
     failure (CF = clear if success), an error code in AX (AX = 0 if
     success), and request-specific data in BX, CX, and DX.  Typically, part
     of the request-specific data returned will be a handle number in the CX
     register.  This handle number will be required for later requests, such
     as when it becomes necessary to un-register as the entity owner.

     After the owner of an entity has registered, the owner will be notified
     by the host driver(s) whenever anything happens that might affect how it
     operates (device connections and disconnections, frame timing changes,
     the host starting and stopping, etc.).  The complete list of
     NOTIFICATION CODES is detailed below on page 10.  The owner is notified
     by a call to the call back address that was provided during the original
     INT 14h ownership registration request, with the appropriate
     notification code in AX, the user packet ID (the same one that was
     provided by the entity owner during the original ownership registration
     request) in BX, and notification-specific data in CX and DX.  The rest
     of the "environment" related to the notification call (CPU flags, stack,
     etc.) is as detailed below in the "CALL BACK ADDRESSES & USER PACKET
     ID's" section (page 15).


     As noted before, this API is designed to operate almost completely as a
     background process.  The way it does this is by "tying" itself to
     hardware interrupts (IRQ's).  When a notification occurs, it is almost
     always being called from "inside" an IRQ processing routine.  This is of
     major concern if you are attempting to write a piece of software to
     interface with this API.  IRQ processing routines are very time-
     sensitive, and any program that is "tied" to a hardware IRQ needs to
     concern itself with efficiency.  If you are not accustomed to writing
     software for hardware IRQ processing, you may be in for some surprises.




















                 BIOS-LEVEL USB API 0.05            Page 8 of 168

     Let us briefly discuss each of the three types of ownership registration
     entities (new devices, interfaces, and frame timing).  When a piece of
     software registers as a new device (device 0) owner, it is telling the
     host driver(s) that it wants to be notified immediately when a certain
     kind of device/interface is first attached to the bus.  As part of the
     "Register As Device 0 (New Interface) Owner" request (detailed below on
     page 123), the owner provides a profile (vendor ID, product ID, device
     class/subclass/protocol, and interface class/subclass/protocol) of the
     device(s)/interface(s) it would like to be notified of.  For example, an
     owner could choose to be notified of every new device/interface that
     gets attached to the bus, or only certain devices/interfaces (e.g., all
     human interface devices, all mice, all Logitech mice, or just Logitech
     model XXX mice).  If a new device is attached to the bus, but none of
     its interfaces match the device 0 owner's profile, the owner will not be
     notified.  Note that a device/interface driver is still able to "find"
     all of the appropriate interfaces it may want to own, even if it is not
     registered as a device 0 owner.

     The second type of ownership registration is registering as the owner of
     an interface.  When a piece of software registers as an interface owner,
     it is telling a host driver that it "owns" one particular interface on
     one particular device.  The owner will be notified of anything that
     happens on the bus that might affect the operation of the interface
     (device disconnects, resets, enables/disables, etc.).  Although it is
     not enforced by the host driver, the owner of an interface is the only
     software allowed to modify anything functional regarding an interface
     (e.g., selecting an alternate interface).  In addition, the owner is the
     only software allowed to download/upload any "real" data from/to the
     interface (typically, "real" data comes from an endpoint other than
     endpoint 0).  The "Register As Interface Owner" request is explained in
     detail below on page 121.

     The last type of ownership registration is registering as the frame
     timing owner.  When a piece of software registers as the frame timing
     owner, it is the only software allowed to speed up or slow down the bus. 
     The bus nominally runs at 12 Mbps, but can be adjusted to run slightly
     slower or slightly faster than that.  The only time it should be
     necessary to adjust the frame timing is if there is an isochronous
     device attached to the bus, and that isochronous device must be
     synchronized to an external clock of some sort.  Details on the
     "Register As Frame Timing Owner" request are given below on page 57.












                 BIOS-LEVEL USB API 0.05            Page 9 of 168

                                NOTIFICATION CODES
               (Sent to Entity Owners regarding Bus/Device Changes)

      ษออออออออออออออออออออออัอออออัออออออออออออออออออออออออออออออออออออออออป
      บ       Mnemonic       ณValueณ             Description                บ
      ฬออออออออออออออออออออออุอออออุออออออออออออออออออออออออออออออออออออออออน
      บOwnerCallNewDvc       ณ0001hณNew Device Attached                     บ
      บOwnerCallDvcDisc      ณ0002hณRegistered Device Disconnected          บ
      บOwnerCallDvc0Disc     ณ0003hณUnregistered Device Disconnected        บ
      บOwnerCallDontLook     ณ0007hณStop Looking for New Interfaces         บ
      บOwnerCallDvcEnable    ณ0008hณDevice Enabled                          บ
      บOwnerCallDvcDisable   ณ0009hณDevice Disabled                         บ
      บOwnerCallDvcReset     ณ000AhณDevice Resetting                        บ
      บOwnerCallDvcSuspend   ณ000BhณDevice Suspended                        บ
      บOwnerCallDvcResume    ณ000ChณDevice Resumed                          บ
      บOwnerCallDvcPwrOn     ณ000DhณDevice Powered On                       บ
      บOwnerCallDvcPwrOff    ณ000EhณDevice Powered Off                      บ
      บOwnerCallDvcPwrReset  ณ000FhณDevice Power Reset                      บ
      วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤลฤฤฤฤฤลฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
      บOwnerCallNewHost      ณ0011hณNew Host Driver Installed               บ
      บOwnerCallHostDisc     ณ0012hณExisting Host Driver Uninstalled        บ
      บOwnerCallHostHWErr    ณ0017hณHost Hardware Error (Host will be Reset)บ
      บOwnerCallHostRun      ณ0018hณHost Running                            บ
      บOwnerCallHostStop     ณ0019hณHost Stopped                            บ
      บOwnerCallHostReset    ณ001AhณHost Resetting                          บ
      บOwnerCallHostSuspend  ณ001BhณHost Suspended                          บ
      บOwnerCallHostResume   ณ001ChณHost Resumed                            บ
      บOwnerCallHostDebug    ณ001DhณHost in Debug Mode                      บ
      บOwnerCallHostSST      ณ001EhณHost Single-Stepped                     บ
      บOwnerCallTimingChg    ณ0021hณHost Frame Timing Changed               บ
      วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤลฤฤฤฤฤลฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
      บHubCallEnumerated     ณ0077hณNew/Reset Device has been Enumerated    บ
      บHubCallEnable         ณ0078hณEnable Device                           บ
      บHubCallDisable        ณ0079hณDisable Device                          บ
      บHubCallReset          ณ007AhณReset Device                            บ
      บHubCallSuspend        ณ007BhณSuspend Device (Selective Suspend)      บ
      บHubCallResume         ณ007ChณResume Device                           บ
      บHubCallPwrOn          ณ007DhณPower On Device                         บ
      บHubCallPwrOff         ณ007EhณPower Off Device                        บ
      บHubCallPwrReset       ณ007FhณPower Reset Device                      บ
      วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤลฤฤฤฤฤลฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
      บOwnerCallDvcDiscUS    ณ0082hณDevice Disconnected Upstream            บ
      บOwnerCallDvcEnableUS  ณ0088hณDevice Enabled Upstream                 บ
      บOwnerCallDvcDisableUS ณ0089hณDevice Disabled Upstream                บ
      บOwnerCallDvcResetUS   ณ008AhณDevice Reset Upstream                   บ
      บOwnerCallDvcSuspendUS ณ008BhณDevice Suspended Upstream               บ
      บOwnerCallDvcResumeUS  ณ008ChณDevice Resumed Upstream                 บ
      บOwnerCallDvcPwrOnUS   ณ008DhณDevice Powered On Upstream              บ
      บOwnerCallDvcPwrOffUS  ณ008EhณDevice Powered Off Upstream             บ
      บOwnerCallDvcPwrResetUSณ008FhณDevice Power Reset Upstream             บ
      ศออออออออออออออออออออออฯอออออฯออออออออออออออออออออออออออออออออออออออออผ


                 BIOS-LEVEL USB API 0.05            Page 10 of 168

     IMMEDIATE, SCHEDULE, AND LARGE TRANSACTIONS
     อออออออออออออออออออออออออออออออออออออออออออ

     There are many different types of INT 14h requests in this API.  Some
     INT 14h requests initiate transactions that are relatively simple and
     straightforward, while others initiate transactions that are extremely
     complicated and time-consuming.  It is convenient to classify INT 14h
     requests into three different "categories": immediate, schedule, and
     large.  These categories have to do with how and when the transaction
     initiated by the INT 14h request is truly "completed."

     Immediate transactions are like most INT transactions you would deal
     with on a regular basis: they are completely finished as soon as the INT
     14h request returns.  The INT 14h request will return with the carry
     flag indicating success or failure (CF = clear if success), an error
     code in AX (the complete ERROR CODE table is detailed below on page 35),
     and some sort of transaction-specific data in BX, CX, and DX.

     Just like immediate transactions, schedule transactions and large
     transactions also return from the INT 14h request with the carry flag
     indicating success or failure, AX containing an error code, and
     transaction-specific data in BX, CX, and DX.  However, a successful
     schedule or large transaction is not actually complete when the INT 14h
     request returns.  When successful schedule or large transactions return
     from the INT 14h request, a background process has been scheduled
     (usually on the USB bus).  The background process will actually be
     completed at some other (usually much later) point in time.  Exactly
     when the background process might complete depends on several factors,
     including the specific type of transaction and the current state of the
     USB hardware and bus.

     As part of the INT 14h request to initialize the schedule or large
     transaction, the requester provides a call back address (segment:offset)
     that will be called (notified) when the background process has been
     completed.  In addition to a call back address, the requester also
     provides a user packet ID.  A user packet ID is simply a word (two
     bytes) that is "returned" to the requester at the end of the process (in
     the BX register) when the call back address is called.  The user packet
     ID can be an index, a pointer, or whatever the requester may want it to
     be.













                 BIOS-LEVEL USB API 0.05            Page 11 of 168

     The difference between a schedule transaction and a large transaction
     lies in exactly how complicated the scheduled background process is. 
     With a schedule transaction, what is scheduled is a single packet
     transaction on the bus (in USB terminology, a single transfer descriptor
     is created).  A transfer descriptor (TD) will complete with one or more
     status codes (the complete STATUS CODE table is detailed below on page
     14).  Since a TD can actually complete with more than one status code at
     the same time, the individual status codes are bit-mapped and are OR'd
     together to get the complete TD status code for a schedule transaction. 
     At the end of a schedule transaction, the call back address is called
     with the complete TD status code in AX, the user packet ID in BX, and
     transaction-specific data in CX and DX.


     A large transaction is very similar to a schedule transaction.  However,
     what a large transaction schedules to occur in the background is not
     simply a single USB packet (transfer descriptor or TD).  Instead, what
     is scheduled by a large transaction is a complicated series of "sub-
     transactions."  This may include one or more schedule-type transactions
     (transfer descriptors), it may include other types of "sub-processes"
     that do not necessarily even involve packets traversing the bus, and may
     also include some "logic" so that exactly what happens depends on the
     current state of something related to the bus.  What happens during a
     large transaction is, in fact, so complicated that it is not possible to
     generate a status code at the end of it that has any specificity.  That
     is, the status code at the end of a large transaction will either be 0
     (TDStsOK) or 8000h (TDStsLargeCallErr), with no further details
     available as to why the transaction might have failed.  Just as in a
     schedule transaction, at the end of a large transaction, the call back
     address is called with the status code in AX, the user packet ID in BX,
     and transaction-specific data in CX and DX.  Other than the specificity
     of the status code during the call back, a large transaction and a
     schedule transaction appear pretty much the same to the requester.


     There are certain states of the bus where certain kinds of schedule and
     large transactions can actually be completed immediately, and do not
     actually need to be "scheduled".  An example of this would be a request
     to start the host running (see page 48 below), when the host is already
     running.  In such a situation, it is possible (in fact, likely) that the
     transaction call back process will actually occur BEFORE the INT 14h
     request is completed.  This is backwards from what normally happens
     (typically, the call back process occurs at some point in time much
     later than the INT 14h request returns).  If you are writing a program
     to interact with this USB API, this can be a source of extremely-hard-
     to-find (and typically very intermittent) program bugs.  Consider
     yourself forewarned.






                 BIOS-LEVEL USB API 0.05            Page 12 of 168

     There is also one particular status code that is "special", and works a
     little bit differently than the rest: TDStsDvcRemoved (2000h).  This
     particular status code is returned when the host driver detects that a
     device has been removed from the bus (physically unplugged or reset)
     while the transfer descriptor (TD) was in progress, thereby making it
     impossible for the TD to complete.  There are three things that are
     "special" about TDStsDvcRemoved.  Firstly, the TDStsDvcRemoved status
     code is not combined (OR'd) with any other status codes at the same
     time.

     Secondly, when a TD returns with a status code of TDStsDvcRemoved in AX,
     CX and DX are always returned as 0.  For most transactions, CX contains
     the number of data bytes that were successfully transferred by the TD. 
     When a device is disconnected while a TD is in progress, some or all of
     the data associated with the TD may, in fact, have been transferred
     successfully before the disconnect occurred.  Unfortunately, the host
     driver has no way of knowing how many bytes were actually transferred
     unless it can communicate with the device, which is impossible since the
     device is no longer attached to the bus.  Therefore, the host driver
     must assume that no data was able to be transferred, and so returns with
     CX = 0.

     Lastly, when a TD returns with a status code of TDStsDvcRemoved, the TD
     is automatically unscheduled and deleted, even if it is a periodic
     transaction (periodic interrupt or isochronous transaction).  Normally,
     periodic transactions can only be terminated with a "Close Transaction
     Handle" request (page 147)., but the host driver performs this function
     automatically when a device is disconnected from the bus.

























                 BIOS-LEVEL USB API 0.05            Page 13 of 168

                                   STATUS CODES
        (Sent to Transfer Descriptor (TD) Requester at end of Transaction)
                        (Multiple Errors are OR'd together)

       ษอออออออออออออออออออัอออออัอออออออออออออออออออออออออออออออออออออออออป
       บ     Mnemonic      ณValueณ               Description               บ
       ฬอออออออออออออออออออุอออออุอออออออออออออออออออออออออออออออออออออออออน
       บTDStsOK            ณ0000hณACK Received (Complete/No Errors)        บ
       วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤลฤฤฤฤฤลฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
       บTDStsNAKReceived   ณ0001hณNAK Received                             บ
       บTDStsStalled       ณ0002hณStalled                                  บ
       บTDStsTimeout       ณ0004hณTimed Out (Bulk/Control)                 บ
       บTDStsOverDue       ณ0008hณOverdue (Isoch/Interrupt)                บ
       วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤลฤฤฤฤฤลฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
       บTDStsShortPacket   ณ0010hณShort Packet Detected                    บ
       บTDStsBabbleDetectedณ0020hณBabble Detected                          บ
       บTDStsCRCTOReceived ณ0040hณCRC/Timeout Error Received               บ
       บTDStsBitStuffError ณ0080hณRx Data contained > 6 ones in a row      บ
       วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤลฤฤฤฤฤลฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
       บTDStsDataBuffErr   ณ0100hณData Buffer Error (Overflow/Underflow)   บ
       วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤลฤฤฤฤฤลฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
       บTDStsControlSetup  ณ1000hณError occurred during Control Setup Stageบ
       บTDStsDvcRemoved    ณ2000hณDevice Removed while TD was in progress  บ
       บTDStsLargeCallErr  ณ8000hณError During Large Call                  บ
       ศอออออออออออออออออออฯอออออฯอออออออออออออออออออออออออออออออออออออออออผ


     The codes in this status code table can come from any of several
     different sources.  Many of the status codes are caused by hardware- or
     bus-related problems.  For those kinds of errors, the host driver is
     simply "passing through" the same error information that it received
     from the host hardware.  The codes that fall into this category are
     TDStsNAKReceived, TDStsStalled, TDStsShortPacket, TDStsBabbleDetected,
     TDStsCTCTOReceived, TDStsBitStuffError, TDStsDataBuffErr, and
     TDStsControlSetup.

     TDStsDvcRemoved is generated when a device is removed (unplugged or
     reset) from the bus.

     The remaining status codes (TDStsTimeout, TDStsOverDue, and
     TDStsLargeCallErr) are generated by the host driver itself.  These
     status codes are not necessarily directly related to problems on the bus
     hardware (though they can be indirectly related) -- many times these
     status codes are caused by unresponsive devices attached to the bus.









                 BIOS-LEVEL USB API 0.05            Page 14 of 168

     CALL BACK ADDRESSES & USER PACKET ID's
     ออออออออออออออออออออออออออออออออออออออ

     One fairly common theme in this API are the concepts of call back
     addresses and user packet ID's.  These things are required for certain
     types of INT 14h transactions: Ownership registrations (device 0,
     interface, and frame timing), as well as schedule transactions and large
     transactions.  While these types of transactions may appear to be very
     different from each other, the CallBack/Notification process is handled
     in pretty much the same way from a technical perspective.  That process
     is discussed here.

     We do, however, need to separate the call backs into two different
     "categories": transaction status call backs (schedule transactions and
     large transactions), and ownership notification call backs (device 0,
     interface, and frame timing ownership registration notifications).  This
     is necessary for a couple of different reasons.  First of all, it is
     possible to provide a "null" or "fake" call back address (exactly how to
     do this is discussed a couple of paragraphs down - keep reading).  A
     null call back address is "ignored" at the time of the
     callback/notification - that is, the call back process never actually
     occurs.  Most of the time, the requester of a transaction will want to
     know when a background process is complete, but (believe it or not)
     there are times when it is actually quite useful to not know.

     You can provide a null address for a transaction status call back, but
     the address for an ownership notification call back can NOT be null (it
     must be a real address that actually does something).  Ownership
     notifications are discussed above in the "OWNERSHIP REGISTRATION"
     section (page 7), and are issued when various kinds of events happen on
     the bus that may affect how a device or program operates.  The owner
     notification call back address is called, for instance, when an
     appropriate device is connected or disconnected from the bus, if the
     host is stopped for some reason, if the bus is put into suspend mode,
     etc.  A legitimate ownership notification call back address must be
     provided.

     The second reason we need to differentiate between ownership
     notification call backs and transaction status call backs are because of
     the types of codes that get issued during the call.  During a
     callback/notification, the user packet ID is in the BX register, call-
     specific data is in the CX and DX registers, and there is a code in the
     AX register.  For ownership notifications, the code in the AX register
     is a notification code (see the NOTIFICATION CODE table above on page
     10).  For a transaction call back, the code in the AX register is a
     status code (see the STATUS CODE table above on page 14).







                 BIOS-LEVEL USB API 0.05            Page 15 of 168

     A call back address must always be provided in a standard segment:offset
     format.  A null call back address (an "ignored" call back address) can
     either have a segment of 0000h, or an offset of FFFFh (neither of which
     would exist in a real, functional code address).  If the segment is
     anything other than 0000h, and the offset is anything other than FFFFh,
     the call back address is considered legitimate.

     Immediately before calling the callBack/notification code, the host
     driver sets up the following "environment" for the callBack/notification
     code to run in.  The host driver performs the following procedures
     (though not necessarily in this order) immediately before calling the
     callBack/notification address:

        1. If the call back address is null (segment = 0000h or offset =
           FFFFh), does nothing.
        2. Saves CPU flags register (PUSHF).
        3. Saves all general CPU registers ({E}AX, {E}BX, {E}CX, {E}DX,
           {E}DI, {E}SI, {E}BP, and {E}SP).
        4. Saves all segment registers (DS, ES, {FS}, {GS}, SS).
        5. Sets AX, BX, CX, and DX registers as appropriate for the call: AX
           contains the status or notification code, BX contains the user
           packet ID, and CX and DX contain transaction-specific or
           notification-specific values.
        6. Sets string functions to go forward (CLD).
        7. Enables interrupts (STI).
        8. Initializes zero flag and sign flag (OR AX,AX).
        9. Sets all segment registers, except SS, to the same value: The
           segment (CS) of the call back address (DS = ES = {FS} = {GS} =
           CS).
       10. All that is expected of the call back code is to preserve stack
           integrity and end with a RETF.  The call back code does not need
           to preserve registers or flags.
       11. The call back code will almost always be called as part of a
           hardware interrupt (IRQ) processing routine, which makes it speed-
           sensitive.  IRQ processes should be completed as quickly as
           possible in order to keep the computer running efficiently.  If
           the call back code can consume a significant amount of time, it is
           usually best to simply have the call back code set some kind of
           semaphore flag or counter indicating that it has happened.  The
           time-consuming part of the code can be performed at some later
           point in time, outside the critical timing constraints of the IRQ.












                 BIOS-LEVEL USB API 0.05            Page 16 of 168

     INTERACTION BETWEEN MULTIPLE HOST DRIVERS
     อออออออออออออออออออออออออออออออออออออออออ

     It is possible for there to be several host controllers installed on the
     same computer, and each one will need a complementary host driver to
     enable it.  In theory, it would be possible to have a single, large,
     monolithic host driver capable of enabling all different types and
     quantities of host controllers, but this would not be a practical
     solution.  Instead, it is much more efficient to install several
     independent host drivers, one for each host controller.  From the
     perspective of the outside world, though, the API must provide a single,
     uniform interface that makes it appear as though there is only one
     monolithic driver.

     The API services are provided as an extension to the BIOS serial
     services interrupt, INT 14h.  Like all interrupts, INT 14h is chained,
     and whenever a new host driver is installed into memory it becomes the
     first program to receive an INT 14h request when it is issued.  In
     addition, it is possible for the user to uninstall or disable any of the
     host drivers at any time, even if they are not the most recent host
     driver to be installed.  Therefore, each individual host driver must be
     capable of being the only host driver installed, as well as being the
     first, middle, or last host driver in a "chain" of installed host
     drivers.  In order to accomplish this, every host driver must have some
     basic knowledge of every other host driver that is installed.

     The first host driver to receive a USB-related INT 14h request (usually
     the last host driver that was installed into memory) is responsible for
     certain error-checking functions.  A USB-related INT 14h request has
     several data fields containing details about the exact type of request,
     one of which is the host index.  The API allows for a total of 16 host
     drivers, with specific host indexes numbered from 0-15.  The first host
     driver to receive a request for a specific host index is responsible for
     checking the validity of the requested host index, even if the first
     host driver is not the host driver associated with the host index.  If
     the host index is invalid, the first host driver to receive the request
     is responsible for returning the appropriate error code to the calling
     program.  If the host index is valid, and the first host driver is the
     driver associated with the index, it will then complete the processing
     of the request.  If the host index is valid, but the first driver is not
     the one associated with the index, it will pass the request down the INT
     14h chain to the appropriate driver for processing.  An invalid request
     must not be allowed to "pass through" the INT 14h chain to a non-USB
     interrupt handler, where it will be improperly processed.









                 BIOS-LEVEL USB API 0.05            Page 17 of 168

     In addition, there are certain types of USB-related INT 14h requests
     that are not directed at a specific host index, but rather are directed
     at any or all host drivers.  The host index for such requests is 255,
     rather than a number between 0 and 15 as it is for specific hosts. 
     There are certain types of requests that are directed at ANY host
     driver, and must be processed by the first host driver with no "help"
     from other host drivers.  An example of this is the "Get Host Hardware
     Information" request with a host index of 255, which is discussed below
     on page 44.

     There are also certain types of requests that are directed at ALL host
     drivers (rather than ANY host driver), and can be thought of as a
     "broadcast request".  When one of these requests is issued, the first
     host driver to receive the request is responsible for "translating" the
     request into an appropriate sub-request, and then issuing individual
     sub-requests to each separate host driver through separate INT 14h sub-
     Requests.  An example of this is the "Register As Device 0 (New
     Interface) Owner" request, and the related "InterHost Register As Device
     0 Owner" sub-request (discussed below on pages 123 and 159,
     respectively).


     A very important and integral part of this API is the process of
     ownership registration, wherein a device/interface driver registers as
     the owner of an entity (this is discussed in great detail in the
     "OWNERSHIP REGISTRATION" section above on page 7).  A piece of software,
     external to the host driver(s), can "own" certain new devices that get
     attached to the bus (device 0 ownership).  A piece of software that
     "owns" a newly attached device (device 0) is automatically informed by
     the host driver(s) when an appropriate new device is attached to the
     bus.

     There is a special "new device ownership table" that keeps track of all
     of the device 0 ownership registrations, and it has a specific format
     (detailed in the "Copy The New Device Ownership Table" request below,
     page 163).  Remember that individual host drivers can be added/removed
     from memory at any time, so each host driver must be capable of being
     the only, first, middle, or last host driver in memory at any time. 
     Therefore, every host driver must maintain its own copy of the new
     device ownership table, and every copy in every host driver must be
     EXACTLY the same as all of the others.  Several requests in the API are
     specifically designed to allow different host drivers to "share" the
     contents of the new device ownership table.  They are detailed below in
     the "TRANSACTION REQUEST TYPES" section (starting on page 42).









                 BIOS-LEVEL USB API 0.05            Page 18 of 168

     If a host driver is the only host driver remaining in memory, and there
     are any valid entries in the new device ownership table, the host driver
     cannot be removed from memory.  Doing so could cause the computer to
     crash, since a device 0 owner could issue a faulty request under the
     assumption that at least one host driver (and consequently this API) was
     still installed in memory.  Although device 0 owners are notified when
     host drivers are added and removed from memory, they are not required to
     keep track of the number of host drivers currently installed.  In
     particular, they are not required to "know" that the last host driver
     has been removed, and that consequently the API is no longer installed. 
     The last host driver cannot be removed from memory if there is any
     possibility that another "dependent" program might be under the
     assumption that the API is still installed.

     As an example of the interaction between multiple host drivers, here are
     the general steps that a new host driver must go through as it is being
     initialized (assuming that it is not the first host driver in memory):

     1.  The new host driver issues an "Install Check" request (page 33), to
         determine whether or not the API is already installed (whether or
         not there is at least one other host driver already installed in
         memory).

     2.  The new host driver issues a "Get Host Hardware Information" request
         with I14RHostIndex = 255 (page 44), to determine which host indexes
         are already being used by other host drivers.  The new host driver
         "grabs" an unused host index for itself to use.

     3.  The new host driver issues a "Copy the New Device Ownership Table"
         request (page 163), to obtain a copy of the new device ownership
         table from the existing host driver(s).

     4.  The new host driver assumes control of INT 14h, and becomes the
         first USB host driver to receive INT 14h requests.

     5.  The new host driver issues a "New Host Driver Has Been Installed"
         request (page 157), to inform all the other host drivers, and
         consequently all device/interface drivers, of its existence.















                 BIOS-LEVEL USB API 0.05            Page 19 of 168

     IRQ's
     อออออ

     Each USB host controller requires an IRQ (hardware Interrupt ReQuest) to
     operate.  There are a very limited number of IRQ's available on a
     computer (16).  Several of the IRQ's are dedicated to specific
     functions, and cannot be used by USB host controllers.  Most modern
     computers have several host controllers (my newest computer has eight of
     them), and it is rarely possible for each USB host controller to have
     its own dedicated IRQ (there simply aren't enough IRQ's to go around). 
     Rather, two or more USB host controllers must many times "share" the
     same IRQ.  In addition, at least on some computers, an IRQ used for a
     USB host controller must also be shared with some other (non-USB)
     hardware, such as a FireWire or BlueTooth controller.

     "Sharing" IRQ's is a tricky proposition in DOS.  There has been a long-
     standing rule-of-thumb with DOS programmers that states that IRQ's
     cannot be shared, though that is not at all true.  IRQ's can be shared
     in DOS, as long as the software is written correctly.  USB host driver
     software MUST be designed to share IRQ's.

































                 BIOS-LEVEL USB API 0.05            Page 20 of 168

     HUBS
     ออออ

     A USB hub is a very interesting type of device.  It is in one respect
     simply another device that can be attached to the bus, but is also very
     special because it is the mechanism that allows the physical and logical
     extension of the bus to other devices.  Host drivers "extend" their
     control of the bus, and all devices attached to the bus, by being able
     to control the hubs.

     To enable, disable, reset, suspend, resume, power on, or power off a
     particular device, the host driver does not actually do anything
     directly to the device it is trying to control.  Instead, what the host
     driver does is do something to the port of the upstream hub that the
     device is attached to.  For example, let's assume that the user wants to
     disable a particular device.  Here are the steps that actually occur in
     order to make that happen:

     1.  A "Disable Device Given Device Address" request (page 102) is issued
         to the host driver.  Among other things, the request contains the
         address of the device to be disabled, and a call back address to be
         notified when the disable process (which runs in the background) is
         complete.

     2.  The host driver internally "translates" the device address from the
         request to a hub address and port number (the port that the device
         is attached to).  The host driver notifies the appropriate hub
         interface owner (the hub driver), with notification code =
         HubCallDisable.  The notification includes the host index, hub
         address, hub port number, and a large call index.

     3.  The hub driver issues a "Schedule Control (Setup) Transaction"
         request (page 139) to the host driver, sending a control packet
         across the bus to the hub hardware telling it to disable the port.

     4.  The hub driver issues another "Schedule Control (Setup) Transaction"
         request (page 139) to the host driver, sending a control packet
         across the bus to the hub hardware to verify that the port has
         actually been disabled.

     5.  The hub driver issues a "Large Call Completed" request (page 154) to
         the host driver.  The request contains a status code indicating
         success or failure of the hub driver's attempt to disable the port. 
         The request also "returns" the large call index back to the host
         driver.

     6.  The host driver informs (calls back) the original INT 14h requester
         of the status of the request (status code = TDStsOK or
         TDStsLargeCallErr).




                 BIOS-LEVEL USB API 0.05            Page 21 of 168

     7.  If the device was successfully disabled, the host driver notifies
         all interface owners on the device that the device has been disabled
         (notification code = OwnerCallDvcDisable).

     8.  If the device was successfully disabled, and the device is a hub,
         the host driver notifies all interface owners of all devices
         downstream of the hub that an upstream device has been disabled
         (notification code = OwnerCallDvcDisableUS).


     This example hopefully illuminates the complicated interactions that
     take place between host drivers and hub drivers.  There are special
     kinds of messages that are sent back and forth between host drivers and
     hub drivers, which are not needed for any other type of device.  The
     NOTIFICATION CODE table above (page 10) lists all of the different codes
     that a host driver may use to notify an interface owner.  There is a
     special section of the table, where the mnemonic starts with "HubCall"
     (instead of "OwnerCall"), that only applies to hub interface owners. 
     The HubCall notifications are special notifications that are needed to
     be sent by a host driver to a hub driver in order to control the bus.


     There is also a special INT 14h request that is issued by a hub driver
     to a host driver, that is not needed for any other type of device except
     a hub.  It is the "Send Hub Characteristics to Host Driver" request, and
     is detailed below on page 71.  Immediately after a hub driver registers
     as owner of the hub (immediately after it has issued the "Register As
     Interface Owner" request), it must issue a "Send Hub Characteristics to
     Host Driver" request to notify the host driver of certain power-related
     characteristics of the hub.  There is a more detailed discussion of this
     in the "Power Distribution" section below (page 26).






















                 BIOS-LEVEL USB API 0.05            Page 22 of 168

     DEVICE ENUMERATION
     ออออออออออออออออออ

     There is a complicated process in the USB architecture called device
     enumeration.  This is the process where a device newly attached to a bus
     is recognized, initialized, configured, and assigned an address.  Every
     device attached to the bus must go through the enumeration process
     before it can be used.

     Under this API, there are three different ways to initiate the
     enumeration process.  The first way is to physically attach (or
     disconnect and then re-attach) a device to an open port on a hub.  This
     is the "standard" way to start the enumeration process.

     The second way to initiate the enumeration process is to issue a "Reset
     Device Given Device Address" request (page 104).  Resetting a device
     that is already attached to the bus is functionally equivalent to
     physically disconnecting and then re-attaching a device, but does not
     require physical manipulation of the device (which can sometimes be a
     HUGE pain in the backside).

     The last way to begin the enumeration process is to issue a "Reset
     Device and Set New Configuration" request (page 114).  This is
     functionally similar to a simple reset (discussed in the previous
     paragraph);  however, a Set New Configuration request allows the user to
     select the configuration value that the device will have after the
     enumeration process is complete, while a simple reset will only set the
     default configuration value (one) for the device.

     Regardless of how the enumeration process is initiated, the process
     itself is rather complicated.  It involves a high degree of interaction
     between the host driver and hub driver of the hub that the new device is
     attached to.  Following is a summary of that process:

     1.  The hub driver is continually polling the hub hardware for changes
         in status.  When the hub hardware detects that a new device has been
         attached to one of its ports, it informs the hub driver at the next
         opportunity (during the next status poll).  If a device was recently
         reset, it will look like a newly attached device to the hub
         hardware.

     2.  The hub driver verifies that the new device is disabled by the hub
         hardware, and waits at least 100 milliseconds for power to stabilize
         on the new device.  The hub driver then verifies that the new device
         is still attached to the hub hardware, and obtains the speed (low,
         full, or high) of the new device from the hub hardware.

     3.  The hub driver then issues a "Notify Host Driver of New Device
         Connection" request (page 67) to the host driver.

     4.  The host driver initializes its "enumeration retry counter" to five.


                 BIOS-LEVEL USB API 0.05            Page 23 of 168

     5.  The host driver notifies the hub driver to reset the new device,
         which in turn causes the hub driver to issue a control request back
         to the host driver, which sends a control packet across the bus to
         the hub hardware to perform the reset.

     6.  The host driver issues several control requests to the new device to
         assign it an address, and to obtain basic information about the
         device (e.g., the host driver downloads the device, configuration,
         interface, and end point descriptors from the new device).

     7.  The host driver issues a control request to the new device to set
         its configuration value.  The default configuration value for a new
         device is one, but other configuration values can be assigned using
         the "Reset Device and Set New Configuration" request (page 114).

     8.  If the new device supports the remote wakeup feature, the host
         driver issues a control request to the new device to enable the
         feature.

     9.  If the entire enumeration process was successful, the host driver
         issues a notification to the hub driver to inform the hub driver
         that the enumeration process is complete.  Part of the notification
         to the hub driver includes the address of the new device (a number
         between 2 and 127).  If the device is configured (has a
         configuration value other than zero), the host driver notifies all
         device 0 owners (registered in the new device ownership table) whose
         profiles match the attributes of the new device, informing the
         device 0 owners of the new device attachment.

         If the enumeration process did not work correctly for any reason,
         the host driver decrements the "enumeration retry counter".  If the
         counter has not reached zero, the host driver waits three seconds
         and then repeats this entire process beginning at stage 5.

         If the counter has reached zero 0 (the enumeration process has been
         tried five times with no success), the new device is declared to be
         "bad" by the host driver.  The host driver notifies the hub driver
         to disable the device, which in turn causes the hub driver to issue
         a control request to the hub hardware (via the host driver) to
         disable the port that the new device is attached to.  The host
         driver also notifies the hub driver that the device is bad, by
         telling the hub driver that the device has address 255 instead of
         telling it that it has a legitimate address (between 2 and 127).










                 BIOS-LEVEL USB API 0.05            Page 24 of 168

     A host driver must "assign" an address to a bad device, even though the
     host driver is the only entity that knows what the "fake" address is. 
     The hub driver that is controlling the hub that the device is attached
     to will never know what the address is, since the hub driver is told
     that the "bad" device has address 255 (which is an "illegal" address).

     Having a fake address assigned by the host driver allows the user to
     still manipulate the bad device, performing actions such as powering off
     or resetting the device.  The host driver must respond to all requests
     regarding the bad device, returning information much as if the device
     were OK.  Of course, the host driver may not know much, if anything,
     about the bad device, so the host driver must in some cases return
     "fake" information about the device (returning all zeroes in the status
     registers it does not actually know).  For example, if a "Get Device
     Class Information" request (described below on page 96) is issued for a
     bad device, the host driver will return successfully, but values in
     status registers (including the USB version returned in the CH register)
     will be 0 if the host driver was unable successfully download the device
     descriptor from the device.  The "Get Device Status Information" request
     (discussed below on page 98) specifically returns a flag indicating that
     a device is bad, as well as some information about the stage of the
     reset/enumeration process where the problem occurred.

     After a device has been attached to the bus, powered up, and reset, it
     automatically responds to address 0.  As part of the enumeration
     process, the host driver attempts to assign the device a "real" address
     (something other than zero).  Only one device at a time can respond to
     any particular address, including address zero.  Therefore, there can
     only be one device at a time on any particular bus in the enumeration
     process, and the enumeration process itself can take many seconds to
     complete.  While there can be many active (already enumerated) devices
     on the bus at the same time (in effect, multitasking), this can only
     happen after all of the devices are enumerated one at a time.  If there
     are several devices attached to a bus when it is first initialized (when
     the host driver is first installed into memory), it may take a long time
     (many tens of seconds) for all the devices attached to the bus to get
     enumerated.

     After a device is attached to the bus and enumerated, it is possible to
     have it re-enumerated, either with a physical disconnect and re-
     insertion, or with a "soft reset".  After the re-enumeration process is
     complete, the device may not necessarily have the same address it did
     when it was enumerated the first time.  It is never safe to assume that
     a device's address will stay the same across a reset.









                 BIOS-LEVEL USB API 0.05            Page 25 of 168

     POWER DISTRIBUTION
     ออออออออออออออออออ

     Power distribution on a USB bus can be the source of all kinds of
     consternation.  The USB architecture makes an attempt to manage power on
     devices attached to the bus, but unfortunately does not do a very good
     job of it.  The problem is not necessarily with the USB architecture
     itself, but rather with the way it is implemented and enforced.

     There are four wires in a standard USB cable.  Two of the wires carry
     the actual USB bus signals, and the other two wires carry power from the
     upstream hub(s) to the downstream device(s).  All USB devices require
     power to do anything useful.  A bus-powered device draws its power from
     the upstream hub (via the two power wires).  A self-powered device has
     its own power source, and does not draw any power (or at least does not
     draw a significant amount of power) from the bus.  Usually, a self-
     powered device is plugged into an AC power outlet, but it could also use
     batteries, solar power, or some other type of power source.

     The source of power (self-powered or bus-powered) a device uses is
     identified in the configuration descriptor of the device, as is the
     amount of bus power it draws (if it is bus-powered).  If a device is
     self-powered, there should never be a power-related problem when you
     hook it up to a bus and try to get it to work.  A bus-powered device, on
     the other hand, can cause problems.

     A bus-powered device obtains its power from the upstream hub that it is
     attached to.  Hubs are like any other USB device, in that they are
     either bus-powered or self-powered.  A bus-powered hub draws its power
     from its upstream hub, and then also "redistributes" the extra power
     that it does not itself use to its downstream devices.  A self-powered
     hub can provide up to 500 mA (milliamps) of power to each downstream
     port.  Therefore, if the total amount of current required by the
     downstream devices attached to any particular port exceeds 500mA, the
     port will be overloaded.  An overloaded port can cause large segments of
     a bus to fail.

     A host driver needs to monitor and track the power distribution on the
     bus, and (at least theoretically) is not supposed to configure a device
     that would cause a bus power overload.  While that is a noble ideal, it
     is not actually practical.  The problem is that some devices report
     false information (lies) about their power requirements.  For instance,
     I personally own two hubs that claim (in their configuration descriptor)
     to be self-powered when they are not.  If a host driver were to base its
     power distribution scheme on such false information, it could cause
     catastrophic bus failures.  Since at least some USB devices misrepresent
     their true power requirements, a host driver may simply choose to ignore
     power issues and leave it up to the user to monitor and resolve power-
     related issues.




                 BIOS-LEVEL USB API 0.05            Page 26 of 168

     There are some other issues to be aware of related to power distribution
     through hubs.  Hubs (the mechanism that distributes power to bus-powered
     devices) are not all created equal.  Specifically, there are two areas
     regarding power distribution where hubs are allowed to differ.  Those
     two areas are power-switching (being able to turn on or off the power to
     a specific downstream port), and overcurrent-protection (being able to
     sense and react to power overloads on downstream ports).

     There are three different options a hub can have regarding power-
     switching: per-port-power-switching, global-power-switching, and no-
     power-switching.  If a hub has per-port-power-switching, the hub allows
     each individual port to have the power turned on or off without
     affecting any of the other ports on the hub.  If a hub has global-power-
     switching, all of the downstream ports are "ganged" together as far as
     power switching is concerned.  That is, there is either power to all of
     the ports or there is power to none of the ports - it is not possible to
     control power to an individual port without affecting all of the other
     ports at the same time.  If a hub has no-power-switching, then there is
     always power to all of the ports, and it is not possible to turn the
     power off at all.  The only type of hub that is allowed to have no-
     power-switching is a root hub -- a "regular" (remote) hub must either
     have per-port-power-switching or global-power-switching.

     There are certain INT 14h requests that allow a user to control the
     power to individual ports on the bus.  Specifically, they are the "Power
     On Device Given Device Address", "Power Off Device Given Device
     Address", and "Power Reset Device Given Device Address" requests,
     described below on pages 90, 92, and 94, respectively.  A host driver
     will reject a request to control the power of a port on a hub that does
     not have per-port-power-switching.

     There are also three different options a hub can have regarding
     overcurrent-protection: per-port-overcurrent-protection, global-
     overcurrent-protection, and no-overcurrent-protection.  If a hub has
     per-port-overcurrent-protection, the hub will not allow more than 500mA
     of current to flow out of any individual port.  If a hub has global-
     overcurrent-protection, it will not allow the total current flow out of
     all of the ports combined to exceed a specified value.  For example, a
     self-powered four-Port hub that has global-overcurrent-protection would
     not allow more than 2000mA to flow out all of the ports combined.  In
     theory, it would be possible for all 2000mA to go out one individual
     port, and no current at all to flow out of any of the other three ports. 
     A hub that has no-overcurrent-protection, as the name implies, has no
     protection whatsoever.  It is possible for a hub with no-overcurrent-
     protection to literally melt down if there are problems either with the
     hub itself or with downstream devices, which could cause all kinds of
     misery.






                 BIOS-LEVEL USB API 0.05            Page 27 of 168

     Both the type of power-switching a hub has and the type of overcurrent-
     protection it has are detailed in the hub descriptor.  IMHO (In My
     Humble Opinion), the USB architecture should have never allowed for
     anything except per-port-power-switching and per-port-overcurrent-
     protection, but it does not do that.  You may need to be careful about
     the types of hubs that you purchase if you want your USB devices to work
     correctly and safely.

     As stated earlier, while the USB architecture makes an attempt to manage
     the power distribution on a bus, it does not do a very good job of it. 
     There are still many things that are left up to the user to monitor and
     troubleshoot, which cannot be handled automatically by the USB hardware
     or software.








































                 BIOS-LEVEL USB API 0.05            Page 28 of 168

     ROOT HUBS AND DEVICE ADDRESS 1
     ออออออออออออออออออออออออออออออ

     There is a special entity on a USB bus that is called the root hub.  It
     is in some ways similar to a "real" (remote) hub, but in most ways is
     completely different.  The root hub is not a USB device that you can
     simply pick up and look at.  Physically, it is integrated and
     inseparable from the USB host hardware.  A root hub is a logical device,
     and provides the same functions that a "real" hub provides (it allows
     the physical and logical extension of the USB bus to "real" devices). 
     The way a root hub physically provides those functions, though, is
     COMPLETELY different than the way a "real" hub does it.  It gets even
     more convoluted than that, because different types of host hardware (for
     example, UHCI vs. OHCI) provide the root hub functionality in completely
     different ways.  Under this API, the host driver is responsible for
     providing the root hub API functionality, since exactly how a root hub
     works is hardware-dependent.

     A root hub is not a physical device, and therefore does not respond to
     USB requests in the same way that "real" devices do.  However, there are
     times when it is either desired or required to refer to the root hub as
     if it were a real device.  Therefore, under this API, the root hub is
     always assigned a device address.  Specifically, the root hub always has
     address 1, while "real" devices are assigned addresses between 2 and
     127.  The host driver sets up the root hub to "look like" a real device
     with address 1, a single end point (endpoint 0), and a maximum packet
     size of 64 bytes.

     Even though the root hub is at the "head" of the bus, it is not actually
     a device attached to the bus, and therefore does not respond to packets
     sent out across the bus.  If a packet directed at device address 1 is
     actually sent out across the bus, the packet will always fail.  Believe
     it or not, this actually provides an incredibly useful tool when used
     appropriately.

     Most of the time, a host driver will reject any INT 14h requests that
     are directed at non-existent device addresses or end points.  However, a
     host driver will allow periodic interrupt packets with address 1 and end
     point 0 to be sent across the bus, even though it knows the packets will
     fail.  This provides the ability to use the USB bus for timing and
     testing purposes.  You can issue a "Schedule Periodic Interrupt
     Transaction" request (described on page 137 below) to address 1, end
     point 0, and it will work.  Of course, every time the periodic interrupt
     occurs, the status code (returned in the AX register) will contain an
     error, which can simply be ignored.








                 BIOS-LEVEL USB API 0.05            Page 29 of 168

     Under this API, whenever a device is disconnected from the bus, the host
     driver automatically terminates any packet transactions that are
     scheduled to go to the device.  The host driver does this by returning a
     status of TDStsDvcRemoved, and then unscheduling and deleting the
     appropriate transfer descriptors.  A root hub is not a real device, and
     can never be disconnected from the bus.  Therefore, the host driver will
     never automatically unschedule or delete any of the "fake" packet
     transactions scheduled to go to address 1.  Any program that schedules
     packet transactions to address 1 must unschedule those transactions
     manually when appropriate.  This is done with the "Close Transaction
     Handle" request (page 147).










































                 BIOS-LEVEL USB API 0.05            Page 30 of 168

     MEMORY ADDRESSES
     ออออออออออออออออ

     This API is written under the assumption that the operating system the
     API will be used with is DOS, and that the USB host hardware will be
     attached to the computer through a PCI bus.  In today's environment,
     that will most certainly be the case.  All other major operating systems
     (like the Unix/Linux variants and Microsoft Windows) have been updated
     to include native USB support, and there is no USB host hardware being
     sold today that attaches to any type of bus other than PCI.  That may no
     longer be the case 10 years from now, but it is certainly true today.

     There are two different types of memory addresses that are used by this
     API: code addresses and data addresses.  Many times, another program
     (like a device/interface driver) must provide a code address (in the
     form of a call back address) to a USB host driver.  The host driver will
     call this code address at various times (exactly how and why a call back
     address will be called is discussed in various sections throughout this
     document).  When provided, a code address (call back address) must be a
     standard segment:offset address in the first megabyte of memory (the
     only format and location allowed to be called by DOS programs).

     When another program provides the host driver a data address, however,
     there are two different possibilities.  The data address can be provided
     in a standard segment:offset format, or it can be provided as a 32-bit
     physical memory address.  Data is transferred between physical memory
     and the USB host hardware through the PCI bus using a process called bus
     mastering.  Bus mastering allows the PCI bus to access all of the
     physical memory on the computer directly, completely bypassing the CPU. 
     This allows the USB hardware to directly access parts of memory (like
     extended memory) that is normally very difficult (or sometimes even
     impossible) to access directly from DOS.

     In order to use bus mastering, what must be provided to the USB (PCI)
     hardware is ALWAYS a physical memory address -- it can never be a
     segment:offset address.  If a host driver receives a segment:offset
     address as part of a data transfer request (which it almost always will
     in a DOS environment), it must convert the segment:offset address to a
     physical address as required by the host hardware.  There are certain
     situations where this is possible, and others where it is not.













                 BIOS-LEVEL USB API 0.05            Page 31 of 168

     A host driver can easily perform the conversion if the data address is
     in conventional memory (in the first 640 kB).  The conversion can also
     be performed if the data address is in an Upper Memory Block (UMB,
     between 640 kB and 1 MB), as long as the CPU is running in protected
     mode under a VCPI-compliant memory manager (like EMM386).  The
     conversion cannot be made under any other protected mode environment
     (such as Windows DPMI).  In addition, UMB's as provided by a program
     like UMBPCI cannot be used (even though the CPU is in real mode),
     because the memory used by UMBPCI to create UMB's is not physical memory
     that can be accessed though PCI bus mastering.  In an environment where
     direct memory address conversion cannot be performed (such as DPMI or
     UMB's provided by UMBPCI), it is sometimes possible to design a double-
     buffering process, though that functionality is not provided by any
     existing program.







































                 BIOS-LEVEL USB API 0.05            Page 32 of 168

     INT 14h API EXTENSIONS
     ออออออออออออออออออออออ

     This API is implemented as an extension to the BIOS serial services
     interrupt (INT 14h).  There are currently only two functions provided at
     the INT 14h level: an install check (AX = 5000h) and a transaction
     request (AX = 5001h).  Additional functions will be required in the
     future, particularly as the API is expanded to include support for USB
     2.0 (EHCI), 2.5 (WHCI), and 3.0 (XHCI) functionality.  The INT 14h
     request is issued with appropriate values (as detailed directly below)
     in the AX, BX, CX, DX, and/or DS registers.  The request returns with
     the carry flag indicating success or error (CF = clear if success), AX
     containing an error code (the error codes are listed below on page 35),
     and request-specific data in the BX, CX, and/or DX registers.  In
     addition, the ES register may be used to return request-specific data in
     future versions of the API, though it is not currently used.


       Install Check
       ฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Entry:
           AX = 5000h
           BX = 5553h ("US")
           CX = 4221h ("B!")

         Return (Success):
           CF = Clear
           AX = 0
           BX = 4221h ("B!")
           CX = 5553h ("US")

         Return (Error):
           Since the API is not installed, it cannot control how the BIOS
           will respond to an INT 14h.  However, the BIOS will usually return
           with registers and flags unchanged.  Pre-setting the carry flag
           before the request can help ease the identification process.

         Notes: If there is at least one host driver installed in memory,
                this call will return successfully.  No matter how many host
                drivers are actually installed, the first host driver to
                receive the INT 14h request will respond in the affirmative.











                 BIOS-LEVEL USB API 0.05            Page 33 of 168

       Transaction Request
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Entry:
           AX = 5001h
           BX = 5553h ("US")
           CX = 4221h ("B!")
           DS:[DX] = Pointer to 64-byte request structure (see below)

         Return (Success):
           CF = Clear
           AX = 0
           BX, CX, DX = Depends on request type

         Return (Error):
           CF = Set
           AX = Error code (see error code table on page 35)
           BX = CX = DX = FFFFh

         Notes: This particular request actually hosts a multitude of
                different types of sub-requests.  Details about a specific
                request are contained in the 64-byte request data structure
                pointed at by the DS:[DX] register combination.  The 64-byte
                request structure is detailed in the next section, "THE 64-
                BYTE REQUEST STRUCTURE" (page 37).




























                 BIOS-LEVEL USB API 0.05            Page 34 of 168

                                    ERROR CODES
                  (Returned immediately by all INT 14h Requests)
                                    Part 1 of 2

        ษอออออออออออออออออออออัอออออัออออออออออออออออออออออออออออออออออออป
        บ     Mnemonic        ณValueณ             Description            บ
        ฬอออออออออออออออออออออุอออออุออออออออออออออออออออออออออออออออออออน
        บI14RErrSuccess       ณ0000hณNo Error at all (Success!)          บ
        วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤลฤฤฤฤฤลฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
        บI14RErrResources     ณ0001hณInsufficient Resources/Memory       บ
        บI14RErrHostHardware  ณ0002hณUnknown Hardware Problem with Host  บ
        บI14RErrReqTypeNoSupt ณ0003hณRequest Type Not Supported          บ
        วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤลฤฤฤฤฤลฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
        บI14RErrRequestType   ณ0011hณInvalid Request Type                บ
        บI14RErrFlags         ณ0012hณInvalid Flags                       บ
        บI14RErrHostIndex     ณ0013hณInvalid Host Index                  บ
        บI14RErrDeviceAddress ณ0014hณInvalid Device Address              บ
        บI14RErrHubAddress    ณ0014hณInvalid Hub Address                 บ
        บI14RErrEndPoint      ณ0015hณInvalid End Point                   บ
        บI14RErrHubPort       ณ0015hณInvalid Hub Port                    บ
        บI14RErrAltIntf       ณ0015hณInvalid Alternate Interface         บ
        บI14RErrConfigValue   ณ0016hณInvalid Configuration Value         บ
        บI14RErrCloseID       ณ0016hณInvalid Closure ID                  บ
        บI14RErrInterfaceNum  ณ0017hณInvalid Interface Number            บ
        บI14RErrSearchIndex   ณ0018hณInvalid Search Index                บ
        บI14RErrVendorProdID  ณ0019hณInvalid Vendor/Product ID           บ
        บI14RErrDvcIntf       ณ001AhณInvalid Device/Interface Value      บ
        บI14RErrRequestHandle ณ001BhณInvalid Request Handle              บ
        บI14RErrPeriodicity   ณ001ChณInvalid Periodicity                 บ
        บI14RErrBeepFrequency ณ001ChณInvalid Beep Frequency              บ
        บI14RErrTimeOut       ณ001DhณInvalid Timeout                     บ
        บI14RErrDataAddress   ณ001EhณInvalid Data Address                บ
        บI14RErrDataSize      ณ001FhณInvalid Data Size                   บ
        บI14RErrCallBackAddr  ณ0021hณInvalid Call Back Address           บ
        บI14RErrLCRtnCode     ณ0021hณInvalid Large Call Return Code      บ
        บI14RErrUserPktID     ณ0022hณInvalid User Packet ID              บ
        บI14RErrSetupReqData  ณ0023hณInvalid Setup Request Data          บ
        บI14RErrFrameTiming   ณ0024hณInvalid Frame Timing                บ
        บI14RErrFrameIndex    ณ0024hณInvalid Frame Index                 บ
        บI14RErrIsochArray    ณ0025hณInvalid Entry in Isoch Array Data   บ
        ศอออออออออออออออออออออฯอออออฯออออออออออออออออออออออออออออออออออออผ












                 BIOS-LEVEL USB API 0.05            Page 35 of 168

                                    ERROR CODES
                  (Returned immediately by all INT 14h Requests)
                                    Part 2 of 2

        ษอออออออออออออออออออออัอออออัออออออออออออออออออออออออออออออออออออป
        บ     Mnemonic        ณValueณ             Description            บ
        ฬอออออออออออออออออออออุอออออุออออออออออออออออออออออออออออออออออออน
        บI14RErrHostHalted    ณ0031hณHost is Halted/Suspended            บ
        บI14RErrIntfNotFound  ณ0032hณInterface Not Found                 บ
        บI14RErrIntfInConfig  ณ0033hณInterface Already Being Configured  บ
        บI14RErrIntfAlreadyRegณ0034hณInterface Already Registered        บ
        บI14RErrHostCallInUse ณ0035hณHost Run/Stop/etc. Already Running  บ
        บI14RErrNoPortPower   ณ0036hณPer-Port-Power not Supported by Hub บ
        บI14RErrAlreadyBeepingณ0037hณBeep Request Already Running        บ
        วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤลฤฤฤฤฤลฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
        บI14RErrDebugMode     ณ0041hณTried Single-Step with no Debug Modeบ
        วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤลฤฤฤฤฤลฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
        บI14RErrTimingOwned   ณ0051hณProblem with Frame Timing Ownership บ
        บI14RErrTimingLimit   ณ0052hณFrame Timing Already at a Limit     บ
        บI14RErrTmgChgInProg  ณ0053hณTiming Change Already in Progress   บ
        ศอออออออออออออออออออออฯอออออฯออออออออออออออออออออออออออออออออออออผ
































                 BIOS-LEVEL USB API 0.05            Page 36 of 168

     THE 64-BYTE REQUEST STRUCTURE
     อออออออออออออออออออออออออออออ

     As part of a INT 14h USB transaction request (AX = 5001h, discussed in
     the previous section), there is provided a pointer to a 64-byte request
     structure.  The 64-byte structure contains details on the exact request
     type, as well as any "extra" data that may be required to complete the
     transaction.

     The basic detail of a 64-byte Int 14h request structure is given below,
     in the format of an A86 assembly language structure.  The first byte of
     the structure is the request type (I14RRequestType), which is the
     "cornerstone" of the rest of the structure.  That is, exactly which
     other fields in the structure may or may not need to be filled in, and
     exactly what the those fields mean, depends on what is in the
     I14RRequestType field.

     The request types are divided into different classes.  For example,
     there is a host class (00h), timing class (10h), hub class (20h), etc. 
     The class identifiers (which all end with a 0h) are not legal request
     types -- they are simply used to help organize things.  For example, if
     you actually tried to send a request with an I14RRequestType of 10h
     ("Frame Timing Class"), you would receive an error.

     When you request a transaction with the host driver, the driver will
     immediately return with the carry flag and an error code in AX
     indicating success or error (CF = clear and AX = 0 is success, CF = set
     and AX > 0 is an error).  The exact error codes are detailed in the
     error code table above on page 35.  Depending on the specific request
     type, it may also return values in BX, CX, and/or DX.  In some cases,
     that will entirely complete the transaction.  In other cases, it will
     cause transaction(s) to be scheduled on the USB bus (see the "IMMEDIATE,
     SCHEDULE, AND LARGE TRANSACTIONS" section above on page 11).

     Immediately after the transaction request returns, the 64-byte request
     structure can be reused to issue another transaction request (if so
     desired).  While processing the transaction request, the host driver
     "copies" all of the relevant data it needs (addresses, codes, etc.) from
     the request structure and "stores" it until the entire transaction is
     completed (which may be a long time after the transaction request has
     returned).  Note, however, that the transaction request only "stores"
     the relevant data that is contained in the request structure itself --
     it will NOT store/copy/buffer any data outside the request structure
     (for example, data stored in memory with the memory address pointer
     stored in the request structure).








                 BIOS-LEVEL USB API 0.05            Page 37 of 168

     Each individual request type is explained in great detail in the section
     below, "TRANSACTION REQUEST TYPES" (page 42).  If a particular field of
     the structure is not listed in the description for that particular
     request type, the field will be ignored.  That is, the field can contain
     anything and it will not affect the status or result of the request. 
     However, the 14 "reserved" bytes at the end of the structure must be set
     to zero.














































                 BIOS-LEVEL USB API 0.05            Page 38 of 168

       Int14RequestSize EQU 64 ;Size of Request Structure

       Int14RequestStruc         STRUC      ;Structure for an Int 14h Request
         I14RRequestType            DB   ?  ;Type of Request
           I14RRTHostClass         EQU  00h ;Host/System/OS Class
             I14RRTGetHostSWInfo   EQU  01h ;Get Host Software Info
             I14RRTGetHostHWInfo   EQU  02h ;Get Host Hardware Info
             I14RRTGetHostVendInfo EQU  03h ;Get Host Vendor Info
             I14RRTGetHostStatus   EQU  04h ;Get Current Host Status
             I14RRTHostRun         EQU  08h ;Start/Run/Resume the Host
             I14RRTHostStop        EQU  09h ;Stop the Host
             I14RRTHostReset       EQU  0Ah ;Reset the Host
             I14RRTHostSuspend     EQU  0Bh ;Global Suspend the Host
             I14RRTHostResume      EQU  0Ch ;Force Global Resume on Host
           I14RRTTimingClass       EQU  10h ;Frame Timing Class
             I14RRTRegTmgOwner     EQU  11h ;Register as Timing Owner
             I14RRTUnRegTmgOwner   EQU  12h ;UnRegister as Timing Owner
             I14RRTIncTiming       EQU  13h ;Increment (Slow Down) Frame Tmg
             I14RRTDecTiming       EQU  14h ;Decrement (Speed Up) Frame Tmg
             I14RRTChangeTiming    EQU  15h ;Change Frame Timing (Large Amt)
           I14RRTHubClass          EQU  20h ;Hub Class
             I14RRTGetDvcHubInfo   EQU  21h ;Get Hub Info for Device
             I14RRTNewDvcConn      EQU  24h ;Device has been connected
             I14RRTDvcDisc         EQU  25h ;Device has been disconnected
             I14RRTSendHubChar     EQU  27h ;Send Hub Characteristics to Host
             I14RRTEnableHubPort   EQU  28h ;Enable Device given Hub & Port
             I14RRTDisableHubPort  EQU  29h ;Disable Device given Hub & Port
             I14RRTResetHubPort    EQU  2Ah ;Reset Device given Hub & Port
             I14RRTSuspendHubPort  EQU  2Bh ;Suspend Device given Hub & Port
             I14RRTResumeHubPort   EQU  2Ch ;Resume Device given Hub & Port
             I14RRTPwrOnHubPort    EQU  2Dh ;Power On Device given Hub & Port
             I14RRTPwrOffHubPort   EQU  2Eh ;Power Off Dvc given Hub & Port
             I14RRTPwrResetHubPort EQU  2Fh ;Power Reset Dvc given Hub & Port
           I14RRTTPowerClass       EQU  30h ;Power Class
             I14RRTGetDvcPowerInfo EQU  31h ;Get Power Info for Device
             I14RRTGetHubPowerDraw EQU  32h ;Get Power Draw Info for Hub
             I14RRTPwrOnDevice     EQU  3Dh ;Power On Device given Dvc Addr
             I14RRTPwrOffDevice    EQU  3Eh ;Power Off Device given Dvc Addr
             I14RRTPwrResetDevice  EQU  3Fh ;Power Reset Dvc given Dvc Addr
           I14RRTDeviceClass       EQU  40h ;Device Class
             I14RRTGetDvcClassInfo EQU  41h ;Get Device Class Info
             I14RRTGetDvcVendInfo  EQU  42h ;Get Device Vendor Info
             I14RRTGetDvcStatus    EQU  43h ;Get Device Status
             I14RRTEnableDevice    EQU  48h ;Enable/Resume Dvc given Dvc Addr
             I14RRTDisableDevice   EQU  49h ;Disble Device given Dvc Addr
             I14RRTResetDevice     EQU  4Ah ;Reset Device given Dvc Addr
             I14RRTSuspendDevice   EQU  4Bh ;Suspend Device given Dvc Addr
             I14RRTResumeDevice    EQU  4Ch ;Resume Device given Dvc Addr





                 BIOS-LEVEL USB API 0.05            Page 39 of 168

           I14RRTConfigClass       EQU  50h ;Configuration Class
             I14RRTConfigingIntf   EQU  51h ;Interface is Being Configured
             I14RRTConfigIntfDone  EQU  52h ;Interface Configuration is Done
             I14RRTSetNewConfig    EQU  58h ;Set/Change Device Config Value
           I14RRTInterfaceClass    EQU  60h ;Interface Class
             I14RRTFindRegIntf     EQU  62h ;Look for Registered Interface
             I14RRTFindUnRegIntf   EQU  63h ;Look for Unregistered Interface
             I14RRTRegIntfOwner    EQU  64h ;Register as Interface Owner
             I14RRTUnRegIntfOwner  EQU  65h ;Unregister as Interface Owner
             I14RRTIntfDontLook    EQU  68h ;Existing Intf Owner Don't Look
           I14RRTAltIntfClass      EQU  70h ;Alternate Interface Class
             I14RRTGetAltIntfInfo  EQU  71h ;Get Alternate Interface Info
           I14RRTEndPointClass     EQU  80h ;End Point Class
             I14RRTGetDataX        EQU  81h ;Get Current DataX Value
             I14RRTIncDataX        EQU  88h ;Increment/Toggle DataX Value
           I14RRTPacketClass       EQU  90h ;Packet Class
             I14RRTDoIsoch         EQU  94h ;Schedule Isochronous Transaction
             I14RRTDoInterruptPer  EQU  95h ;Schedule Periodic Interrupt
             I14RRTDoControl       EQU  96h ;Schedule Control/Setup Request
             I14RRTDoBulk          EQU  97h ;Schedule Bulk Transaction
             I14RRTDoInterrupt1T   EQU  98h ;Schedule One-Time Interrupt
             I14RRTCloseHandle     EQU  9Ch ;Close Scheduled Transaction
             I14RRTChangeIntPer    EQU  9Dh ;Change Periodicity of Interrupt
             I14RRTGetTransStatus  EQU  9Fh ;Get Status of Packet Transaction
           I14RRTMiscClass         EQU 0A0h ;Miscellaneous Class
             I14RRTLargeCallDone   EQU 0A1h ;Large Request Completed
             I14RRTBeepSpeaker     EQU 0AFh ;Beep the Speaker
           I14RRTInterHostClass    EQU 0E0h ;Inter-Host Communication Class
             I14RRTHostAdded       EQU 0E1h ;New Host Driver installed
             I14RRTHostDeleted     EQU 0E2h ;Host Driver removed
             I14RRTRegDvc0Host     EQU 0E3h ;Device0 Registration
             I14RRTUnRegDvc0Host   EQU 0E4h ;Device0 UnRegistration
             I14RRTCopyNDTable     EQU 0E5h ;Copy New Device Ownership Table
           I14RRTInternalClass     EQU 0F0h ;Host Internal/Troubleshooting
             I14RRTHostDebug       EQU 0FDh ;Put Host Into Debug Mode
             I14RRTHostSingleStep  EQU 0FEh ;SingleStep the Host (Debug Mode)
         I14RFlags                  DB   ?  ;Bit-level flags
           I14RFlagIn              EQU  01h ;In Direction
           I14RFlagLowSpeed        EQU  02h ;Low-Speed Device
           I14RFlagHiSpeed         EQU  04h ;High-Speed Device
           I14RFlagNoRetries       EQU  10h ;No Auto-Retries for Control Pkts
           I14RFlagShortPktOK      EQU  20h ;No Auto-Retry for Short Pkt Err
           I14RFlagSpecificFrame   EQU  40h ;Use Specific Frame Number
           I14RFlagAddrIsPhys      EQU  80h ;Data Address is Physical
         I14RHostIndex              DB   ?  ;Host Host Index
         I14RDeviceAddress          DB   ?  ;USB Device Address
           I14RHubAddress          EQU (OFFSET I14RDeviceAddress)
         I14REndPoint               DB   ?  ;EndPoint or Port or Alt Intf
           I14RHubPort             EQU (OFFSET I14REndPoint)
           I14RAltInterface        EQU (OFFSET I14REndPoint)



                 BIOS-LEVEL USB API 0.05            Page 40 of 168


         I14RConfigValue            DB   ?  ;Configuration Value
           I14RCloseID             EQU (OFFSET I14RConfigValue)
           I14RDataX               EQU (OFFSET I14RConfigValue)
         I14RInterfaceNum           DB   ?  ;Interface Number
         I14RSearchIndex            DB   ?  ;Search Index
         I14RVendorID               DW   ?  ;Vendor ID
         I14RProductID              DW   ?  ;Product ID
         I14RDvcClass               DB   ?  ;Device Class
         I14RDvcSubClass            DB   ?  ;Device SubClass
         I14RDvcProtocol            DB   ?  ;Device Protocol
         I14RIntfClass              DB   ?  ;Interface Class
         I14RIntfSubClass           DB   ?  ;Interface SubClass
         I14RIntfProtocol           DB   ?  ;Interface Protocol
         I14RRequestHandle          DW   ?  ;Request Handle Number
         I14RPeriodicity            DW   ?  ;Interrupt Periodicity/Duration
           I14RBeepFrequency       EQU (OFFSET I14RPeriodicity)
         I14RTimeout                DW   ?  ;Transaction Time Out Value
         I14RDataAddress            DD   ?  ;Data Address
         I14RDataSize               DW   ?  ;Size of Data (Bytes)
         I14RCallBackAddr           DD   ?  ;Call Back Address (CS:IP format)
           I14RLargeCallRtnCode    EQU (OFFSET I14RCallBackAddr)
         I14RUserPktID              DW   ?  ;User Packet ID
         I14RSetupReqData           DQ   ?  ;Setup Request Data (8 bytes)
         I14RFrameTiming            DW   ?  ;Frame Timing Value (def = 12000)
           I14RFrameIndex          EQU (OFFSET I14RFrameTiming)
                                            ;Starting Frame of Isoch Schedule
         I14RIsochSchedAddr         DD   ?  ;Address of Isoch Schedule
         I14RFiller DB (Int14RequestSize-$) DUP (0) ;Reserved/Future Use
        ENDS























                 BIOS-LEVEL USB API 0.05            Page 41 of 168

     TRANSACTION REQUEST TYPES
     อออออออออออออออออออออออออ

     As discussed in the "INT 14h API EXTENSIONS" section above (page 33), a
     specific API transaction is initiated by issuing an INT 14h with AX =
     5001h, BX = 5553h ("US"), CX = 4221h ("B!"), and DS:[DX] pointing at a
     64-byte data structure.  The exact format of the 64-byte data structure
     is discussed in the previous section, "THE 64-BYTE REQUEST STRUCTURE"
     (page 37).

     There are several data fields that are detailed in the data structure,
     but only two of them are required for every transaction: I14RRequestType
     (a byte at offset 0) and I14RHostIndex (a byte at offset 2).  Other
     fields in the structure may also be required, depending on the exact
     request type (determined by the combination of the contents in
     I14RRequestType and I14RHostIndex).  Below are listed the details of
     each request type, including which fields in the data structure are
     required for each different request type, and exactly what those fields
     mean.  If a particular field is not listed as pertinent to a particular
     request type, it is ignored.  That is, it can contain anything at all
     when the transaction request is issued, and it will not affect the
     results.

     When the INT 14h request returns, it will have the carry flag indicating
     success or failure (carry flag clear = success), an error code in AX (AX
     = 0 if success), and transaction-specific data in BX, CX, DX, and (in
     future versions of the API) ES.  Exact details on what is returned in
     BX, CX, and DX are given below in the description for each request type. 
     The error codes returned in AX are detailed above on page 35.

     In the details for each request there is also indicated a return type,
     which can be immediate, schedule, or large.  Immediate transactions are
     completed as soon as the INT 14h request returns, while schedule and
     large transactions schedule background process to occur which will be
     completed at some other (usually much later) point in time.  Exact
     details on the differences between the three different return types are
     discussed in the "IMMEDIATE, SCHEDULE, AND LARGE TRANSACTIONS" section
     above (page 11).















                 BIOS-LEVEL USB API 0.05            Page 42 of 168

       Get Host Software Information
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Host
         Return Type: Immediate

         Entry:
           I14RRequestType = 01h (I14RRTGetHostSWInfo)
           I14RHostIndex   = Host Index (0-15, 255 = All Hosts)

         Return (Success, I14RHostIndex = 255 (All Hosts)):
           CF = Clear
           AX = 0
           BX = Host Driver API Version (BCD)
                BH = Major Version
                BL = Minor Version
                e.g., version 0.05 = 0005h
           CX = FFFFh
           DX = FFFFh

         Return (Success, 0 <= I14RHostIndex <= 15):
           CF = Clear
           AX = 0
           BL = USB Version (BCD)
                High Nibble = Major Version
                Low Nibble  = Minor Version
                e.g., version 1.0 = 10h
           BH = Int 2Fh (TSR Multiplex) Handle Number (C0h-FFh)
                If Host Driver does not use Int 2Fh, CH = 0
           CX = FFFFh
           DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: If this request is issued with I14RHostIndex = 255 (all
                hosts), the first host driver to receive the request will
                process the request.  It will not "pass on" the request to
                other host driver(s).

                All Host Drivers installed in memory at the same time must
                support the same version of the Driver API.









                 BIOS-LEVEL USB API 0.05            Page 43 of 168

       Get Host Hardware Information
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Host
         Return Type: Immediate

         Entry:
           I14RRequestType = 02h (I14RRTGetHostHWInfo)
           I14RHostIndex   = Host Index (0-15, 255 = Any Host)

         Return (Success, I14RHostIndex = 255 (Any Host)):
           CF = Clear
           AX = 0
           BX = Installed Hosts Bitmap
                 Bit 0 = Set if Host Index 0 is Installed, etc.
           CX = FFFFh
           DX = FFFFh

         Return (Success, 0 <= I14RHostIndex <= 15):
           CF = Clear
           AX = 0
           BL = Host Type and Bus Type (not a Bitmap)
                Low Nibble = Host Type:
                  01h = UHCI
                  02h = OHCI
                  03h = EHCI
                  04h = WHCI
                  05h = XHCI
                High Nibble = Bus Type:
                  10h = PCI
           BH = FFh
           CL = IRQ Line Number (3-15)
           CH = Number of Root Hub Ports
           DX = PCI Bus-Device-Function Word
                Bits 0-2  = Function (0-7)
                Bits 3-7  = Device (0-31)
                Bits 8-15 = Bus (0-255)
                If Host is not PCI-attached, DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: A UHCI host always reports as having exactly 2 ports, even
                though both ports may not physically be present.

                The format of the PCI bus-device-function word is in the same
                format that it is received from the PCI BIOS.




                 BIOS-LEVEL USB API 0.05            Page 44 of 168

                If this request is issued with I14RHostIndex = 255 (any
                host), the first host driver to receive the request will
                process the request.  It will not "pass on" the request to
                other host driver(s).

















































                 BIOS-LEVEL USB API 0.05            Page 45 of 168

       Get Host Vendor Information
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Host
         Return Type: Immediate

         Entry:
           I14RRequestType   = 03h (I14RRTGetHostVendInfo)
           I14RHostIndex     = Host Index (0-15)

         Return (Success):
           CF = Clear
           AX = 0
           BX = Host Controller Vendor ID
           CX = Host Controller Product ID
           DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: This returns the PCI vendor ID and product ID as stored in
                the PCI configuration space for the host controller.  This is
                the same information returned by a "Get Device Vendor
                Information" request (page 97) issued for device address 1
                (the root hub).


























                 BIOS-LEVEL USB API 0.05            Page 46 of 168

       Get Host Status
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Host
         Return Type: Immediate

         Entry:
           I14RRequestType = 04h (I14RRTGetHostStatus)
           I14RHostIndex   = Host Index (0-15)

         Return (Success):
           CF = Clear
           AX = 0
           BL = Host Status
                  1 = Running normally
                  2 = Stopped/Halted
                  3 = Global Suspend Mode
                  4 = Debug (Single-Step) Mode
                255 = Unknown/Undefined
           BH = Percentage of Bus Bandwidth currently in use
           CX = Current Frame Index (0-1023)
           DX = Frame Timing (Full-Speed Bit-Times/Frame, default = 12000)

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: According to the USB specification, 90% of the bus bandwidth
                is "reserved" for isochronous and interrupt transactions, and
                the remaining 10% is "left over" for control and bulk
                transactions.  The value returned in BH is how much of the
                90% isochronous/periodic interrupt bandwidth is actually
                being used (NOT how much of the entire bus is being used). 
                This is a fairly good approximation of how "full" the bus
                currently is.

















                 BIOS-LEVEL USB API 0.05            Page 47 of 168

       Host Run
       ฤฤฤฤฤฤฤฤ

         Class:       Host
         Return Type: Large

         Entry:
           I14RRequestType  = 08h (I14RRTHostRun)
           I14RHostIndex    = Host Index (0-15, 255 = All Hosts)
           I14RCallBackAddr = Large Return Address (CS:IP)
           I14RUserPktID    = Value to return in BX on Large Return

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Large Return (Success):
           ZF = Set
           AX = 0
           BX = I14RUserPktID of Requester
           CX = DX = FFFFh

         Large Return (Error):
           ZF = Clear
           AX = 8000h (TDStsLargeCallErr)
           BX = I14RUserPktID of Requester
           CX = DX = FFFFh

         Owner Notifications (Success):
           AX = 0018h (OwnerCallHostRun)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = DX = 0

             Notifies interface owners of all devices attached to the
             host(s), all device 0 owners, and the frame timing owner.

         Notes: This request will do whatever it takes to attempt to run the
                host(s) "normally" again, no matter what state(s) the host(s)
                are currently in.  I.e., this request will "recover" a host
                that is simply halted, one that is in debug mode, or one that
                is currently in global suspend mode.





                 BIOS-LEVEL USB API 0.05            Page 48 of 168

                If this request is issued with I14RHostIndex = 255 (all
                hosts), the first host driver to receive the request will
                "pass on" the request to all host drivers individually.


















































                 BIOS-LEVEL USB API 0.05            Page 49 of 168

       Host Stop
       ฤฤฤฤฤฤฤฤฤ

         Class:       Host
         Return Type: Large

         Entry:
           I14RRequestType  = 09h (I14RRTHostStop)
           I14RHostIndex    = Host Index (0-15, 255 = All Hosts)
           I14RCallBackAddr = Large Return Address (CS:IP)
           I14RUserPktID    = Value to return in BX on Large Return

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Large Return (Success):
           ZF = Set
           AX = 0
           BX = I14RUserPktID of Requester
           CX = DX = FFFFh

         Large Return (Error):
           ZF = Clear
           AX = 8000h (TDStsLargeCallErr)
           BX = I14RUserPktID of Requester
           CX = DX = FFFFh

         Owner Notifications (Success):
           AX = 0019h (OwnerCallHostStop)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = DX = 0

             Notifies interface owners of all devices attached to the
             host(s), all device 0 owners, and the frame timing owner.

         Notes: This request simply stops the host from generating timing on
                the bus.  It does not unschedule or reschedule any bus
                transactions.  After the bus is started again, any pending
                transactions will be processed as originally scheduled.

                If this request is issued with I14RHostIndex = 255 (all
                hosts), the first host driver to receive the request will
                "pass on" the request to all host drivers individually.


                 BIOS-LEVEL USB API 0.05            Page 50 of 168

       Host Reset
       ฤฤฤฤฤฤฤฤฤฤ

         Class:       Host
         Return Type: Large

         Entry:
           I14RRequestType  = 0Ah (I14RRTHostReset)
           I14RHostIndex    = Host Index (0-15, 255 = All Hosts)
           I14RCallBackAddr = Large Return Address (CS:IP)
           I14RUserPktID    = Value to return in BX on Large Return

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Large Return (Success):
           ZF = Set
           AX = 0
           BX = I14RUserPktID of Requester
           CX = DX = FFFFh

         Large Return (Error):
           ZF = Clear
           AX = 8000h (TDStsLargeCallErr)
           BX = I14RUserPktID of Requester
           CX = DX = FFFFh

         Owner Notifications (Success):
           AX = 001Ah (OwnerCallHostReset)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = DX = 0

             Notifies interface owners of all devices attached to the
             host(s), all device 0 owners, and the frame timing owner.

             In addition to the "Host Reset" owner call, ALL devices attached
             to the host, either directly or through a remote hub, will be
             disconnected.  This will result in device disconnect
             notifications to all interface owners of devices attached to the
             host.  Because owner(s) will be notified of each individual
             device being disconnected, there is typically no need for an
             interface owner to do anything directly in response to a host
             reset notification.


                 BIOS-LEVEL USB API 0.05            Page 51 of 168

         Notes: This request performs a complete (global) reset of the
                host(s).  All "real" devices attached to the host, either
                directly or indirectly, will effectively be disconnected. 
                All scheduled bus transactions to those devices are
                automatically deleted (unscheduled).  Owners MUST NOT issue
                "Close Handle" requests to unschedule the requests.

                The process that occurs after the host reset is complete is
                essentially the same as the process that occurs when the host
                driver is first installed into memory and begins to control
                the host hardware.  All devices that remain attached to the
                bus during and after the host reset process will be
                automatically re-enumerated as appropriate.  However, the
                device address(es) assigned after the re-enumeration process
                is complete may not be the same as they were before the
                initiation of the host reset process.

                Device address 1 (the root hub) is not disconnected during a
                host reset.  Therefore, any "fake" (timing-only) transactions
                to device address 1 will remain in the schedule, and will
                continue to be processed after the reset process is complete
                (the host reset process typically takes several hundred
                milliseconds to complete).

                Frame timing and frame sequence numbers are preserved across
                a "Host Reset" request.  Therefore, the frame timing owner
                should not need to worry about timing resynchronization, and
                the timing-only transactions should resume just as they did
                before the host reset was issued.

                The large return does not necessarily occur at the end of the
                reset process, but rather may occur sometime during the
                middle of the process.  The host reset process may continue
                for several hundred milliseconds after the large return is
                issued.

                If this request is issued with I14RHostIndex = 255 (all
                hosts), the first host driver to receive the request will
                "pass on" the request to all host drivers individually.














                 BIOS-LEVEL USB API 0.05            Page 52 of 168

       Host Suspend (Global Suspend)
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Host
         Return Type: Large

         Entry:
           I14RRequestType  = 0Bh (I14RRTHostSuspend)
           I14RHostIndex    = Host Index (0-15, 255 = All Hosts)
           I14RCallBackAddr = Large Return Address (CS:IP)
           I14RUserPktID    = Value to return in BX on Large Return

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Large Return (Success):
           ZF = Set
           AX = 0
           BX = I14RUserPktID of Requester
           CX= DX = FFFFh

         Large Return (Error):
           ZF = Clear
           AX = 8000h (TDStsLargeCallErr)
           BX = I14RUserPktID of Requester
           CX = DX = FFFFh

         Owner Notifications (Success):
           AX = 001Bh (OwnerCallHostSuspend)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = DX = 0

             Notifies interface owners of all devices attached to the
             host(s), all device 0 owners, and the frame timing owner.

         Notes: This request has the host(s) issue a global suspend signal to
                the bus.  To "recover" from a host suspend, the "Host Run"
                request (page 48) should be issued, rather than the "Host
                Resume" request (page 55).  A "Host Resume" issues a global
                resume signal down the bus, but does NOT cause the host to
                begin running "normally" again.  The "Host Run" request will
                do both.



                 BIOS-LEVEL USB API 0.05            Page 53 of 168

                If this request is issued with I14RHostIndex = 255 (all
                hosts), the first host driver to receive the request will
                "pass on" the request to all host drivers individually.


















































                 BIOS-LEVEL USB API 0.05            Page 54 of 168

       Host Resume (Global Resume)
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Host
         Return Type: Large

         Entry:
           I14RRequestType  = 0Ch (I14RRTHostResume)
           I14RHostIndex    = Host Index (0-15, 255 = All Hosts)
           I14RCallBackAddr = Large Return Address (CS:IP)
           I14RUserPktID    = Value to return in BX on Large Return

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Large Return (Success):
           ZF = Set
           AX = 0
           BX = I14RUserPktID of Requester
           CX = DX = FFFFh

         Large Return (Error):
           ZF = Clear
           AX = 8000h (TDStsLargeCallErr)
           BX = I14RUserPktID of Requester
           CX = DX = FFFFh

         Owner Notifications (Success):
           AX = 001Ch (OwnerCallHostResume)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = DX = 0

             Notifies interface owners of all devices attached to the
             host(s), all device 0 owners, and the frame timing owner.

         Notes: This request has the host(s) issue a global suspend to the
                bus, which will only partially "recover" the bus from a "Host
                Suspend" request (page 53).  To have the bus begin running
                "normally" again, the "Host Run" request (page 48) should be
                issued instead of this "Host Resume" request.





                 BIOS-LEVEL USB API 0.05            Page 55 of 168

                The large return does not necessarily occur at the end of the
                resume process, but rather may occur sometime during the
                middle of the process.  The resume process may continue for
                several hundred milliseconds after the large return is
                issued.

                If this request is issued with I14RHostIndex = 255 (all
                hosts), the first host driver to receive the request will
                "pass on" the request to all host drivers individually.












































                 BIOS-LEVEL USB API 0.05            Page 56 of 168

       Register As Frame Timing Owner
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Timing
         Return Type: Immediate

         Entry:
           I14RRequestType  = 11h (I14RRTRegTmgOwner)
           I14RHostIndex    = Host Index (0-15)
           I14RCallBackAddr = Notification Call Back Address (CS:IP)
                                (Frame Timing Owner)
           I14RUserPktID    = Value to return in BX on Notifications

         Return (Success):
           CF = Clear
           AX = 0
           CX = Frame Timing Owner Handle
           BX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Owner Notifications:
           AX = (see NOTIFICATION CODES Table on page 10)
           BX = I14RUserPktID of Frame Timing Owner
           CX = Depends on Notification Code
           DX = Depends on Notification Code

             The frame timing owner is notified when "changes" occur
             somewhere on the bus that would be of interest to the frame
             timing owner.  For example, an frame timing owner is notified if
             the host is stopped (halted) or reset.  Notifications detailed
             in the NOTIFICATION CODES table (page 10) that are related to
             the host, as opposed to a device, would be the ones issued to a
             frame timing owner.

         Notes: The frame timing cannot be changed unless this request has
                been issued first, and only the registered frame timing owner
                is allowed to make changes to the frame timing.  In addition,
                there can be only one registered owner of the frame timing.

                The frame timing owner handle (the value returned in CX) will
                be a randomly-generated number, and must be "returned" (in
                I14RRequestHandle) in all consequent requests related to
                frame timing.  The handle number is how the host driver
                verifies that a request is being generated by the legitimate
                frame timing owner.




                 BIOS-LEVEL USB API 0.05            Page 57 of 168

                The requester will remain the frame timing owner until the
                host driver receives an "Unregister as Frame Timing Owner"
                request (page 59), or until the host driver is removed from
                memory.

















































                 BIOS-LEVEL USB API 0.05            Page 58 of 168

       Unregister as Frame Timing Owner
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Timing
         Return Type: Immediate

         Entry:
           I14RRequestType   = 12h (I14RRTUnRegTmgOwner)
           I14RHostIndex     = Host Index (0-15)
           I14RRequestHandle = Frame Timing Owner Handle

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: The frame timing owner handle is the value that was returned
                in the CX register during the "Register as Frame Timing
                Owner" request (page 57).





























                 BIOS-LEVEL USB API 0.05            Page 59 of 168

       Increment Frame Timing Factor (Slow Down Bus)
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Timing
         Return Type: Schedule

         Entry:
           I14RRequestType   = 13h (I14RRTIncTiming)
           I14RHostIndex     = Host Index (0-15)
           I14RRequestHandle = Frame Timing Owner Handle
           I14RCallBackAddr  = Schedule Return Address (CS:IP)
           I14RUserPktID     = Value to return in BX on Schedule Return

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Schedule Return (Success):
           ZF = Set
           AX = 0
           BX = I14RUserPktID of Requester
           CX = New Frame Timing Factor
           DX = FFFFh

         Schedule Return (Error):
           ZF = Clear
           AX = Status Code (see Status Code Table on page 14)
           BX = I14RUserPktID of Requester
           CX = DX = FFFFh

         Owner Notifications (Success):
           AX = 0021h (OwnerCallTimingChg)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = FFh
           DX = New Frame Timing Factor
                UHCI Hosts: 11936-12063

             Notifies interface owners of all devices attached to the
             host(s), all device 0 owners, and the frame timing owner.







                 BIOS-LEVEL USB API 0.05            Page 60 of 168

         Notes: The frame timing owner handle is the value that was returned
                in the CX register during the "Register as Frame Timing
                Owner" request (page 57).

                If the bus is actively running, the host driver will
                automatically wait 6 milliseconds before actually changing
                the frame timing factor.  This is done to ensure compliance
                with the USB specification regarding how quickly a frame
                timing factor can be changed.












































                 BIOS-LEVEL USB API 0.05            Page 61 of 168

       Decrement Frame Timing Factor (Speed Up Bus)
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Timing
         Return Type: Schedule

         Entry:
           I14RRequestType   = 14h (I14RRTDecTiming)
           I14RHostIndex     = Host Index (0-15)
           I14RRequestHandle = Frame Timing Owner Handle
           I14RCallBackAddr  = Schedule Return Address (CS:IP)
           I14RUserPktID     = Value to return in BX on Schedule Return

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Schedule Return (Success):
           ZF = Set
           AX = 0
           BX = I14RUserPktID of Requester
           CX = New Frame Timing Factor
           DX = FFFFh

         Schedule Return (Error):
           ZF = Clear
           AX = Status Code (see Status Code Table on page 14)
           BX = I14RUserPktID of Requester
           CX = DX = FFFFh

         Owner Notifications (Success):
           AX = 0021h (OwnerCallTimingChg)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = FFh
           DX = New Frame Timing Factor
                UHCI Hosts: 11936-12063

             Notifies interface owners of all devices attached to the
             host(s), all device 0 owners, and the frame timing owner.







                 BIOS-LEVEL USB API 0.05            Page 62 of 168

         Notes: The frame timing owner handle is the value that was returned
                in the CX register during the "Register as Frame Timing
                Owner" request (page 57).

                If the bus is actively running, the host driver will
                automatically wait 6 milliseconds before actually changing
                the frame timing factor.  This is done to ensure compliance
                with the USB specification regarding how quickly a frame
                timing factor can be changed.












































                 BIOS-LEVEL USB API 0.05            Page 63 of 168

       Change Frame Timing Factor (By a Large Amount)
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Timing
         Return Type: Schedule

         Entry:
           I14RRequestType   = 15h (I14RRTChangeTiming)
           I14RHostIndex     = Host Index (0-15)
           I14RRequestHandle = Frame Timing Owner Handle
           I14RCallBackAddr  = Schedule Return Address (CS:IP)
           I14RUserPktID     = Value to return in BX on Schedule Return
           I14RFrameTiming   = New Frame Timing Factor
                               UHCI Hosts: 11936-12063

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Schedule Return (Success):
           ZF = Set
           AX = 0
           BX = I14RUserPktID of Requester
           CX = New Frame Timing Factor
           DX = FFFFh

         Schedule Return (Error):
           ZF = Clear
           AX = Status Code (see Status Code Table on page 14)
           BX = I14RUserPktID of Requester
           CX = DX = FFFFh

         Owner Notifications (Success):
           AX = 0021h (OwnerCallTimingChg)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = FFh
           DX = New Frame Timing Factor
                UHCI Hosts: 11936-12063

             Notifies interface owners of all devices attached to the
             host(s), all device 0 owners, and the frame timing owner.





                 BIOS-LEVEL USB API 0.05            Page 64 of 168

         Notes: The frame timing owner handle is the value that was returned
                in the CX register during the "Register as Frame Timing
                Owner" request (page 57).

                If the bus is actively running, the host driver will
                automatically wait 6 milliseconds between each
                increment/decrement of the frame timing factor. 
                Consequently, a significant change in the frame timing factor
                may take several hundred milliseconds to complete.  This is
                done to ensure compliance with the USB specification
                regarding how quickly a frame timing factor can be changed.










































                 BIOS-LEVEL USB API 0.05            Page 65 of 168

       Get Device Hub Information
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Hub
         Return Type: Immediate

         Entry:
           I14RRequestType   = 21h (I14RRTGetDvcHubInfo)
           I14RHostIndex     = Host Index (0-15)
           I14RDeviceAddress = Address of Device to get Info for

         Return (Success):
           CF = Clear
           AX = 0
           BL = Device Address of Hub that Device is attached to
           BH = Hub Port Number that Device is attached to
           CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: If the device of concern is the root hub (I14RDeviceAddress =
                1), this request will return BL = 255 and BH = 255.  This is
                because the root hub is not actually attached to another hub,
                but is directly "attached" to the host.

                Hub port numbers are 1-based (a hub never has a port number
                of 0).  The port number returned will be the software port
                number.  There is at least one hub manufacturer that labels
                the port numbers on the hub backwards from the software port
                numbers (that is software port 1 is physically labeled as
                port 4, SW 2 is labeled 3, SW 3 is labeled 2, and SW 4 is
                labeled 1).

                Under normal circumstances, a device/interface driver would
                never issue this request, since it has no need to know any
                information about the hub it is attached to.














                 BIOS-LEVEL USB API 0.05            Page 66 of 168

       Notify Host Driver of New Device Connection
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Hub
         Return Type: Large

         Entry:
           I14RRequestType  = 24h (I14RRTNewDvcConn)
           I14RHostIndex    = Host Index (0-15)
           I14RHubAddress   = Device Address of Hub connection
           I14RHubPort      = Port Number of Hub connection
           I14RCallBackAddr = Large Return Address (CS:IP)
           I14RUserPktID    = Value to return in BX on Large Return
           I14RFlags:
             I14RFlagLowSpeed (02h) = Set if Device is Low-Speed
                                    = Clear if Device is Full-Speed

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Large Return (Success):
           ZF = Set
           BX = I14RUserPktID of Requester
           AX = CX = DX = 0

         Large Return (Error):
           ZF = Clear
           AX = 8000h (TDStsLargeCallErr)
           BX = I14RUserPktID of Requester
           CX = DX = 0

         Owner Notifications (Success):
           AX = 0001h (OwnerCallNewDvc)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of newly attached Device (2-127)
           DL = Interface Number
           DH = Alternate Interface Number

             Notifies device 0 owner(s) whose search criteria match alternate
             interface(s) of the new device under the current configuration. 
             If the device is unconfigured (configuration value 0) after the
             enumeration process is complete, no notifications are issued.



                 BIOS-LEVEL USB API 0.05            Page 67 of 168

           AX = 0077h (HubCallEnumerated)
           BX = I14RUserPktID of Hub Owner
           CL = Hub Address
           CH = Hub Port
           DL = Host Index
           DH = Address of New Device (2-127, 255 = Bad Device)

             Notifies the interface owner of the hub that the new device is
             attached to.

         Notes: This is an internal request that goes between a hub driver
                and a host driver.  This request must NOT be issued by any
                software other than a hub driver or a host driver.

                When a hub detects a new device attachment, the hub driver
                must immediately disable the newly attached device, and then
                must wait AT LEAST 100 milliseconds for power to stabilize
                before issuing this request to the host driver.  The host
                driver will enumerate the device (reset the device, enable
                it, assign it an address, configure it, enable the remote
                wakeup feature (if appropriate), and gather some basic
                information about the device by downloading the device and
                configuration descriptors).  After the enumeration process is
                complete, the host driver will issue the large return call to
                the hub driver that initiated the request.  If the device
                fails to respond properly during ANY part of the enumeration
                process, it will be considered a "bad" device, and is
                automatically disabled by the host driver.

                The host driver will typically have a "reset/enumeration
                queue" which allows multiple reset/enumeration requests to be
                handled at the same time.

                This hub notification process for an enumerated device occurs
                after ALL enumerations, whether they were initiated with this
                particular request, a "Reset Device Given Device Address"
                request (page 104), or a "Reset Device and Change
                Configuration" request (page 114).

                A single device 0 owner may be notified multiple times for
                the same device attachment, depending on the search criteria
                of the device 0 owner, and exactly how many matching
                alternate interfaces the device actually has under the
                current configuration.









                 BIOS-LEVEL USB API 0.05            Page 68 of 168

       Notify Host Driver of Device Disconnection
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Hub
         Return Type: Immediate

         Entry:
           I14RRequestType = 25h (I14RRTDvcDisc)
           I14RHostIndex   = Host Index (0-15)
           I14RHubAddress  = Device Address of Hub disconnection (1-127)
           I14RHubPort     = Port Number of Hub disconnection

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Owner Notifications:
           AX = 0002h (OwnerCallDvcDisc)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of disconnected Device (2-127)
           DX = 0

             Notifies interface owner(s) of all interfaces on the device.  If
             the disconnected device is a hub, all device(s) downstream of
             the hub are also disconnected.  Consequently, all interface
             owners(s) of all downstream device(s) will also receive a
             notification.

           AX = 0082h (OwnerCallDvcDiscUS)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of disconnected Device (2-127)
           DX = 0

             Notifies interface owner(s) of all device(s) downstream of the
             disconnected device.  This only applies if the disconnected
             device is a hub.  Consequently, interface owner(s) of all
             device(s) downstream of a disconnected hub will receive both an
             OwnerCallDvcDiscUS notification (AX=0082h) and an
             OwnerCallDvcDisc notification (AX=0002h).






                 BIOS-LEVEL USB API 0.05            Page 69 of 168

           AX = 0003h (OwnerCallDvc0Disc)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of disconnected Device (2-127)
           DX = 0

             Notifies device 0 owner(s) whose search criteria match alternate
             interface(s) of the disconnected device under the current
             configuration.  If the disconnected device is a hub, all
             device(s) downstream of the hub are also disconnected. 
             Consequently, all device 0 owners(s) whose search criteria match
             alternate interface(s) of device(s) downstream of the
             disconnected hub will also receive a notification.

         Notes: This is an internal request that goes between a hub driver
                and a host driver.  This request must NOT be issued by any
                software other than a hub driver or a host driver.

                The host driver AUTOMATICALLY removes all bus transactions
                that are scheduled to the disconnected device(s), regardless
                of end point.  Therefore, the interface owners and device 0
                owners MUST NOT issue separate requests to remove the
                scheduled transactions.

                The root hub (device address 1) is never disconnected, so
                scheduled transactions to that address will never be removed
                automatically, unless the host driver is removed from memory. 
                When a host driver is removed from memory, a "Host
                Disconnect" notification is issued to all affected owners.

                A single device 0 owner or interface owner may be notified
                multiple times for the same device detachment, depending on
                several factors.  Those factors include the search criteria
                of the device 0 owner, exactly how many matching interfaces
                and alternate interfaces the device actually has under the
                current configuration, and exactly how many "layers" of hubs
                there are between the "owned" device and the device (hub)
                that is actually disconnected.















                 BIOS-LEVEL USB API 0.05            Page 70 of 168

       Send Hub Characteristics to Host Driver
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Hub
         Return Type: Immediate

         Entry:
           I14RRequestType = 27h (I14RRTSendHubChar)
           I14RHostIndex   = Host Index (0-15)
           I14RHubAddress  = Device Address of Hub
           I14RHubPort     = Number of Ports on Hub (1-255)
           I14RConfigValue = Hub Flags Bitmap
                             Bit 0 (01h) = Set if Hub supports
                               Per-Port-Power-Switching
                             Bits 1-7 = Reserved (0)

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: This is an internal request that goes between a hub driver
                and a host driver.  This request must NOT be issued by any
                software other than a hub driver.

                This request must be issued by a hub driver immediately after
                it has issued the "Register As Interface Owner" request (page
                121) to the host driver.

                If per-port-power-switching is not supported by a particular
                hub, the host driver will reject all "Power On Device Given
                Device Address", "Power Off Device Given Device Address", and
                "Power Reset Device Given Device Address" requests (pages 90,
                92, and 94, respectively) to devices attached to that hub.














                 BIOS-LEVEL USB API 0.05            Page 71 of 168

       Enable Device Given Hub Address and Port
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Hub
         Return Type: Large

         Entry:
           I14RRequestType  = 28h (I14RRTEnableHubPort)
           I14RHostIndex    = Host Index (0-15)
           I14RHubAddress   = Device Address of Hub that Port is On
           I14RHubPort      = Port Number on Hub to Enable
           I14RCallBackAddr = Large Return Address (CS:IP)
           I14RUserPktID    = Value to return in BX on Large Return

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Large Return (Success):
           ZF = Set
           BX = I14RUserPktID of Requester
           AX = 0
           CX = DX = FFFFh

         Large Return (Error):
           ZF = Clear
           AX = 8000h (TDStsLargeCallErr)
           BX = I14RUserPktID of Requester
           CX = DX = FFFFh

         Owner Notifications:
           AX = 0078h (HubCallEnable)
           BX = I14RUserPktID of Hub Owner
           CL = Hub Address
           CH = Hub Port Number
           DL = Large Call Index
           DH = Host Index (0-15)

             Notifies hub owner of the port to be enabled.  The hub driver
             MUST inform the host driver when it is completed by issuing a
             "Large Call Completed" request (page 154) back to the host.






                 BIOS-LEVEL USB API 0.05            Page 72 of 168

         Notes: This is an internal request that goes between a hub driver
                and a host driver.  This request must NOT be issued by any
                software other than a hub driver or a host driver.

                The host driver temporarily passes control of the large call
                over to the hub driver during the hub call.  The hub driver
                MUST inform the host driver when it is completed by issuing a
                "Large Call Completed" request (page 154) back to the host.

                This request is functionally similar to an "Enable Device
                Given Device Address" request (page 100), except that the
                affected owner(s) are NOT notified at the end of the process.









































                 BIOS-LEVEL USB API 0.05            Page 73 of 168

       Disable Device Given Hub Address and Port
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Hub
         Return Type: Large

         Entry:
           I14RRequestType  = 29h (I14RRTDisableHubPort)
           I14RHostIndex    = Host Index (0-15)
           I14RHubAddress   = Device Address of Hub that Port is On
           I14RHubPort      = Port Number on Hub to Disable
           I14RCallBackAddr = Large Return Address (CS:IP)
           I14RUserPktID    = Value to return in BX on Large Return

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Large Return (Success):
           ZF = Set
           BX = I14RUserPktID of Requester
           AX = CX = DX = 0

         Large Return (Error):
           ZF = Clear
           AX = 8000h (TDStsLargeCallErr)
           BX = I14RUserPktID of Requester
           CX = DX = 0

         Owner Notifications:
           AX = 0079h (HubCallDisable)
           BX = I14RUserPktID of Hub Owner
           CL = Hub Address
           CH = Hub Port Number
           DL = Large Call Index
           DH = Host Index (0-15)

             Notifies hub owner of the port to be disabled.  The hub driver
             MUST inform the host driver when it is completed by issuing a
             "Large Call Completed" request (page 154) back to the host.







                 BIOS-LEVEL USB API 0.05            Page 74 of 168

         Notes: This is an internal request that goes between a hub driver
                and a host driver.  This request must NOT be issued by any
                software other than a hub driver or a host driver.

                The host driver temporarily passes control of the large call
                over to the hub driver during the hub call.  The hub driver
                MUST inform the host driver when it is completed by issuing a
                "Large Call Completed" request (page 154) back to the host.

                This request is functionally similar to a "Disable Device
                Given Device Address" request (page 102), except that the
                affected owner(s) are NOT notified at the end of the process.









































                 BIOS-LEVEL USB API 0.05            Page 75 of 168

       Reset Device Given Hub Address and Port
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Hub
         Return Type: Large

         Entry:
           I14RRequestType  = 2Ah (I14RRTResetHubPort)
           I14RHostIndex    = Host Index (0-15)
           I14RHubAddress   = Device Address of Hub Device is Attached to
           I14RHubPort      = Port Number of Hub Device is Attached to
           I14RCallBackAddr = Large Return Address (CS:IP)
           I14RUserPktID    = Value to return in BX on Large Return

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Large Return (Success):
           ZF = Set
           BX = I14RUserPktID of Requester
           AX = CX = DX = 0

         Large Return (Error):
           ZF = Clear
           AX = 8000h (TDStsLargeCallErr)
           BX = I14RUserPktID of Requester
           CX = DX = 0

         Owner Notifications:
           AX = 007Ah (HubCallReset)
           BX = I14RUserPktID of Hub Owner
           CL = Hub Address
           CH = Hub Port Number
           DL = Large Call Index
           DH = Host Index (0-15)

             Notifies hub owner of the port to be reset.  The hub driver must
             inform the host driver when it is completed by issuing a "Large
             Call Completed" request (page 154) back to the host.







                 BIOS-LEVEL USB API 0.05            Page 76 of 168

         Notes: This is an internal request that goes between a hub driver
                and a host driver.  This request must NOT be issued by any
                software other than a hub driver or a host driver.

                The host driver temporarily passes control of the large call
                over to the hub driver during the hub call.  The hub driver
                MUST inform the host driver when it is completed by issuing a
                "Large Call Completed" request (page 154) back to the host.

                The large return does not necessarily occur at the end of the
                reset process, but rather may occur sometime during the
                middle of the process.  The reset process may continue for
                several hundred milliseconds after the large return is
                issued.

                This request is NOT the same thing as a "Reset Device Given
                Device Address" request (page 104).  This request simply
                informs the hub driver to have the hub send a reset signal on
                the port of interest.  This request simply performs one "sub-
                process" in an entire reset/enumeration process (which is
                what the "Reset Device Given Device Address" request
                performs).































                 BIOS-LEVEL USB API 0.05            Page 77 of 168

       Suspend Device Given Hub Address and Port (Selective Suspend)
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Hub
         Return Type: Large

         Entry:
           I14RRequestType  = 2Bh (I14RRTSuspendHubPort)
           I14RHostIndex    = Host Index (0-15)
           I14RHubAddress   = Device Address of Hub that Port is On
           I14RHubPort      = Port Number on Hub to Suspend
           I14RCallBackAddr = Large Return Address (CS:IP)
           I14RUserPktID    = Value to return in BX on Large Return

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Large Return (Success):
           ZF = Set
           BX = I14RUserPktID of Requester
           AX = CX = DX = 0

         Large Return (Error):
           ZF = Clear
           AX = 8000h (TDStsLargeCallErr)
           BX = I14RUserPktID of Requester
           CX = DX = 0

         Owner Notifications:
           AX = 007Bh (HubCallSuspend)
           BX = I14RUserPktID of Hub Owner
           CL = Hub Address
           CH = Hub Port Number
           DL = Large Call Index
           DH = Host Index (0-15)

             Notifies hub owner of the port to be suspended.  The hub driver
             MUST inform the host driver when it is completed by issuing a
             "Large Call Completed" request (page 154) back to the host.







                 BIOS-LEVEL USB API 0.05            Page 78 of 168

         Notes: This is an internal request that goes between a hub driver
                and a host driver.  This request must NOT be issued by any
                software other than a hub driver or a host driver.

                The host driver temporarily passes control of the large call
                over to the hub driver during the hub call.  The hub driver
                MUST inform the host driver when it is completed by issuing a
                "Large Call Completed" request (page 154) back to the host.

                This request is functionally similar to a "Suspend Device
                Given Device Address" request (page 107), except that the
                affected owner(s) are NOT notified at the end of the process.









































                 BIOS-LEVEL USB API 0.05            Page 79 of 168

       Resume Device Given Hub Address and Port (Selective Resume)
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Hub
         Return Type: Large

         Entry:
           I14RRequestType  = 2Ch (I14RRTResumeHubPort)
           I14RHostIndex    = Host Index (0-15)
           I14RHubAddress   = Device Address of Hub that Port is On
           I14RHubPort      = Port Number on Hub to Resume
           I14RCallBackAddr = Large Return Address (CS:IP)
           I14RUserPktID    = Value to return in BX on Large Return

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Large Return (Success):
           ZF = Set
           BX = I14RUserPktID of Requester
           AX = CX = DX = 0

         Large Return (Error):
           ZF = Clear
           AX = 8000h (TDStsLargeCallErr)
           BX = I14RUserPktID of Requester
           CX = DX = 0

         Owner Notifications:
           AX = 007Ch (HubCallResume)
           BX = I14RUserPktID of Hub Owner
           CL = Hub Address
           CH = Hub Port Number
           DL = Large Call Index
           DH = Host Index (0-15)

             Notifies hub owner of the port to be resumed.  The hub driver
             MUST inform the host driver when it is completed by issuing a
             "Large Call Completed" request (page 154) back to the host.







                 BIOS-LEVEL USB API 0.05            Page 80 of 168

         Notes: This is an internal request that goes between a hub driver
                and a host driver.  This request must NOT be issued by any
                software other than a hub driver or a host driver.

                The host driver temporarily passes control of the large call
                over to the hub driver during the hub call.  The hub driver
                MUST inform the host driver when it is completed by issuing a
                "Large Call Completed" request (page 154) back to the host.

                The large return does not necessarily occur at the end of the
                resume process, but rather may occur sometime during the
                middle of the process.  The resume process may continue for
                several hundred milliseconds after the large return is
                issued.

                This request is functionally similar to a "Resume Device
                Given Device Address" request (page 107), except that the
                affected owner(s) are NOT notified at the end of the process.



































                 BIOS-LEVEL USB API 0.05            Page 81 of 168

       Power On Device Given Hub Address and Port
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Hub
         Return Type: Large

         Entry:
           I14RRequestType  = 2Dh (I14RRTPwrOnHubPort)
           I14RHostIndex    = Host Index (0-15)
           I14RHubAddress   = Device Address of Hub that Port is On
           I14RHubPort      = Port Number on Hub to Power On
           I14RCallBackAddr = Large Return Address (CS:IP)
           I14RUserPktID    = Value to return in BX on Large Return

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Large Return (Success):
           ZF = Set
           BX = I14RUserPktID of Requester
           AX = CX = DX = 0

         Large Return (Error):
           ZF = Clear
           AX = 8000h (TDStsLargeCallErr)
           BX = I14RUserPktID of Requester
           CX = DX = 0

         Owner Notifications:
           AX = 007Dh (HubCallPwrOn)
           BX = I14RUserPktID of Hub Owner
           CL = Hub Address
           CH = Hub Port Number
           DL = Large Call Index
           DH = Host Index (0-15)

             Notifies hub owner of the port to be powered on.  The hub driver
             MUST inform the host driver when it is completed by issuing a
             "Large Call Completed" request (page 154) back to the host.







                 BIOS-LEVEL USB API 0.05            Page 82 of 168

         Notes: This is an internal request that goes between a hub driver
                and a host driver.  This request must NOT be issued by any
                software other than a hub driver or a host driver.

                The host driver temporarily passes control of the large call
                over to the hub driver during the hub call.  The hub driver
                MUST inform the host driver when it is completed by issuing a
                "Large Call Completed" request (page 154) back to the host.

                This request is functionally similar to a "Power On Device
                Given Device Address" request (page 90), except that the
                affected owner(s) are NOT notified at the end of the process.

                A hub driver powers on all ports while a hub is being
                initialized.  Therefore, there is normally no need to issue
                this request unless a "Power Off Device" request (page 92)
                was previously issued.

                If the hub that the port being powered on is part of does not
                support per-port-power-switching, this request will be
                rejected by the host driver with an error code of
                I14RErrNoPortPower.































                 BIOS-LEVEL USB API 0.05            Page 83 of 168

       Power Off Device Given Hub Address and Port
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Hub
         Return Type: Large

         Entry:
           I14RRequestType  = 2Eh (I14RRTPwrOffHubPort)
           I14RHostIndex    = Host Index (0-15)
           I14RHubAddress   = Device Address of Hub that Port is On
           I14RHubPort      = Port Number on Hub to Power Off
           I14RCallBackAddr = Large Return Address (CS:IP)
           I14RUserPktID    = Value to return in BX on Large Return

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Large Return (Success):
           ZF = Set
           BX = I14RUserPktID of Requester
           AX = CX = DX = 0

         Large Return (Error):
           ZF = Clear
           AX = 8000h (TDStsLargeCallErr)
           BX = I14RUserPktID of Requester
           CX = DX = 0

         Owner Notifications:
           AX = 007Eh (HubCallPwrOff)
           BX = I14RUserPktID of Hub Owner
           CL = Hub Address
           CH = Hub Port Number
           DL = Large Call Index
           DH = Host Index (0-15)

             Notifies hub owner of the port to be powered off.  The hub
             driver MUST inform the host driver when it is completed by
             issuing a "Large Call Completed" request (page 154) back to the
             host.






                 BIOS-LEVEL USB API 0.05            Page 84 of 168

         Notes: This is an internal request that goes between a hub driver
                and a host driver.  This request must NOT be issued by any
                software other than a hub driver or a host driver.

                The host driver temporarily passes control of the large call
                over to the hub driver during the hub call.  The hub driver
                MUST inform the host driver when it is completed by issuing a
                "Large Call Completed" request (page 154) back to the host.

                This request is functionally similar to a "Power Off Device
                Given Device Address" request (page 92), except that the
                affected owner(s) are NOT notified at the end of the process.

                If the hub that the port being powered off is part of does
                not support per-port-power-switching, this request will be
                rejected by the host driver with an error code of
                I14RErrNoPortPower.

                If the device being powered off is bus-powered, this request
                has the same functional effect as physically unplugging the
                device from the bus.  If the device being powered off is
                self-powered, this request should not provide any functional
                effect.






























                 BIOS-LEVEL USB API 0.05            Page 85 of 168

       Power Reset Device Given Hub Address and Port
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Hub
         Return Type: Large

         Entry:
           I14RRequestType  = 2Fh (I14RRTPwrResetHubPort)
           I14RHostIndex    = Host Index (0-15)
           I14RHubAddress   = Device Address of Hub that Port is On
           I14RHubPort      = Port Number on Hub to Power Reset
           I14RCallBackAddr = Large Return Address (CS:IP)
           I14RUserPktID    = Value to return in BX on Large Return

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Large Return (Success):
           ZF = Set
           BX = I14RUserPktID of Requester
           AX = CX = DX = 0

         Large Return (Error):
           ZF = Clear
           AX = 8000h (TDStsLargeCallErr)
           BX = I14RUserPktID of Requester
           CX = DX = 0

         Owner Notifications:
           AX = 007Fh (HubCallPwrReset)
           BX = I14RUserPktID of Hub Owner
           CL = Hub Address
           CH = Hub Port Number
           DL = Large Call Index
           DH = Host Index (0-15)

             Notifies hub owner of the port to be power reset.  The hub
             driver MUST inform the host driver when it is completed by
             issuing a "Large Call Completed" request (page 154) back to the
             host.






                 BIOS-LEVEL USB API 0.05            Page 86 of 168

         Notes: This is an internal request that goes between a hub driver
                and a host driver.  This request must NOT be issued by any
                software other than a hub driver or a host driver.

                The host driver temporarily passes control of the large call
                over to the hub driver during the hub call.  The hub driver
                MUST inform the host driver when it is completed by issuing a
                "Large Call Completed" request (page 154) back to the host.

                This request is functionally similar to a "Power Reset Device
                Given Device Address" request (page 94), except that the
                affected owner(s) are NOT notified at the end of the process.

                If the hub that the port being power reset is part of does
                not support per-port-power-switching, this request will be
                rejected by the host driver with an error code of
                I14RErrNoPortPower.

                The hub driver has the hub hardware power off the port,
                leaves it un-Powered for approximately 250 milliseconds, and
                then has the hub hardware power on the port again.  If the
                device being power reset is bus-powered, this request has the
                same effect as physically unplugging the device from the bus,
                leaving it unplugged for approximately 250 milliseconds, and
                then re-inserting the device back into the hub port again. 
                If the device being power reset is self-powered, this request
                should not provide any functional effect.


























                 BIOS-LEVEL USB API 0.05            Page 87 of 168

       Get Device Power Information
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Power
         Return Type: Immediate

         Entry:
           I14RRequestType   = 31h (I14RRTGetDvcPowerInfo)
           I14RHostIndex     = Host Index (0-15)
           I14RDeviceAddress = Address of Device to get Info for

         Return (Success):
           CF = Clear
           AX = 0
           BX = Maximum Bus Power draw of Device (milliamps)
           CL = Power Flags Bitmap
                Bit 0 (01h) = Set if Device is Self-Powered
                Bit 6 (40h) = Set if Device is a Hub that supports
                                Per-Port-Power-Switching
                Bit 7 (80h) = Set if Device is a Hub
                Bits 1-5    = Reserved (0)
           CH = Number of Ports if Device is a Hub (1-255)
              = 0 if Device is not a Hub
           DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: The maximum bus power draw and the self-powered status of the
                device are obtained from the device's configuration
                descriptor during the reset/enumeration process.  If the
                device has more than one configuration, the information
                returned by this request pertains only to the current
                configuration.  If the device is currently unconfigured
                (configuration value = 0), the information returned by this
                request pertains only to the first configuration
                (configuration value = 1).

                There are several devices being sold where the power
                information contained in the device's configuration
                descriptor is incorrect (e.g., the descriptor claims that the
                device is self-powered when it is actually bus-powered). 
                Therefore, the information returned by this request should
                not necessarily be trusted for accuracy.







                 BIOS-LEVEL USB API 0.05            Page 88 of 168

       Get Hub Power Draw
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Power
         Return Type: Immediate

         Entry:
           I14RRequestType = 32h (I14RRTGetHubPowerDraw)
           I14RHostIndex   = Host Index (0-15)
           I14RHubAddress  = Address of Hub to get Info for
           I14RHubPort     = Hub Port number to get info for
                               (1-based Port Number, 0 = All Ports)

         Return (Success):
           CF = Clear
           AX = 0
           BX = Total Power drawn from Hub Ports (milliamps)
           CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: This indicates the total power drawn by ALL downstream
                devices that claim to be bus-powered in their descriptors. 
                This includes devices that are "indirectly" downstream of the
                hub in question, by being attached to a port on a bus-powered
                hub that is downstream of the hub.

                If I14RHubPort = 0, this provides the total power drawn on
                all ports on the hub combined (the total power drawn by all
                downstream devices).  If I14RHubPort >= 1, this provides the
                total power drawn on an individual port.

                There are several devices being sold where the power
                information contained in the device's configuration
                descriptor is incorrect (e.g., the descriptor claims that the
                device is self-powered when it is actually bus-powered). 
                Therefore, the information returned by this request should
                not necessarily be trusted for accuracy.












                 BIOS-LEVEL USB API 0.05            Page 89 of 168

       Power On Device Given Device Address
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Power
         Return Type: Large

         Entry:
           I14RRequestType   = 3Dh (I14RRTPwrOnDevice)
           I14RHostIndex     = Host Index (0-15)
           I14RDeviceAddress = Address of Device to Power On
           I14RCallBackAddr  = Large Return Address (CS:IP)
           I14RUserPktID     = Value to return in BX on Large Return

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Large Return (Success):
           ZF = Set
           BX = I14RUserPktID of Requester
           AX = CX = DX = 0

         Large Return (Error):
           ZF = Clear
           AX = 8000h (TDStsLargeCallErr)
           BX = I14RUserPktID of Requester
           CX = DX = 0

         Owner Notifications:
           AX = 007Dh (HubCallPwrOn)
           BX = I14RUserPktID of Hub Owner
           CL = Hub Address
           CH = Hub Port Number
           DL = Large Call Index
           DH = Host Index (0-15)

             Notifies hub owner of the port to be powered on (the port that
             the device to be powered on is attached to).  The hub driver
             MUST inform the host driver when it is completed by issuing a
             "Large Call Completed" request (page 154) back to the host.







                 BIOS-LEVEL USB API 0.05            Page 90 of 168

           AX = 000Dh (OwnerCallDvcPwrOn)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of Device that was Powered On (2-127)
           DX = 0

             Notifies interface owner(s) of all interfaces on the device that
             was powered on.  The notification will only occur if the
             transaction was successful.

           AX = 008Dh (OwnerCallDvcPwrOnUS)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of Device that was Powered On (2-127)
           DX = 0

             Notifies interface owner(s) of all device(s) downstream of the
             device that was powered on.  This only applies if the device
             powered on is a hub.  The notification will only occur if the
             transaction was successful.

         Notes: This request does not actually result in anything being sent
                directly to the device that is being powered on, but rather
                to the hub that the device is attached to.

                If the hub that the port being powered on is part of does not
                support per-port-power-switching, this request will be
                rejected by the host driver with an error code of
                I14RErrNoPortPower.

                This request is functionally similar to a "Power On Device
                Given Hub Address and Port" request (page 82), except that
                the affected owner(s) ARE notified at the end of the process.

                A hub driver powers on all ports while a hub is being
                Initialized.  Therefore, there is normally no need to issue
                this request unless a "Power Off Device" request was
                previously issued.















                 BIOS-LEVEL USB API 0.05            Page 91 of 168

       Power Off Device Given Device Address
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Power
         Return Type: Large

         Entry:
           I14RRequestType   = 3Eh (I14RRTPwrOffDevice)
           I14RHostIndex     = Host Index (0-15)
           I14RDeviceAddress = Address of Device to Power Off
           I14RCallBackAddr  = Large Return Address (CS:IP)
           I14RUserPktID     = Value to return in BX on Large Return

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Large Return (Success):
           ZF = Set
           BX = I14RUserPktID of Requester
           AX = CX = DX = 0

         Large Return (Error):
           ZF = Clear
           AX = 8000h (TDStsLargeCallErr)
           BX = I14RUserPktID of Requester
           CX = DX = 0

         Owner Notifications:
           AX = 007Eh (HubCallPwrOff)
           BX = I14RUserPktID of Hub Owner
           CL = Hub Address
           CH = Hub Port Number
           DL = Large Call Index
           DH = Host Index (0-15)

             Notifies hub owner of the port to be powered off (the port that
             the device to be powered off is attached to).  The hub driver
             MUST inform the host driver when it is completed by issuing a
             "Large Call Completed" request (page 154) back to the host.







                 BIOS-LEVEL USB API 0.05            Page 92 of 168

           AX = 000Eh (OwnerCallDvcPwrOff)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of Device that was Powered Off (2-127)
           DX = 0

             Notifies interface owner(s) of all interfaces on the device that
             was powered off.  The notification will only occur if the
             transaction was successful.

           AX = 008Eh (OwnerCallDvcPwrOffUS)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of Device that was Powered Off (2-127)
           DX = 0

             Notifies interface owner(s) of all device(s) downstream of the
             device that was powered off.  This only applies if the device
             powered off is a hub.  The notification will only occur if the
             transaction was successful.

         Notes: This request does not actually result in anything being sent
                directly to the device that is being powered off, but rather
                to the hub that the device is attached to.

                If the hub that the port being powered off is part of does
                not support per-port-power-switching, this request will be
                rejected by the host driver with an error code of
                I14RErrNoPortPower.

                This request is functionally similar to a "Power Off Device
                Given Hub Address and Port" request (page 84), except that
                the affected owner(s) ARE notified at the end of the process.

                If the device being powered off is bus-powered, this request
                has the same functional effect as physically unplugging the
                device from the bus.  If the device being powered off is
                self-powered, this request will not provide any functional
                effect.














                 BIOS-LEVEL USB API 0.05            Page 93 of 168

       Power Reset Device Given Device Address
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Power
         Return Type: Large

         Entry:
           I14RRequestType   = 3Fh (I14RRTPwrResetDevice)
           I14RHostIndex     = Host Index (0-15)
           I14RDeviceAddress = Address of Device to Power Reset
           I14RCallBackAddr  = Large Return Address (CS:IP)
           I14RUserPktID     = Value to return in BX on Large Return

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Large Return (Success):
           ZF = Set
           BX = I14RUserPktID of Requester
           AX = CX = DX = 0

         Large Return (Error):
           ZF = Clear
           AX = 8000h (TDStsLargeCallErr)
           BX = I14RUserPktID of Requester
           CX = DX = 0

         Owner Notifications:
           AX = 007Fh (HubCallPwrReset)
           BX = I14RUserPktID of Hub Owner
           CL = Hub Address
           CH = Hub Port Number
           DL = Large Call Index
           DH = Host Index (0-15)

             Notifies hub owner of the port to be power reset (the port that
             the device to be power reset is attached to).  The hub driver
             MUST inform the host driver when it is completed by issuing a
             "Large Call Completed" request (page 154) back to the host.







                 BIOS-LEVEL USB API 0.05            Page 94 of 168

           AX = 000Fh (OwnerCallDvcPwrReset)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of Device that was Power Reset (2-127)
           DX = 0

             Notifies interface owner(s) of all interfaces on the device that
             was power reset.  The notification will only occur if the
             transaction was successful.

           AX = 008Fh (OwnerCallDvcPwrResetUS)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of Device that was Power Reset (2-127)
           DX = 0

             Notifies interface owner(s) of all device(s) downstream of the
             device that was power reset.  This only applies if the device
             power reset is a hub.  The notification will only occur if the
             transaction was successful.

         Notes: This request does not actually result in anything being sent
                directly to the device that is being power reset, but rather
                to the hub that the device is attached to.

                If the hub that the port being power reset is part of does
                not support per-port-power-switching, this request will be
                rejected by the host driver with an error code of
                I14RErrNoPortPower.

                This request is functionally similar to a "Power Reset Device
                Given Hub Address and Port" request (page 86), except that
                the affected owner(s) ARE notified at the end of the process.

                The hub driver has the hub hardware power off the port,
                leaves it un-Powered for approximately 250 milliseconds, and
                then has the hub hardware power on the port again.  If the
                device being power reset is bus-powered, this request has the
                same effect as physically unplugging the device from the bus,
                leaving it unplugged for approximately 250 milliseconds, and
                then re-inserting the device back into the hub port again. 
                If the device being power reset is self-powered, this request
                will not provide any functional effect.










                 BIOS-LEVEL USB API 0.05            Page 95 of 168

       Get Device Class Information
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Device
         Return Type: Immediate

         Entry:
           I14RRequestType   = 41h (I14RRTGetDvcClassInfo)
           I14RHostIndex     = Host Index (0-15)
           I14RDeviceAddress = Address of Device to get Info for

         Return (Success):
           CF = Clear
           AX = 0
           BL = Device Class
           BH = Device SubClass
           CL = Device Protocol
           CH = USB Version (BCD: High Nibble = Major, Low Nibble = Minor)
           DL = Speed Flags Bitmap
                Bit 0 (01h) = Set if Device is Low-Speed
                Bits 1-7    = Reserved (0)
           DH = FFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: The class, subclass, protocol, and USB version are obtained
                from the device descriptor during the reset/enumeration
                process.

                The USB version is contained in the device descriptor as a
                word, which is "compressed" into a single byte before being
                returned by this request.  For example, version 01.10 (0110h
                in the device descriptor) is "compressed" (the high and low
                nibbles are discarded) and returned as 11h (version 1.1). 
                This format (a byte as opposed to a word) is consistent with
                the USB version as returned by the host hardware on the PCI
                bus.













                 BIOS-LEVEL USB API 0.05            Page 96 of 168

       Get Device Vendor Information
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Device
         Return Type: Immediate

         Entry:
           I14RRequestType   = 42h (I14RRTGetDvcVendInfo)
           I14RHostIndex     = Host Index (0-15)
           I14RDeviceAddress = Address of Device to get Info for

         Return (Success):
           CF = Clear
           AX = 0
           BX = Device Vendor ID
           CX = Device Product ID
           DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: The vendor ID and product ID are obtained from the device
                descriptor during the reset/enumeration process.

                For the root hub (address 1), the vendor ID and product ID
                are associated with the PCI host controller (a PCI device,
                not a USB device).  Therefore, the vendor ID and product ID
                will be PCI ID's, not USB ID's (it is not possible to
                "translate" a PCI ID into a USB ID).  This is the same data
                returned by a "Get Host Vendor Information" request (page
                46).




















                 BIOS-LEVEL USB API 0.05            Page 97 of 168

       Get Device Status Information
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Device
         Return Type: Immediate

         Entry:
           I14RRequestType   = 43h (I14RRTGetDvcStatus)
           I14RHostIndex     = Host Index (0-15)
           I14RDeviceAddress = Address of Device to get Info for

         Return (Success):
           CF = Clear
           AX = 0
           BL = Current Configuration Value for Device
           BH = Status Flags Bitmap
                Bit 0 (01h) = Set if Device is "Bad" (a problem occurred
                                during the Reset/Enumeration Process)
                Bit 1 (02h) = Set if Device supports Remote Wakeup Feature
                Bit 2 (04h) = Set if Remote Wakeup Feature is Enabled
                Bit 3 (08h) = Set if Test Mode is Enabled
                Bits 4-6    = Reserved (0)
                Bit 7 (80h) = Set if Device is currently in the middle of the
                                Reset/Enumeration process
           CL = Last Completed Stage of Reset/Enumeration Process
           CH = FFh
           DX = Error Code Associated with Last Completed Stage of
                  Reset/Enumeration Process

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: The host driver must monitor the appropriate control requests
                in "real time" so that it can process this request as an
                immediate return.  The host must NOT send a control packet
                across the bus requesting status(es) directly from the device
                before processing this request.

                The remote wakeup feature support status (bit 1 of the BH
                register) is obtained from the device's configuration
                descriptor during the reset/enumeration process.  If the
                device has more than one configuration, the information
                returned by this request pertains only to the current
                configuration.  If the device is currently unconfigured
                (configuration value = 0), the information returned by this
                request pertains only to the first configuration
                (configuration value = 1).




                 BIOS-LEVEL USB API 0.05            Page 98 of 168

                The remote wakeup feature enabled status (bit 2 of the BH
                register) is obtained by monitoring the device's response to
                the most recent "Set Feature: Remote Wakeup" or "Clear
                Feature: Remote Wakeup" control request.  It does not
                necessarily indicate the true enabled status of the remote
                wakeup feature.  A device which does not support the remote
                wakeup feature (as indicated in bit 1 of the BH register)
                should reject any request associated with the feature, but
                many devices do not.  The true status of the remote wakeup
                feature is indicated by the combination of bits 1 and 2.

                The test mode enabled status (bit 3 of the BH register) is
                obtained by monitoring the device's response to the most
                recent "Set Feature: Test Mode" or "Clear Feature: Test Mode"
                control request.  It may or may not indicate the true test
                mode enabled status, given that many devices respond
                affirmatively to feature control requests that they do not
                support and should reject.

                If bit 7 (80h) of the value returned in BH is set, the device
                is currently in the middle of the enumeration process.  Any
                data associated with the device returned by this, or any
                other, request may be incomplete or erroneous until the
                enumeration process has been completed in its entirety.

                If bit 0 (01h) of the value returned in BH is set (indicating
                that the device is "bad"), the values returned in CL and DX
                can be used as a troubleshooting tool to help determine where
                and how the device failed during the enumeration process. 
                The precise meaning of the values returned in CL & DX are
                specific to the host driver software used.  They are of
                little value other than highly technical troubleshooting. 
                Refer to the specific host driver software documentation for
                details.



















                 BIOS-LEVEL USB API 0.05            Page 99 of 168

       Enable Device Given Device Address
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Device
         Return Type: Large

         Entry:
           I14RRequestType   = 48h (I14RRTEnableDevice)
           I14RHostIndex     = Host Index (0-15)
           I14RDeviceAddress = Address of Device to Enable
           I14RCallBackAddr  = Large Return Address (CS:IP)
           I14RUserPktID     = Value to return in BX on Large Return

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Large Return (Success):
           ZF = Set
           BX = I14RUserPktID of Requester
           AX = CX = DX = 0

         Large Return (Error):
           ZF = Clear
           AX = 8000h (TDStsLargeCallErr)
           BX = I14RUserPktID of Requester
           CX = DX = 0

         Owner Notifications:
           AX = 0078h (HubCallEnable)
           BX = I14RUserPktID of Hub Owner
           CL = Hub Address
           CH = Hub Port Number
           DL = Large Call Index
           DH = Host Index (0-15)

             Notifies hub owner of the port to be enabled (the port that the
             device to be enabled is attached to).  The hub driver MUST
             inform the host driver when it is completed by issuing a "Large
             Call Completed" request (page 154) back to the host.







                BIOS-LEVEL USB API 0.05            Page 100 of 168

           AX = 0008h (OwnerCallDvcEnable)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of Device that was Enabled (2-127)
           DX = 0

             Notifies interface owner(s) of all interfaces on the device that
             was enabled.  The notification will only occur if the
             transaction was successful.

           AX = 0088h (OwnerCallDvcEnableUS)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of Device that was Enabled (2-127)
           DX = 0

             Notifies interface owner(s) of all device(s) downstream of the
             device that was enabled.  This only applies if the enabled
             device is a hub.  The notification will only occur if the
             transaction was successful.

         Notes: This request does not actually result in anything being sent
                directly to the device that is being enabled, but rather to
                the hub that the device is attached to.

                This request is functionally similar to an "Enable Device
                Given Hub Address and Port" request (page 72), except that
                the affected owner(s) ARE notified at the end of the process.

                If a device is disabled, enabling it will NOT cause it
                "recover" and start running normally again.  A device must be
                reset to "recover" from being disabled.





















                BIOS-LEVEL USB API 0.05            Page 101 of 168

       Disable Device Given Device Address
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Device
         Return Type: Large

         Entry:
           I14RRequestType   = 49h (I14RRTDisableDevice)
           I14RHostIndex     = Host Index (0-15)
           I14RDeviceAddress = Address of Device to Disable
           I14RCallBackAddr  = Large Return Address (CS:IP)
           I14RUserPktID     = Value to return in BX on Large Return

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Large Return (Success):
           ZF = Set
           BX = I14RUserPktID of Requester
           AX = CX = DX = 0

         Large Return (Error):
           ZF = Clear
           AX = 8000h (TDStsLargeCallErr)
           BX = I14RUserPktID of Requester
           CX = DX = 0

         Owner Notifications:
           AX = 0079h (HubCallDisable)
           BX = I14RUserPktID of Hub Owner
           CL = Hub Address
           CH = Hub Port Number
           DL = Large Call Index
           DH = Host Index (0-15)

             Notifies hub owner of the port to be disabled (the port that the
             device to be disabled is attached to).  The hub driver MUST
             inform the host driver when it is completed by issuing a "Large
             Call Completed" request (page 154) back to the host.







                BIOS-LEVEL USB API 0.05            Page 102 of 168

           AX = 0009h (OwnerCallDvcDisable)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of Device that was Disabled (2-127)
           DX = 0

             Notifies interface owner(s) of all interfaces on the device that
             was disabled.  The notification will only occur if the
             transaction was successful.

           AX = 0089h (OwnerCallDvcDisableUS)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of Device that was Disabled (2-127)
           DX = 0

             Notifies interface owner(s) of all device(s) downstream of the
             device that was disabled.  This only applies if the disabled
             device is a hub.  The notification will only occur if the
             transaction was successful.

         Notes: This request does not actually result in anything being sent
                directly to the device that is being disabled, but rather to
                the hub that the device is attached to.

                This request is functionally similar to an "Disable Device
                Given Hub Address and Port" request (page 74), except that
                the affected owner(s) ARE notified at the end of the process.

                If a device is disabled, enabling it will NOT cause it
                "recover" and start running normally again.  A device must be
                reset to "recover" from being disabled.





















                BIOS-LEVEL USB API 0.05            Page 103 of 168

       Reset Device Given Device Address
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Device
         Return Type: Large

         Entry:
           I14RRequestType   = 4Ah (I14RRTResetDevice)
           I14RHostIndex     = Host Index (0-15)
           I14RDeviceAddress = Address of Device to Reset
           I14RCallBackAddr  = Large Return Address (CS:IP)
           I14RUserPktID     = Value to return in BX on Large Return

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Large Return (Success):
           ZF = Set
           BX = I14RUserPktID of Requester
           AX = CX = DX = 0

         Large Return (Error):
           ZF = Clear
           AX = 8000h (TDStsLargeCallErr)
           BX = I14RUserPktID of Requester
           CX = DX = 0

         Owner Notifications:
           AX = 000Ah (OwnerCallDvcReset)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of Device being Reset (2-127)
           DX = 0

             Notifies interface owner(s) of all interfaces on the device that
             is being reset.










                BIOS-LEVEL USB API 0.05            Page 104 of 168

           AX = 008Ah (OwnerCallDvcResetUS)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of Device being Reset (2-127)
           DX = 0

             Notifies interface owner(s) of all device(s) downstream of the
             device being reset.  This only applies if the device being reset
             is a hub.

           AX = 0002h (OwnerCallDvcDisc)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of Device being Reset (2-127)
           DX = 0

             Notifies interface owner(s) of all interfaces on the device.  If
             the device being reset is a hub, all device(s) downstream of the
             hub are also disconnected.  Consequently, all interface
             owners(s) of all downstream device(s) will also receive a
             notification.


           AX = 0082h (OwnerCallDvcDiscUS)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of Device being Reset (2-127)
           DX = 0

             Notifies interface owner(s) of all device(s) downstream of the
             device being reset.  This only applies if the device being reset
             is a hub.  Consequently, interface owner(s) of all device(s)
             downstream of a hub being reset will receive both an
             OwnerCallDvcDiscUS notification (AX=0082h) and an
             OwnerCallDvcDisc notification (AX=0002h).

           AX = 0003h (OwnerCallDvc0Disc)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of Device being Reset (2-127)
           DX = 0

             Notifies device 0 owner(s) whose search criteria match alternate
             interface(s) of the device being reset under the current
             configuration.  If the device being reset is a hub, all
             device(s) downstream of the hub are also disconnected. 
             Consequently, all device 0 owners(s) whose search criteria match
             alternate interface(s) of device(s) downstream of the hub being
             reset will also receive a notification.




                BIOS-LEVEL USB API 0.05            Page 105 of 168

         Notes: This request initiates an entire reset/enumeration process on
                a device.  This process involves several different "sub-
                processes", resulting in several different notifications
                being sent to the owner of the hub that the device being
                reset is attached to.  Those notifications can include
                HubCallDisable (0079h), HubCallReset (007Ah), HubCallEnable
                (0078h), and HubCallEnumerated (0077h).

                This request is effectively a "software version" of
                momentarily detaching the device from the hub and then
                reinserting it again.  The same process is executed that
                occurs when a device is first attached to the bus.

                The device remains continuously attached to bus power during
                the entire reset/enumeration process.

                After the reset/enumeration process is complete, the device
                may not necessarily have the same address it did before the
                request was initiated.

                After the reset/enumeration process is complete, the device
                will normally be set to the "default" configuration
                (configuration value = 1).  If the device needs to be
                configured to any other value, including configuration value
                = 0 (unconfigured), you must use the "Reset Device and Set
                New Configuration" request (page 114).

                The large return does not necessarily occur at the end of the
                reset/enumeration process, but rather may occur sometime
                during the middle of the process.  The reset/enumeration
                process may continue for several hundred milliseconds after
                the large return is issued.

                This request is not the same thing as a "Reset Device Given
                Hub Address and Port" request (page 76).  This request
                initiates an entire reset/enumeration process on a device,
                while the "Reset Device Given Hub Address and Port" request
                simply performs one of the "sub-processes" involved in the
                entire reset/enumeration process.

                If a device is disabled, enabling it will NOT cause it
                "recover" and start running normally again.  A device must be
                reset to "recover" from being disabled.










                BIOS-LEVEL USB API 0.05            Page 106 of 168

       Suspend Device Given Device Address (Selective Suspend)
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Device
         Return Type: Large

         Entry:
           I14RRequestType   = 4Bh (I14RRTSuspendDevice)
           I14RHostIndex     = Host Index (0-15)
           I14RDeviceAddress = Address of Device to Suspend
           I14RCallBackAddr  = Large Return Address (CS:IP)
           I14RUserPktID     = Value to return in BX on Large Return

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Large Return (Success):
           ZF = Set
           BX = I14RUserPktID of Requester
           AX = CX = DX = 0

         Large Return (Error):
           ZF = Clear
           AX = 8000h (TDStsLargeCallErr)
           BX = I14RUserPktID of Requester
           CX = DX = 0

         Owner Notifications:
           AX = 007Bh (HubCallSuspend)
           BX = I14RUserPktID of Hub Owner
           CL = Hub Address
           CH = Hub Port Number
           DL = Large Call Index
           DH = Host Index (0-15)

             Notifies hub owner of the port to be suspended (the port that
             the device to be suspended is attached to).  The hub driver MUST
             inform the host driver when it is completed by issuing a "Large
             Call Completed" request (page 154) back to the host.







                BIOS-LEVEL USB API 0.05            Page 107 of 168

           AX = 000Bh (OwnerCallDvcSuspend)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of Device that was Suspended (2-127)
           DX = 0

             Notifies interface owner(s) of all interfaces on the device that
             was suspended.  The notification will only occur if the
             transaction was successful.

           AX = 008Bh (OwnerCallDvcSuspendUS)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of Device that was Suspended (2-127)
           DX = 0

             Notifies interface owner(s) of all device(s) downstream of the
             device that was suspended.  This only applies if the suspended
             device is a hub.  The notification will only occur if the
             transaction was successful.

         Notes: This request does not actually result in anything being sent
                directly to the device that is being suspended, but rather to
                the hub that the device is attached to.

                This request is functionally similar to an "Suspend Device
                Given Hub Address and Port (Selective Suspend)" request (page
                80), except that the affected owner(s) ARE notified at the
                end of the process.
























                BIOS-LEVEL USB API 0.05            Page 108 of 168

       Resume Device Given Device Address (Selective Resume)
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Device
         Return Type: Large

         Entry:
           I14RRequestType   = 4Ch (I14RRTResumeDevice)
           I14RHostIndex     = Host Index (0-15)
           I14RDeviceAddress = Address of Device to Resume
           I14RCallBackAddr  = Large Return Address (CS:IP)
           I14RUserPktID     = Value to return in BX on Large Return

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Large Return (Success):
           ZF = Set
           BX = I14RUserPktID of Requester
           AX = CX = DX = 0

         Large Return (Error):
           ZF = Clear
           AX = 8000h (TDStsLargeCallErr)
           BX = I14RUserPktID of Requester
           CX = DX = 0

         Owner Notifications:
           AX = 007Ch (HubCallResume)
           BX = I14RUserPktID of Hub Owner
           CL = Hub Address
           CH = Hub Port Number
           DL = Large Call Index
           DH = Host Index (0-15)

             Notifies hub owner of the port to be resumed (the port that the
             device to be resumed is attached to).  The hub driver MUST
             inform the host driver when it is completed by issuing a "Large
             Call Completed" request (page 154) back to the host.







                BIOS-LEVEL USB API 0.05            Page 109 of 168

           AX = 000Ch (OwnerCallDvcResume)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of Device that was Resumed (2-127)
           DX = 0

             Notifies interface owner(s) of all interfaces on the device that
             was resumed.  The notification will only occur if the
             transaction was successful.

           AX = 008Bh (OwnerCallDvcResumeUS)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of Device that was Resumed (2-127)
           DX = 0

             Notifies interface owner(s) of all device(s) downstream of the
             device that was resumed.  This only applies if the resumed
             device is a hub.  The notification will only occur if the
             transaction was successful.

         Notes: This request does not actually result in anything being sent
                directly to the device that is being resumed, but rather to
                the hub that the device is attached to.

                The large return does not necessarily occur at the end of the
                resume, but rather may occur sometime during the middle of
                the process.  The resume process may continue for several
                hundred milliseconds after the large return is issued.

                This request is functionally similar to an "Resume Device
                Given Hub Address and Port (Selective Resume)" request (page
                80), except that the affected owner(s) ARE notified at the
                end of the process.



















                BIOS-LEVEL USB API 0.05            Page 110 of 168

       Configuring Interface
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Configuration
         Return Type: Immediate

         Entry:
           I14RRequestType   = 51h (I14RRTConfigingIntf)
           I14RHostIndex     = Host Index (0-15)
           I14RDeviceAddress = Address of Device being configured (2-127)

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: This request is issued by a device driver while it is
                "configuring" an interface (downloading descriptors,
                selecting alternate interfaces, etc.).  The purpose of the
                request is to "warn" other device drivers that might be
                attempting to perform similar functions on other interfaces
                of the same device that they should wait, since many devices
                become "confused" if multiple configuration processes are
                occurring simultaneously.

                Technically, this request does not need to be issued while
                configuring an interface on a device that has only one
                interface.  However, it is highly recommended in all
                situations.

                If another "Configuring Interface" request is received for
                any interface on the same device while another "Configuring
                Interface" request is in process, the second request will
                return with an error code of I14RErrIntfInConfig.

                When the configuration process is complete, the Requester
                should issue a "Configuring Interface Complete" request (page
                113).  If a "Configuring Interface Complete" request is not
                received by the host driver within 5 seconds after receiving
                the "Configuring Interface" request, the host driver will
                automatically terminate the configuration process and
                essentially issue its own "Configuring Interface Complete"
                request.





                BIOS-LEVEL USB API 0.05            Page 111 of 168

                The process performed by this request is similar in concept
                to ownership registration, but is temporary rather than
                permanent, and affects the entire device instead of only a
                single interface.

















































                BIOS-LEVEL USB API 0.05            Page 112 of 168

       Configuring Interface Complete
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Configuration
         Return Type: Immediate

         Entry:
           I14RRequestType   = 52h (I14RRTConfigingIntfDone)
           I14RHostIndex     = Host Index (0-15)
           I14RDeviceAddress = Address of Device done configuring (2-127)

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: This request is issued to terminate a "Configuring Interface"
                request (page 111).  If a "Configuring Interface Complete"
                request is not received by the host driver within 5 seconds
                after receiving the "Configuring Interface" request, the host
                driver will automatically terminate the configuration process
                and essentially issue its own "Configuring Interface
                Complete" request.

























                BIOS-LEVEL USB API 0.05            Page 113 of 168

       Reset Device and Set New Configuration
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Configuration
         Return Type: Large

         Entry:
           I14RRequestType   = 58h (I14RRTSetNewConfig)
           I14RHostIndex     = Host Index (0-15)
           I14RDeviceAddress = Address of Device to Reconfigure
           I14RConfigValue   = New Configuration Value to set (0-255)
           I14RCallBackAddr  = Large Return Address (CS:IP)
           I14RUserPktID     = Value to return in BX on Large Return

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Large Return (Success):
           ZF = Set
           BX = I14RUserPktID of Requester
           AX = CX = DX = 0

         Large Return (Error):
           ZF = Clear
           AX = 8000h (TDStsLargeCallErr)
           BX = I14RUserPktID of Requester
           CX = DX = 0

         Owner Notifications:
           AX = 000Ah (OwnerCallDvcReset)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of Device being Reconfigured (2-127)
           DX = 0

             Notifies interface owner(s) of all interfaces on the device that
             is being reconfigured.









                BIOS-LEVEL USB API 0.05            Page 114 of 168

           AX = 008Ah (OwnerCallDvcResetUS)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of Device being Reconfigured (2-127)
           DX = 0

             Notifies interface owner(s) of all device(s) downstream of the
             device being reconfigured.  This only applies if the device
             being reconfigured is a hub.

           AX = 0002h (OwnerCallDvcDisc)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of Device being Reconfigured (2-127)
           DX = 0

             Notifies interface owner(s) of all interfaces on the device.  If
             the device being reconfigured is a hub, all device(s) downstream
             of the hub are also disconnected.  Consequently, all interface
             owners(s) of all downstream device(s) will also receive a
             notification.


           AX = 0082h (OwnerCallDvcDiscUS)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of Device being Reconfigured (2-127)
           DX = 0

             Notifies interface owner(s) of all device(s) downstream of the
             device being reconfigured.  This only applies if the device
             being reconfigured is a hub.  Consequently, interface owner(s)
             of all device(s) downstream of a hub being reconfigured will
             receive both an OwnerCallDvcDiscUS notification (AX=0082h) and
             an OwnerCallDvcDisc notification (AX=0002h).

           AX = 0003h (OwnerCallDvc0Disc)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = Device Address of Device being Reconfigured (2-127)
           DX = 0

             Notifies device 0 owner(s) whose search criteria match alternate
             interface(s) of the device being reconfigured under the current
             (old) configuration.  If the device being reconfigured is a hub,
             all device(s) downstream of the hub are also disconnected. 
             Consequently, all device 0 owners(s) whose search criteria match
             alternate interface(s) of device(s) downstream of the hub being
             reconfigured will also receive a notification.




                BIOS-LEVEL USB API 0.05            Page 115 of 168

         Notes: This request is the ONLY way to change the configuration
                value of a device, or to set the configuration value of a
                device to anything other than the default value of 1.

                This request is functionally the same as a "Reset Device
                Given Device Address" request (page 104), except for the
                portion of the reset/enumeration process where the device is
                configured.  For this request, the host driver will attempt
                to set the configuration to the value in I14RConfigValue when
                the request was issued.  If the device does not accept the
                requested configuration value for any reason, the host driver
                will then attempt to set the default configuration
                (configuration value = 1).

                This request initiates an entire reset/enumeration process on
                a device.  This process involves several different "sub-
                processes", resulting in several different notifications
                being sent to the owner of the hub that the device being
                reset is attached to.  Those notifications can include
                HubCallDisable (0079h), HubCallReset (007Ah), HubCallEnable
                (0078h), and HubCallEnumerated (0077h).

                This request is effectively a "software version" of
                momentarily detaching the device from the hub and then
                reinserting it again.  The same process is executed that
                occurs when a device is first attached to the bus.

                After the reset/enumeration process is complete, the device
                may not necessarily have the same address it did before the
                request was initiated.

                The device remains continuously attached to bus power during
                the entire reset/enumeration process.




















                BIOS-LEVEL USB API 0.05            Page 116 of 168

       Find Registered Interface
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Interface
         Return Type: Immediate

         Entry:
           I14RRequestType  = 62h (I14RRTFindRegIntf)
           I14RHostIndex    = Host Index (0-15, 255 = All Hosts)
           I14RSearchIndex  = Search Index to use (0-255)
           I14RVendorID     = Vendor ID of Dvc (FFFFh or 0000h = Don't Care)
           I14RProductID    = Product ID of Dvc (FFFFh or 0000h = Don't Care)
           I14RDvcClass     = Device Class of Device (FFh = Don't Care)
           I14RDvcSubClass  = Device SubClass of Device (FFh = Don't Care)
           I14RDvcProtocol  = Device Protocol of Device (FFh = Don't Care)
           I14RIntfClass    = Interface Class of Alternate Interface
                                (FFh = Don't Care)
           I14RIntfSubClass = Interface SubClass of Alternate Interface
                                (FFh = Don't Care)
           I14RIntfProtocol = Interface Protocol of Alternate Interface
                                (FFh = Don't Care)

         Return (Success):
           CF = Clear
           AX = 0
           BX = FFFFh
           CL = Host Index that Device is attached to (0-15)
           CH = Device Address (2-127)
           DL = Interface Number (0-255)
           DH = Alternate Interface Number (0-255)

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: Search index 0 will find the "first" registered interface
                matching the specified criteria.  The "first" interface is
                the one with the lowest alternate interface number,
                associated with the lowest interface number, on the device
                with the lowest address number, attached to the host with the
                lowest index number.  Search index 1 will find the "second"
                matching registered interface, etc.










                BIOS-LEVEL USB API 0.05            Page 117 of 168

                If one (or more) of the search criteria is "Don't Care"
                (FFFFh or 0000h in the vendor/product ID, or FFh in the
                device/interface class/subclass/protocol), it will ALWAYS
                "match" the corresponding field from the actual device.  It
                is not possible to specifically look for an FFFFh or 0000h in
                the actual vendor/product ID fields, nor is it possible to
                specifically look for an FFh (vendor-specific) value in the
                actual device/interface class/subclass/protocol fields.

                This request finds all matching alternate interfaces, even if
                those alternate interfaces are not currently selected.

                It is possible to look for an interface on a specific host,
                though I14RHostIndex for this request would normally be set
                to 255 (all hosts).

                This request finds interface(s) that already have a
                registered owner.  The only type of software that should need
                to look for already-registered interfaces are vendor-specific
                or product-specific drivers, which are wanting to "wrest"
                control of an interface from a more general-purpose device
                driver.  This request would not typically be used by "normal"
                device drivers.

                To process this request effectively with the possibility of
                multiple, semi-independent host drivers, each host driver
                will modify the ORIGINAL I14RSearchIndex value as it finds
                matching interface(s).  If I14RSearchIndex is not 0 when a
                host driver finds a matching interface, it will simply
                decrement I14RSearchIndex in the ORIGINAL request data
                structure that it received, and respond as if it did NOT find
                a matching Interface.  If the original request was issued
                with I14RHostIndex = 255 (all hosts), the host driver that
                received the original request will continue to "pass on" the
                request to each host driver individually, using the
                I14RSearchIndex as it was returned (and possibly modified) by
                the previous host driver.  Only when a matching interface is
                found and I14RSearchIndex is 0 will a host driver return a
                successful result.














                BIOS-LEVEL USB API 0.05            Page 118 of 168

       Find Unregistered Interface
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Interface
         Return Type: Immediate

         Entry:
           I14RRequestType  = 63h (I14RRTFindUnRegIntf)
           I14RHostIndex    = Host Index (0-15, 255 = All Hosts)
           I14RSearchIndex  = Search Index to use (0-255)
           I14RVendorID     = Vendor ID of Dvc (FFFFh or 0000h = Don't Care)
           I14RProductID    = Product ID of Dvc (FFFFh or 0000h = Don't Care)
           I14RDvcClass     = Device Class of Device (FFh = Don't Care)
           I14RDvcSubClass  = Device SubClass of Device (FFh = Don't Care)
           I14RDvcProtocol  = Device Protocol of Device (FFh = Don't Care)
           I14RIntfClass    = Interface Class of Alternate Interface
                                (FFh = Don't Care)
           I14RIntfSubClass = Interface SubClass of Alternate Interface
                                (FFh = Don't Care)
           I14RIntfProtocol = Interface Protocol of Alternate Interface
                                 (FFh = Don't Care)

         Return (Success):
           CF = Clear
           AX = 0
           BX = FFFFh
           CL = Host Index that Device is attached to (0-15)
           CH = Device Address (2-127)
           DL = Interface Number (0-255)
           DH = Alternate Interface Number (0-255)

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: Search index 0 will find the "first" unregistered interface
                matching the specified criteria.  The "first" interface is
                the one with the lowest alternate interface number,
                associated with the lowest interface number, on the device
                with the lowest address number, attached to the host with the
                lowest index number.  Search index 1 will find the "second"
                matching unregistered interface, etc.










                BIOS-LEVEL USB API 0.05            Page 119 of 168

                If one (or more) of the search criteria is "Don't Care"
                (FFFFh or 0000h in the vendor/product ID, or FFh in the
                device/interface class/subclass/protocol), it will ALWAYS
                "match" the corresponding field from the actual device.  It
                is not possible to specifically look for an FFFFh or 0000h in
                the actual vendor/product ID fields, nor is it possible to
                specifically look for an FFh (vendor-specific) value in the
                actual device/interface class/subclass/protocol fields.

                This request finds all matching alternate interfaces, even if
                those alternate interfaces are not currently selected.

                It is possible to look for an interface on a specific host,
                though I14RHostIndex for this request would normally be set
                to 255 (all hosts).


                To process this request effectively with the possibility of
                multiple, semi-independent host drivers, each host driver
                will modify the ORIGINAL I14RSearchIndex value as it finds
                matching interface(s).  If I14RSearchIndex is not 0 when a
                host driver finds a matching interface, it will simply
                decrement I14RSearchIndex in the ORIGINAL request data
                structure that it received, and respond as if it did NOT find
                a matching interface.  If the original request was issued
                with I14RHostIndex = 255 (all hosts), the host driver that
                received the original request will continue to "pass on" the
                request to each host driver individually, using the
                I14RSearchIndex as it was returned (and possibly modified) by
                the previous host driver.  Only when a matching interface is
                found and I14RSearchIndex is 0 will a host driver return a
                successful result.





















                BIOS-LEVEL USB API 0.05            Page 120 of 168

       Register As Interface Owner
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Interface
         Return Type: Immediate

         Entry:
           I14RRequestType   = 64h (I14RRTRegIntfOwner)
           I14RHostIndex     = Host Index Device is attached to (0-15)
           I14RDeviceAddress = Address of Device Interface is on (2-127)
           I14RInterfaceNum  = Interface Number to Register
           I14RCallBackAddr  = Notification Call Back Address (CS:IP)
                                 (Interface Owner)
           I14RUserPktID     = Value to return in BX on Notifications

         Return (Success):
           CF = Clear
           AX = 0
           BX = DX = FFFFh
           CX = Interface Owner Handle

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Owner Notifications:
           AX = (see NOTIFICATION CODES Table on page 10)
           BX = I14RUserPktID of Interface Owner
           CX = Depends on Notification Code
           DX = Depends on Notification Code

             The interface owner is notified when changes occur somewhere on
             the bus that would be of interest to the interface owner.  For
             example, an interface owner is notified if the device that the
             interface is on (or an upstream device) is disabled, enabled,
             reset, suspended, resumed, or detached from the bus.  Most any
             notification detailed in the NOTIFICATION CODES table (page 10)
             can be issued to an interface owner.

         Notes: There can be only one registered owner of an interface, no
                matter how many alternate interfaces are associated with that
                particular interface.

                The interface owner handle (the value returned in CX) must be
                "returned" (in I14RRequestHandle) in the "Unregister As
                Interface Owner" request (page 126).

                The requester will remain the interface owner until the host
                driver receives an "Unregister As Interface Owner" request
                (page 126), or until the interface (device) is disconnected.


                BIOS-LEVEL USB API 0.05            Page 121 of 168

                No software other than the registered owner of an interface
                can issue requests that will directly affect the operation of
                an interface.  For instance, a non-owner could issue a
                request to download a device or interface descriptor from the
                device, but could NOT issue a request to select a different
                alternate interface.

                If the interface (device) is a hub, the hub-specific
                notifications in the NOTIFICATION CODE TABLE (page 10) are
                issued to the registered interface owner.  There is not a
                special "Hub Owner Registration" process.

                The value in the I14RRequestType field for this request
                (I14RRTRegIntfOwner = 64h) is the same value used in a
                "Register as Device 0 (New Interface) Owner" request (page
                123).  In this request, I14RHostIndex must be a legitimate
                host index (0-15), and I14RDeviceAddress must be a legitimate
                device address (2-127).



































                BIOS-LEVEL USB API 0.05            Page 122 of 168

       Register As Device 0 (New Interface) Owner
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Interface
         Return Type: Immediate

         Entry:
           I14RRequestType   = 64h (I14RRTRegIntfOwner)
           I14RHostIndex     = 255 (All Hosts)
           I14RDeviceAddress = 0 (Newly Attached Devices)
           I14RVendorID      = Dvc Vendor ID (FFFFh or 0000h = Don't Care)
           I14RProductID     = Dvc Product ID (FFFFh or 0000h = Don't Care)
           I14RDvcClass      = Device Class of Device (FFh = Don't Care)
           I14RDvcSubClass   = Device SubClass of Device (FFh = Don't Care)
           I14RDvcProtocol   = Device Protocol of Device (FFh = Don't Care)
           I14RIntfClass     = Interface Class of Alternate Interface
                                 (FFh = Don't Care)
           I14RIntfSubClass  = Interface SubClass of Alternate Interface
                                 (FFh = Don't Care)
           I14RIntfProtocol  = Interface Protocol of Alternate Interface
                                 (FFh = Don't Care)
           I14RCallBackAddr  = Notification Call Back Address (CS:IP)
                                 (Device 0 Owner)
           I14RUserPktID     = Value to return in BX on Notifications

         Return (Success):
           CF = Clear
           AX = 0
           BX = DX = FFFFh
           CX = Device 0 Owner Handle (0-127)

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Owner Notifications:
           AX = 0001h (OwnerCallNewDvc)
           BX = I14RUserPktID of Device 0 Owner
           CL = Host Index (0-15)
           CH = Device Address of Newly Attached Device (2-127)
           DL = Interface Number that matching Alternate Interface is on
           DH = Matching Alternate Interface Number

             Notifies all registered device 0 owners whose search criteria
             match the characteristics of the newly attached device
             (I14RVendorID, I14RProductID, I14RDvcClass, I14RDvcSubClass,
             I14RDvcProtocol, I14RIntfClass, I14RIntfSubClass, and
             I14RIntfProtocol).




                BIOS-LEVEL USB API 0.05            Page 123 of 168

           AX = 0003h (OwnerCallDvc0Disc)
           BX = I14RUserPktID of Device 0 Owner
           CL = Host Index (0-15)
           CH = Device Address of Detached Device (2-127)
           DL = Interface Number that matching Alternate Interface is on
           DH = Matching Alternate Interface Number

             Notifies all registered device 0 owners whose search criteria
             match the characteristics of the detached device (I14RVendorID,
             I14RProductID, I14RDvcClass, I14RDvcSubClass, I14RDvcProtocol,
             I14RIntfClass, I14RIntfSubClass, and I14RIntfProtocol).

         Notes: This request registers an "outside" program to be notified
                when an interface (device) is first attached to or detached
                from the bus.  Software can (and should) periodically poll
                the host driver(s) to look for new devices, but this request
                provides a means of immediate notification.

                Depending on the total number of alternate interfaces a
                device has, and exactly how the search criteria are defined, 
                a device 0 owner may be notified multiple times for a single
                device attachment/detachment.

                The device 0 owner handle (the value returned in CX) must be
                "returned" (in I14RRequestHandle) in the "Unregister As
                Device 0 Owner" request (page 127).

                The requester will remain registered as a device 0 owner
                until the host driver receives an "Unregister As Device 0
                Owner" request (page 127).

                If one (or more) of the search criteria is "Don't Care"
                (FFFFh or 0000h in the vendor/product ID, or FFh in the
                device/interface class/subclass/protocol), it will ALWAYS
                "match" the corresponding field from the actual device.  It
                is not possible to specifically look for a 0000h or FFFFh in
                the actual vendor/product ID fields, nor is it possible to
                specifically look for an FFh (vendor-specific) value in the
                actual device/interface class/subclass/protocol fields.

                This request will match all alternate interfaces on a device,
                even if those alternate interfaces are not currently
                selected.

                The value in the I14RRequestType field for this request
                (I14RRTRegIntfOwner = 64h) is the same value used in a
                "Register as Interface Owner" request (page 121).  In this
                request, I14RHostIndex must be 255 (all hosts), and
                I14RDeviceAddress must be 0.




                BIOS-LEVEL USB API 0.05            Page 124 of 168

                The first host driver to receive this request will assign the
                device 0 owner handle (the 0-based index number in the device
                0 owner table).  It will then place the assigned handle
                number in I14RRequestHandle, "translate" the original request
                into an "InterHost Register As Device 0 Owner" request (page
                159), and issue the inter-host request to all host drivers
                individually.














































                BIOS-LEVEL USB API 0.05            Page 125 of 168

       Unregister As Interface Owner
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Interface
         Return Type: Immediate

         Entry:
           I14RRequestType   = 65h (I14RRTUnRegIntfOwner)
           I14RHostIndex     = Host Index Device is attached to (0-15)
           I14RRequestHandle = Interface Owner Handle

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: The interface owner handle is the value that was returned in
                the CX register during the "Register as Interface Owner"
                request (page 121).

                The value in the I14RRequestType field for this request
                (I14RRTUnRegIntfOwner = 65h) is the same value used in a
                "UnRegister as Device 0 (New Interface) Owner" request (page
                127).  In this request, I14RHostIndex must be a legitimate
                host index (0-15).























                BIOS-LEVEL USB API 0.05            Page 126 of 168

       Unregister As Device 0 (New Interface) Owner
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Interface
         Return Type: Immediate

         Entry:
           I14RRequestType   = 65h (I14RRTUnRegIntfOwner)
           I14RHostIndex     = 255 (All Hosts)
           I14RRequestHandle = Device 0 Owner Handle (0-127)

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: The device 0 owner handle is the value that was returned in
                the CX register during the "Register as Device 0 (New
                Interface) Owner" request (page 123).

                The value in the I14RRequestType field for this request
                (I14RRTUnRegIntfOwner = 65h) is the same value used in a
                "UnRegister as Interface Owner" request (page 126).  In this
                request, I14RHostIndex must be 255 (all hosts).

                The first host driver to receive this request will
                "translate" the original request into an "InterHost
                UnRegister As Device 0 Owner" request (page 162), and issue
                the inter-host request to all host drivers individually.



















                BIOS-LEVEL USB API 0.05            Page 127 of 168

       Unregister Current Interface Owner and Don't Look
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Interface
         Return Type: Immediate

         Entry:
           I14RRequestType   = 68h (I14RRTIntfDontLook)
           I14RHostIndex     = Host Index Device is attached to (0-15)
           I14RDeviceAddress = Address of Device Interface is on (2-127)
           I14RInterfaceNum  = Interface Number to UnRegister
           I14RTimeout       = Don't Look Timeout value to use (deciseconds)
                                 (0-255): Only the Least Significant Byte of
                                          I14RTimeout is used.
                                          The Most Significant Byte of the
                                          Word is ignored.

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Owner Notifications:
           AX = 0007h (OwnerCallDontLook)
           BX = I14RUserPktID of Interface Owner
           CL = Host Index (0-15)
           CH = Address of Device that Interface is On (2-127)
           DL = Interface Number to UnRegister
           DH = Don't Look Timeout value to use (deciseconds) (1-255)

             Notifies the existing interface owner that it needs to
             relinquish control (unregister as owner) of the interface, and
             to not try to regain control (re-register as owner) of the
             interface for a certain number of deciseconds.

         Notes: The purpose of this request is to provide a means for a new
                device/interface driver to "wrest" control from an existing
                ("old") device/interface driver.  Generally, the only time
                this might be needed is when a vendor-specific or product-
                specific driver wants to take control of an device/interface
                that is already being controlled by a general-purpose driver. 
                This request would not typically be used by "normal" device
                drivers.





                BIOS-LEVEL USB API 0.05            Page 128 of 168

                Before the "old" interface owner returns from the
                notification, it must issue appropriate requests back to the
                host driver to completely relinquish control of the
                interface.  It must cancel all scheduled bus transactions
                relating to the interface, unregister as the interface owner,
                and initiate an internal don't look timeout process.  The
                "old" interface owner must not attempt reset the device as a
                "shortcut" to relinquishing control.

                During the don't look time, the "old" interface owner must
                not look for any new interfaces.  If the "new" interface
                owner must reset the device to initialize it properly, the
                "old" interface owner will not be able to recognize the re-
                enumerated device as the one it's supposed to be "ignoring".

                The "old" interface owner cannot simply ignore what the
                notification is requesting in an attempt to try and maintain
                control of the interface.  The "old" interface owner must
                immediately relinquish control of the interface and not try
                to regain control during the requested don't look time.

                I14RTimeout should be kept as small as possible.  If the
                "new" interface owner will not need to reset the device,
                I14RTimeout should only need to be 1 or 2 deciseconds.  If
                the device does need to be reset, I14RTimeout will probably
                need to be significantly longer (something on the order of 20
                deciseconds should be sufficient).

                If I14RTimeout is 0, a "default" value of 20 deciseconds will
                be sent to the "old" interface owner in the DH register.

                Although I14RTimeout is designated as a 16-bit word, for this
                particular request ("Unregister Current Interface Owner and
                Don't Look"), the most significant byte of the word is
                ignored, and only the least significant byte of the word is
                used.  This means that the maximum number of deciseconds
                allowed for the don't look timeout value is 255 deciseconds.
















                BIOS-LEVEL USB API 0.05            Page 129 of 168

       Get Alternate Interface Information
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Alternate Interface
         Return Type: Immediate

         Entry:
           I14RRequestType   = 71h (I14RRTGetAltIntfInfo)
           I14RHostIndex     = Host Index Device is attached to (0-15)
           I14RDeviceAddress = Address of Device Interface is on (2-127)
           I14RInterfaceNum  = Interface Number the Alternate Interface is
                                 associated with
           I14RAltInterface  = Alternate Interface Number to get Info for

         Return (Success):
           CF = Clear
           AX = 0
           BL = Interface Class
           BH = Interface SubClass
           CL = Interface Protocol
           CH = Alternate Interface Bitmap
                Bit 0 (01h) = Set if Alternate Interface is Selected
                Bit 1 (02h) = Set if Interface is Owned
                Bits 2-7    = Reserved (0)
           DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: The host driver must monitor the appropriate control requests
                in "real time" so that it can process this request as an
                immediate return.  The host must NOT send a control packet
                across the bus requesting status(es) directly from the device
                before processing this request.

                Note that if an interface has multiple alternate interfaces
                "underneath" it, it is possible for bit 1 of the CH register
                to be set (indicating that the interface is owned) even if
                bit 0 is not set (indicating that alternate interface is not
                the one currently selected).  An unselected alternate
                interface is effectively irrelevant (it cannot be used for
                anything), even though it may be "owned" because the
                interface "above" it is owned.








                BIOS-LEVEL USB API 0.05            Page 130 of 168

       Get Current DataX Value
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       End Point
         Return Type: Immediate

         Entry:
           I14RRequestType    = 81h (I14RRTGetDataX)
           I14RHostIndex      = Host Index Device is attached to (0-15)
           I14RDeviceAddress  = Address of Device Interface is on (2-127)
           I14REndPoint       = End Point to get DataX value of (1-15)
                                  (Bulk or Interrupt EndPoint)
           I14RFlags:
             I14RFlagIn (01h) = Set if End Point Direction is In
                              = Clear if End Point Direction is Out

         Return (Success):
           CF = Clear
           AX = 0
           BL = Current DataX value for End Point
                  00h = Data0
                  01h = Data1
           BH = FFh
           CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: DataX (Data0 and Data1) is a flow control mechanism used by
                the USB architecture when sending multiple packets to the
                same end point.  Read the USB specifications if you need
                further implementation details.

                The direction associated with the end point is embedded in
                bit 0 (I14RFlagIn) of the I14RFlags register.  This is NOT
                the same format used in the end point descriptor (bit 7 of
                the end point number).

                The host driver normally handles all DataX processing
                automatically.  This request, in addition to the "Increment
                (Toggle) DataX Value" request (page 132), allows you to
                manually change the current DataX value if the end point
                requires it for some reason (such as if the device does not
                respond appropriately to "Clear End Point Feature: Halt"
                control requests).






                BIOS-LEVEL USB API 0.05            Page 131 of 168

       Increment (Toggle) DataX Value
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       End Point
         Return Type: Immediate

         Entry:
           I14RRequestType    = 88h (I14RRTIncDataX)
           I14RHostIndex      = Host Index Device is attached to (0-15)
           I14RDeviceAddress  = Address of Device Interface is on (2-127)
           I14REndPoint       = End Point to change DataX value of (1-15)
                                  (Bulk or Interrupt EndPoint)
           I14RFlags:
             I14RFlagIn (01h) = Set if End Point Direction is In
                              = Clear if End Point Direction is Out

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: DataX (Data0 and Data1) is a flow control mechanism used by
                the USB architecture when sending multiple packets to the
                same end point.  Read the USB specifications if you need
                further implementation details.

                The direction associated with the end point is embedded in
                bit 0 (I14RFlagIn) of the I14RFlags register.  This is NOT
                the same format used in the end point descriptor (bit 7 of
                the end point number).

                The host driver normally handles all DataX processing
                automatically.  This request, in addition to the "Get Current
                DataX Value" request (page 131), allows you to manually
                change the current DataX value if the end point requires it
                for some reason (such as if the device does not respond
                appropriately to "Clear End Point Feature: Halt" control
                requests).

                The host driver monitors all "Clear End Point Feature: Halt"
                control requests, and if they are successful, automatically
                resets the end point to Data0.






                BIOS-LEVEL USB API 0.05            Page 132 of 168

                Changing the DataX value should only be performed on end
                points that process bulk and interrupt transactions. 
                Isochronous transactions do not use DataX flow control, and
                control transactions always initialize at Data0.

















































                BIOS-LEVEL USB API 0.05            Page 133 of 168

       Schedule Isochronous Transaction
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Packet
         Return Type: Schedule

         Entry:
           I14RRequestType    = 94h (I14RRTDoIsoch)
           I14RHostIndex      = Host Index Device is attached to (0-15)
           I14RDeviceAddress  = Device Address to send Transaction to (2-127)
           I14REndPoint       = End Point to send Transaction to (0-15)
           I14RPeriodicity    = # of Frames before schedule repeats (1-1024)
                                  (Number of entries in the
                                   I14RIsochSchedAddr Table)
           I14RDataAddress    = Memory Address associated with first
                                  scheduled Isochronous Frame
                                  (32-bit Physical or Segment:Offset)
           I14RFrameIndex     = Starting Frame Index to use (0-1023)
                                  (only valid if I14RFlagSpecificFrame set)
           I14RIsochSchedAddr = Address where Isochronous Schedule Table
                                  is located (Segment:Offset)
           I14RCallBackAddr   = Notification Call Back Address (CS:IP)
                                  (Packet Owner)
           I14RUserPktID      = Value to return in BX on Notifications
           I14RFlags:
             I14RFlagIn             (01h) = Set if Data Direction = In
                                              (Device to Host)
                                          = Clear if Data Direction = Out
                                              (Host to Device)
             I14RFlagSpecificFrame  (40h) = Set if the Schedule should start
                                              at a specific Frame Index (the
                                              one in I14RFrameIndex)
                                          = Clear if Host Driver should
                                              automatically select the
                                              starting Frame Index
             I14RFlagAddrIsPhysical (80h) = Set if I14RDataAddress is a
                                              32-bit Physical Address
                                          = Clear if I14RDataAddress is a
                                              Segment:Offset Address

         Return (Success):
           CF = Clear
           AX = 0
           BX = Starting Frame Index (0-1023)
           CX = Transaction Handle
           DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh


                BIOS-LEVEL USB API 0.05            Page 134 of 168

         Owner Notifications:
           AX = (see Status Codes Table on page 14)
           BX = I14RUserPktID of Packet Owner
           CX = Actual Number of Bytes Transferred by the Packet
           DL = Packet Sequence Number (0 = First Packet in Schedule, etc.)
           DH = 0

             The packet owner is notified of the status of each packet
             scheduled to be transferred across the bus.

         Notes: The isochronous schedule table (the table stored at
                I14RIsochschedAddr) is a list of words containing the number
                of bytes to transfer in each frame.  Each entry in the table
                must be between 0 and 1023.

                There can be a maximum of 256 non-zero entries in the
                isochronous schedule table (entries indicating that at least
                one byte is to be transmitted in the frame).  The maximum
                number of bytes that can be transmitted in an isochronous
                period is 261,888 (1023 bytes/frame * 256 frames).

                Isochronous transactions, unlike other types of packet
                transactions, do not naturally provide constant status
                "feedback".  An isochronous transaction may need another
                "corresponding" transaction (like a periodic interrupt) in
                order to maintain synchronization with the bus.

                The individual packet status notifications received by the
                packet owner will not necessarily be in the same order that
                the packets are scheduled.  The packet sequence number (the
                DL register on packet owner notifications) can be used to
                "reorganize" the packets into the correct order if needed.

                The transaction handle (the value returned in CX) must be
                "returned" (in I14RRequestHandle) in the "Close Transaction
                Handle" request (page 147).

















                BIOS-LEVEL USB API 0.05            Page 135 of 168

                An example request might look something like this:

                   I14RRequestType   =   94h ;I14RRTDoIsoch
                   I14RFlags         =   41h ;Data Direction = In
                                             ;Start at the Frame Index
                                             ;  in I14RFrameIndex
                                             ;Data Address is Segment:Offset
                   I14RHostIndex     =    0  ;Host Index 0
                   I14RDeviceAddress =    6  ;Device Address 6
                   I14REndPoint      =    1  ;End Point 1
                   I14RPeriodicity   =   10h ;Schedule repeats after
                                             ;  16 Frames
                                             ;There are 16 entries in
                                             ;  the Schedule Table
                   I14RFrameIndex    =    3  ;Start at Frame Index 3

                   I14RCallBackAddr   = 2222:0200h ;Notification Address
                   I14RUserPktID      =      0000h ;Value to return in BX
                                                   ;  on Notifications
                   I14RDataAddress    = 2222:1000h ;Segment:Offset where
                                                   ;  first byte of data
                                                   ;  will be stored
                   I14RIsochSchedAddr = 2222:1200h ;Segment:Offset where
                                                   ;  Schedule Table
                                                   ;  is stored

                   Data stored at 2222:1200h (the Schedule Table):
                     DW 0020h, 0000h, 0000h, 0000h ;32, 0, 0, 0
                     DW 0010h, 0000h, 0000h, 0000h ;16, 0, 0, 0
                     DW 0010h, 0000h, 0000h, 0000h ;16, 0, 0, 0
                     DW 0030h, 0000h, 0000h, 0000h ;48, 0, 0, 0

                   This example request would set up an isochronous
                   transaction on the bus, which would repeat every 16
                   frames.  At frame index 3 (sequence 0), 32 bytes would be
                   scheduled to transfer from host 0, device 6, endpoint 1 to
                   memory address 2222:1000h.  At frame index 7 (sequence 1),
                   16 bytes would be scheduled to transfer from host 0,
                   device 6, endpoint 1 to memory address 2222:1020h.  At
                   frame index 11 (sequence 2), 16 bytes would be scheduled
                   to transfer from host 0, device 6, endpoint 1 to memory
                   address 2222:1030h.  At frame index 15 (sequence 3), 48
                   bytes would be scheduled to transfer from host 0, device
                   6, endpoint 1 to memory address 2222:1040h.  At frame
                   index 19, the schedule will start all over again (sequence
                   0), and 32 bytes would be scheduled to transfer from host
                   0, device 6, endpoint 1 to memory address 2222:1000h.  The
                   schedule will continue indefinitely until the host
                   receives a "Close Transaction Handle" request, or until
                   device 6 is disconnected from host 0.



                BIOS-LEVEL USB API 0.05            Page 136 of 168

       Schedule Periodic Interrupt Transaction
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Packet
         Return Type: Schedule

         Entry:
           I14RRequestType    = 95h (I14RRTDoInterruptPer)
           I14RHostIndex      = Host Index Device is attached to (0-15)
           I14RDeviceAddress  = Device Address to send Transaction to (1-127)
           I14REndPoint       = End Point to send Transaction to (0-15)
           I14RPeriodicity    = Number of Frames between Interrupts (1-1024)
           I14RDataAddress    = Memory Address where Data is/will be stored
                                  (32-bit Physical or Segment:Offset)
           I14RDataSize       = Bytes to Transfer each Interrupt (0-65535)
                                  (see Notes regarding upper limit)
           I14RFrameIndex     = Starting Frame Index to use (0-1023)
                                  (only valid if I14RFlagSpecificFrame set)
           I14RCallBackAddr   = Notification Call Back Address (CS:IP)
                                  (Packet Owner)
           I14RUserPktID      = Value to return in BX on Notifications
           I14RFlags:
             I14RFlagIn             (01h) = Set if Data Direction = In
                                              (Device to Host)
                                          = Clear if Data Direction = Out
                                              (Host to Device)
             I14RFlagSpecificFrame  (40h) = Set if Interrupts should start
                                              at a specific Frame Index (the
                                              one in I14RFrameIndex)
                                          = Clear if Host Driver should
                                              automatically select the
                                              starting Frame Index
             I14RFlagAddrIsPhysical (80h) = Set if I14RDataAddress is a
                                              32-bit Physical Address
                                          = Clear if I14RDataAddress is a
                                              Segment:Offset Address

         Return (Success):
           CF = Clear
           AX = 0
           BX = DX = FFFFh
           CX = Transaction Handle

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh






                BIOS-LEVEL USB API 0.05            Page 137 of 168

         Owner Notifications:
           AX = (see Status Codes Table on page 14)
           BX = I14RUserPktID of Packet Owner
           CX = Actual Number of Bytes Transferred by the Packet
           DX = 0

             The packet owner is notified of the status of each packet
             scheduled to be transferred across the bus.

         Notes: Unlike most other types of packet transactions, a periodic
                interrupt can be scheduled to go to device address 1 (the
                root hub).  The root hub is a "virtual" device that does not
                actually exist on the bus, so any packets scheduled to go to
                the root hub will fail (notifications will contain a non-zero
                status code in AX).  Such packet transactions can be used
                simply to generate periodic interrupts that control timing
                (they will never actually return any valid USB device data).

                I14RDataSize is listed as allowing any number between 0 and
                65535, but the upper limit is actually dependent on several
                factors, including the speed of the device and the
                characteristics of the endpoint.  The absolute maximum size
                of a periodic interrupt transaction to a low-speed device is
                48 bytes, and to a full-speed device is 1043 bytes.

                If I14RDataSize is larger than the maximum packet size
                allowed by the endpoint, the host driver will automatically
                "divide" the transaction into smaller, appropriately-sized
                packets.  Owner notifications will always be processed as if
                there were a single packet scheduled on the bus.

                If I14RFlagSpecificFrame is set, the periodicity of the
                interrupt will be maintained religiously by the host driver. 
                If the bus is heavily loaded, this may result in packets
                becoming "lost" (never actually being sent across the bus,
                resulting in a status code which includes 0008h, or
                TDStsOverDue).  If I14RFlagSpecificFrame is not set, and the
                bus is heavily loaded, the host driver may periodically
                "slide" the packet back and forth in the schedule slightly to
                decrease the odds of it becoming "lost".

                While it is theoretically possible to schedule a periodic
                interrupt with a periodicity of 1 frame, it may not actually
                be possible to do (at least not reliably).  The minimum
                recommended periodicity is 2 frames.

                The transaction handle (the value returned in CX) must be
                "returned" (in I14RRequestHandle) in the "Close Transaction
                Handle" request (page 147).




                BIOS-LEVEL USB API 0.05            Page 138 of 168

       Schedule Control (Setup) Transaction
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Packet
         Return Type: Schedule

         Entry:
           I14RRequestType   = 96h (I14RRTDoControl)
           I14RHostIndex     = Host Index Device is attached to (0-15)
           I14RDeviceAddress = Device Address to send Transaction to (2-127)
           I14REndPoint      = End Point to send Transaction to (0-15)
           I14RTimeout       = Transaction Timeout value (deciseconds)
                                 (0-18000)
           I14RDataAddress   = Memory Address where Data is/will be stored
                                 (32-bit Physical or Segment:Offset)
           I14RCallBackAddr  = Notification Call Back Address (CS:IP)
                                 (Transaction Owner)
           I14RUserPktID     = Value to return in BX on Notification
           I14RSetupReqData  = 8-byte Control Setup Packet to send to Device
                                 (contains embedded Direction & Data Size)
           I14RFlags:
             I14RFlagNoRetries      (10h) = Set if unsuccessful
                                              Transactions should not be
                                              not automatically retried
                                          = Clear if unsuccessful
                                              Transactions should be
                                              Automatically retried
             I14RFlagShortPktOK     (20h) = Set if short data packet
                                              errors should not be retried
                                          = Clear if short data packet
                                              errors should be retried
             I14RFlagAddrIsPhysical (80h) = Set if I14RDataAddress is a
                                              32-bit Physical Address
                                          = Clear if I14RDataAddress is a
                                              Segment:Offset Address

         Return (Success):
           CF = Clear
           AX = 0
           BX = FFFFh
           CX = Transaction Handle
           DL = Closure ID (non-zero)
           DH = FFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh





                BIOS-LEVEL USB API 0.05            Page 139 of 168

         Owner Notification:
           AX = (see Status Codes Table on page 14)
           BX = I14RUserPktID of Transaction Owner
           CX = Actual Number of Bytes Transferred by the Transaction
           DX = 0

             The transaction owner is notified of the status of the
             transaction after it has been completed.

         Notes: The 8-byte setup control packet (I14RSetupReqData) contains
                embedded the direction (in/out) & data size (bytes) of the
                actual data (if any) to be transferred to/from the device
                after the setup packet has been transferred.  Therefore,
                I14RDataSize & I14RFlagIn are not used.

                I14RDataAddress contains the address of the actual data (if
                any) to be transferred after the setup packet has been
                transferred.

                If the actual data size is larger than the maximum packet
                size allowed by the endpoint, the host driver will
                automatically "divide" the transaction into smaller,
                appropriately-sized packets.

                The value in I14RTimeout is used to keep the transaction from
                "stalling out" due to an unresponsive device.  If the
                transaction has not completed before the timeout period has
                expired, the transaction will automatically be canceled by
                the host driver and a status code which includes 0004h
                (TDStsTimeout) will be returned.

                If I14RFlagNoRetries is clear, the control transaction will
                be retried as many as 8 times before finally declaring the
                transaction to be in error.  There is no time delay between
                each retry.  The error code returned will correspond to the
                status of the last retry.

                The value in I14RTimeout is the time allotted for each retry,
                not the total time for all retries combined.  For example,
                using the default values of 8 retries and 10 deciseconds (one
                second) per attempt, a control Transaction that fails each
                time due to a Timeout will require a minimum of 9 seconds to
                complete.

                The clock that controls the timeout stops counting down while
                the host is stopped/halted.

                If I14RTimeout is 0, a "default" value of 10 deciseconds will
                be used.  The maximum value allowed for I14RTimeout is 18000
                deciseconds (approximately 1/2 hour).



                BIOS-LEVEL USB API 0.05            Page 140 of 168

                The only type of transaction that can be automatically
                retried, in it entirety, is a control transaction: entire
                bulk, interrupt, and isochronous transactions are not retried
                automatically.

                If I14RFlagShortPacketOK is set, the transaction will not be
                considered in error if the only error is a short packet. 
                This can be useful, for example, when requesting a string
                descriptor from a device, where the actual length of the
                descriptor is unknown until after it has already been
                downloaded.

                If the status code returned at the end of the transaction
                with the TDStsControlSetup bit (1000h) set, it means that the
                error occurred while the transaction was still in the setup
                stage, and the actual data stage was never reached.  The most
                significant implication of this is that the value returned in
                the CX register (the actual number of bytes transferred by
                the transaction) is the number of bytes of the 8-byte setup
                packet that were transferred, not the number of bytes of
                "real" data that were transferred.

                If a control transaction is issued to end point 0 of a
                device, and there is already a control transaction in
                progress to the same end point (end point 0) of the same
                device, the host driver will automatically place the new
                request "On Hold" (in a queue awaiting transmission onto the
                bus).  When the original (older) control transaction is
                completed, the newer control transaction will be
                automatically sent across the bus.  This is done because
                endpoint 0 is common to all interfaces of a device, but only
                one control transaction at a time can typically be processed
                by a device.  Interface drivers are independent and not
                required to communicate and coordinate schedules with one
                another, so this functionality is automatically provided by
                the host driver.

                The host driver needs to "monitor" certain types of control
                requests for internal tracking purposes.  Examples of
                requests that need to be monitored are "Set Device
                Configuration", "Set Alternate Interface", and "Clear End
                Point Feature: Halt".

                The host driver will reject all control requests to change a
                device's address.








                BIOS-LEVEL USB API 0.05            Page 141 of 168

                The transaction handle and closure ID (the values returned in
                CX and DL) must be "returned" (in I14RRequestHandle and
                I14RCloseID, respectively) in the "Close Transaction Handle"
                request (page 147).  There should almost never be a need to
                close a control transaction prematurely, however, as long as
                I14RTimeout was set appropriately.

                The closure ID (the value returned in DL) will never be 0.













































                BIOS-LEVEL USB API 0.05            Page 142 of 168

       Schedule Bulk Transaction
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Packet
         Return Type: Schedule

         Entry:
           I14RRequestType    = 97h (I14RRTDoBulk)
           I14RHostIndex      = Host Index Device is attached to (0-15)
           I14RDeviceAddress  = Device Address to send Transaction to (2-127)
           I14REndPoint       = End Point to send Transaction to (0-15)
           I14RTimeout        = Transaction Timeout value (deciseconds)
                                  (0-18000)
           I14RDataAddress    = Memory Address where Data is/will be stored
                                  (32-bit Physical or Segment:Offset)
           I14RDataSize       = Bytes to Transfer (0-65535)
           I14RCallBackAddr   = Notification Call Back Address (CS:IP)
                                  (Transaction Owner)
           I14RUserPktID      = Value to return in BX on Notification
           I14RFlags:
             I14RFlagIn             (01h) = Set if Data Direction = In
                                              (Device to Host)
                                          = Clear if Data Direction = Out
                                              (Host to Device)
             I14RFlagAddrIsPhysical (80h) = Set if I14RDataAddress is a
                                              32-bit Physical Address
                                          = Clear if I14RDataAddress is a
                                              Segment:Offset Address

         Return (Success):
           CF = Clear
           AX = 0
           BX = FFFFh
           CX = Transaction Handle
           DL = Closure ID (non-zero)
           DH = FFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Owner Notification:
           AX = (see Status Codes Table on page 14)
           BX = I14RUserPktID of Transaction Owner
           CX = Actual Number of Bytes Transferred by the Transaction
           DX = 0

             The transaction owner is notified of the status of the
             transaction after it has been completed.



                BIOS-LEVEL USB API 0.05            Page 143 of 168

         Notes: If I14RDataSize is larger than the maximum packet size
                allowed by the endpoint, the Host Driver will automatically
                "divide" the transaction into smaller, appropriately-sized
                packets.  The owner notification will always be processed as
                if the transaction were a single packet scheduled on the bus.

                The value in I14RTimeout is used to keep the transaction from
                "stalling out" due to an unresponsive device.  If the
                transaction has not completed before the timeout period has
                expired, the transaction will automatically be canceled by
                the host driver and a status code which includes 0004h
                (TDStsTimeout) will be returned.

                The clock that controls the timeout stops counting down while
                the host is stopped/halted.

                If I14RTimeout is 0, a "default" value of 50 deciseconds will
                be used.  The maximum value allowed for I14RTimeout is 18000
                deciseconds (approximately 1/2 hour).

                The transaction handle and closure ID (the values returned in
                CX and DL) must be "returned" (in I14RRequestHandle and
                I14RCloseID, respectively) in the "Close Transaction Handle"
                request (page 147).  There should almost never be a need to
                close a bulk transaction prematurely, however, as long as
                I14RTimeout was set appropriately.

                The closure ID (the value returned in DL) will never be 0.

























                BIOS-LEVEL USB API 0.05            Page 144 of 168

       Schedule One-Time Interrupt Transaction
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Packet
         Return Type: Schedule

         Entry:
           I14RRequestType    = 98h (I14RRTDoInterrupt1T)
           I14RHostIndex      = Host Index to use (0-15)
           I14RPeriodicity    = Number of Frames to Delay (1-65535)
           I14RCallBackAddr   = Notification Call Back Address (CS:IP)
                                  (Transaction Owner)
           I14RUserPktID      = Value to return in BX on Notification

         Return (Success):
           CF = Clear
           AX = 0
           BX = FFFFh
           CX = Transaction Handle
           DL = Closure ID (non-zero)
           DH = FFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Owner Notification:
           AX = 0000h (TDStsOK)
           BX = I14RUserPktID of Transaction Owner
           CX = DX = 0

             The transaction owner is notified after the transaction has been
             completed.

         Notes: This request effectively issues a "background delay", which
                can be used as a very effective way to control timing of
                background processes.

                It is not possible to send data across the bus with a one-
                time interrupt transaction.  It is only possible to control
                timing.

                The resolution of the delay timer is one USB frame
                (approximately one millisecond).  The maximum delay allowed
                is 65535 USB frames, which is approximately 65.535 seconds.







                BIOS-LEVEL USB API 0.05            Page 145 of 168

                Internally, the host controller driver issues a packet
                request on the bus to device address 1 (the Root Hub), end
                point 0.  Therefore, device address 1 and end point 0 must be
                provided In the "Get Status of Packet Transaction" call (page
                150) when requesting the status of a one-time interrupt
                transaction.

                The transaction handle and closure ID (the values returned in
                CX and DL) must be "returned" (in I14RRequestHandle and
                I14RCloseID, respectively) in the "Close Transaction Handle"
                request (page 147).

                The closure ID (the value returned in DL) will never be 0.








































                BIOS-LEVEL USB API 0.05            Page 146 of 168

       Close Transaction Handle
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Packet
         Return Type: Immediate

         Entry:
           I14RRequestType   = 9Ch (I14RRTCloseHandle)
           I14RHostIndex     = Host Index Transaction is on (0-15)
           I14RCloseID       = Closure ID of Transaction to Close
                                 (only needed for Bulk, Control, and
                                  One-Time Interrupt Transactions)
           I14RRequestHandle = Handle number of Transaction to Close

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: This request closes (cancels prematurely) all types of packet
                transactions (isochronous, periodic interrupt, control, bulk,
                and one-time interrupt).

                The transaction handle (in I14RRequestHandle) is the value
                that was returned in the CX register during the request that
                initiated the transaction.

                The closure ID (in I14RCloseID) is the value that was
                returned in the DL register during the request that initiated
                the transaction.  This only applies to bulk, control (setup),
                and one-time interrupt packet transactions.  Isochronous and
                periodic interrupt transactions do not require closure ID's.

                Handle numbers can be reused by a host driver immediately
                after a transaction is closed, and a host driver
                automatically closes certain types of transactions upon
                completion.  By requiring both a closure ID and a handle
                number in order to close a transaction, the host driver can
                be certain that a request to close a handle is truly being
                issued by the correct owner.








                BIOS-LEVEL USB API 0.05            Page 147 of 168

                When a device is disconnected or reset, all packet
                transactions currently in progress or scheduled to the device
                are AUTOMATICALLY removed from the schedule, immediately
                after being issued a TD status code of TDStsDvcRemoved.  This
                request must NEVER be issued by a device driver after being
                notified that the device has been disconnected, or it could
                adversely affect a device other than the one intended.














































                BIOS-LEVEL USB API 0.05            Page 148 of 168

       Change Periodicity of Periodic Interrupt
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Packet
         Return Type: Immediate

         Entry:
           I14RRequestType   = 9Dh (I14RRTChangeIntPer)
           I14RHostIndex     = Host Index Transaction is on (0-15)
           I14RRequestHandle = Handle number of Transaction to Change
                                 (must be a Periodic Interrupt Handle)
           I14RPeriodicity   = Number of Frames between Interrupts (1-1024)
                                 (new value to replace current Periodicity)

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: This request provides a simple way to change the "sampling
                rate" of a periodic interrupt.  Without this request,
                changing the periodicity would require closing the existing
                periodic interrupt transaction, and then scheduling a new
                transaction.

                The transaction handle (in I14RRequestHandle) is the value
                that was returned in the CX register during the original
                "Schedule Periodic Interrupt Transaction" request (page 137).




















                BIOS-LEVEL USB API 0.05            Page 149 of 168

       Get Status of Packet Transaction
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Packet
         Return Type: Immediate

         Entry:
           I14RRequestType   = 9Fh (I14RRTGetTransStatus)
           I14RHostIndex     = Host Index Transaction is on (0-15)
           I14RDeviceAddress = Device Address that Transaction was
                                 sent to (1-127)
           I14REndPoint      = End Point that Transaction was sent to (0-15)
           I14RRequestHandle = Handle number of Transaction to get Status of

         Return (Success):
           CF = Clear
           AX = 0
           BH = 0
           BL = Flags/Special Codes
                Bulk:         BL = 0
                Control:      BL = Stage & Automatic Retry Status
                                   Low Nibble = Current Stage
                                        0 = On Hold
                                        1 = Setup Stage
                                        2 = Data Stage
                                        3 = Status Stage
                                     4-15 = Reserved (Unused)
                                   High Nibble = Number of times the
                                     Transaction will be automatically
                                     attempted (retried) if the current
                                     attempt is unsuccessful (0-7)
                Isochronous:  BL = High Byte of Number of Data Bytes
                                     remaining to be sent in current
                                     Transaction Period (total number of
                                     data bytes is BL:DX)
                Periodic Int: BL = Overdue Status
                                   Bits 0-6    = Reserved (0)
                                   Bit 7 (80h) = Set if Transaction is
                                                   Overdue
                One-Time Int: BL = Overdue Status
                                   Bits 0-6    = Reserved (0)
                                   Bit 7 (80h) = Set if Transaction is
                                                   Overdue










                BIOS-LEVEL USB API 0.05            Page 150 of 168

           CX = Approximate time left until Transaction is complete
                Bulk:         CX = Deciseconds remaining until
                                     Transaction Timeout
                Control:      CX = Deciseconds remaining until
                                     Transaction Timeout
                Isochronous:  CX = Frames remaining in Transaction Period
                Periodic Int: CX = Frames remaining in Transaction Period
                One-Time Int: CX = Frames remaining until Transaction
                                     is complete

           DX = Approximate number of bytes remaining in Transaction
                Bulk:         DX = Bytes remaining to be sent in Transaction
                Control:      DX = Bytes remaining to be sent in Data Stage
                                     of Transaction
                Isochronous:  DX = Low Word of Number of Data Bytes
                                     remaining to be sent in current
                                     Transaction Period (total number of
                                     data bytes is BL:DX)
                Periodic Int: DX = Bytes remaining to be sent in current
                                     Transaction Period
                One-Time Int: DX = 0

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh


         Notes: This request provides the method to monitor the progress of a
                packet-based Transaction that is being processed in the
                background (Bulk, Control, Isochronous, Periodic Interrupt,
                or One-Time Interrupt).  There is no method provided to
                monitor other types of Transactions (such as those with a
                Large Return).

                The transaction handle (in I14RRequestHandle) is the value
                that was returned in the CX register during the request that
                initiated the transaction.

                The Device Address (I14RDeviceAddress) and End Point
                (I14REndPoint) must be the same as those provided during the
                request that initiated the transaction.  These must be
                provided to ensure that only the requester of original
                transaction can request the status.  If the transaction is a
                one-time interrupt, I14RDeviceAddress must be 1, and
                I14REndPoint must be 0.







                BIOS-LEVEL USB API 0.05            Page 151 of 168

                Values returned in CX (time), DX (bytes), or BL:DX (bytes)
                are approximate, not exact.  The transaction is processed by
                the hardware as a background process, and the status as
                provided by this request is simply an attempt by the software
                to take an instantaneous "snapshot" of the hardware at a
                particular instant in time.

                A control transaction is given a status of "On Hold" if it is
                directed at end point 0, and there is already another control
                transaction scheduled to end point 0 of the same device.  "On
                Hold" indicates that the control transaction is in queue
                awaiting the previous (older) control transaction to
                complete.  When the previous control transaction is complete,
                the newer control transaction will be automatically sent
                across the bus (the status of the newer transaction will
                change from "On Hold" to "Setup Stage").  This is done
                because endpoint 0 is common to all interfaces of a device,
                but only one control transaction at a time can typically be
                processed by a device.  Interface drivers are independent and
                not required to communicate and coordinate schedules with one
                another, so this functionality is automatically provided by
                the host driver.

                A periodic interrupt or one-time interrupt transaction is
                considered overdue when it is scheduled to occur at some
                particular time but is not processed properly by the host
                hardware for some reason.  This can happen, for instance, if
                the host hardware does not process hardware interrupts
                (IRQ's) properly, or if the bus is near capacity. 
                Isochronous packets can fail for many of the same reasons as
                periodic and interrupt transactions, but are never considered
                "overdue" simply due to the definition of isochronous
                transactions.

                The units returned for time values (in the CX register) are
                deciseconds for bulk and control transactions, and USB frame
                durations (milliseconds) for isochronous, periodic interrupt,
                and one-time Interrupt transactions.

                The value returned in the CX register (deciseconds remaining
                until transaction timeout) for bulk and control transactions
                is not necessarily the time remaining in the transaction.  If
                the transaction completes in the hardware before the timeout
                period expires, whether the transaction is successful or
                unsuccessful, the transaction is consider complete.








                BIOS-LEVEL USB API 0.05            Page 152 of 168

                The value returned in the DX register for control
                transactions (number of bytes remaining) is only the number
                of bytes remaining to be sent in the data stage of the
                transaction.  The setup stage of a control transaction is
                always exactly 8 bytes, but the count of the bytes in the
                setup stage is not monitored or returned by this request.















































                BIOS-LEVEL USB API 0.05            Page 153 of 168

       Large Call Completed
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Miscellaneous
         Return Type: Immediate

         Entry:
           I14RRequestType      = A1h (I14RRTLargeCallDone)
           I14RHostIndex        = Host Index Large Call is on (0-15)
           I14RRequestHandle    = Large Call Index (in Low Byte)
                                   (contents of DL register when original
                                    Large Call Notification was issued)
           I14RLargeCallRtnCode = Error Code word
                                   (0000h=TDStsOK or 8000h=TDStsLargeCallErr)

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: This request is how an interface owner signals the end of a
                large transaction back to the host driver.  A large
                transaction originally comes into the host driver via a call
                from another piece of software.  The host driver then issues
                a large call notification to the appropriate interface owner. 
                The large call notification includes a large call index,
                provided by the host driver to the interface owner in the DL
                register during the notification.  The purpose of the large
                call notification is to temporarily pass complete control of
                the large transaction over to the interface owner.  After the
                interface owner has completed processing the large call, it
                MUST issue this request back to the host driver indicating
                that the large call has been completed.  The interface owner
                must provide back to the host driver the original large call
                index (in the low byte of I14RRequestHandle), along with a
                success/failure indication (in the I14RLargeCallRtnCode
                word).  The host driver will then notify the original large
                transaction caller of the transaction status.

                There are several types of requests that are classified as
                large transactions, most of them related to hubs.  For
                example, in order to enable, disable, reset, suspend, resume,
                power on, power off, or power reset a device, it is required
                that a large transaction be issued to the owner of the hub
                that the device is attached to.



                BIOS-LEVEL USB API 0.05            Page 154 of 168

       Beep the Speaker
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Miscellaneous
         Return Type: Immediate

         Entry:
           I14RRequestType   = AFh (I14RRTBeepSpeaker)
           I14RHostIndex     = Host Index (0-15, 255 = Any Host)
           I14RBeepFrequency = Frequency to Beep with (Hertz) (20-20000)
           I14RTimeout       = Duration of Beep (deciseconds) (0-18000)

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: This request is provided for other USB-related background
                programs (like TSR's) to easily indicate error conditions by
                beeping the speaker.  By providing this feature in the host
                driver, each individual device/interface driver does not need
                to contain code required to beep the speaker.

                The value in I14RTimeout will be the approximate duration of
                the beep, not necessarily the precise duration.

                The host driver may not necessarily use the USB hardware to
                control the duration of the beep.

                This request generates sounds using the computer's internal
                speaker.  It does not generate sounds through the high-
                quality sound system installed on most modern computers.

                Whether the request is issued to an individual host or to any
                host, the speaker will only beep one time.  It does not beep
                once for each host driver that is installed.

                If the host driver detects that the internal speaker is
                already being used (by another program) when it tries to
                start beeping, the host driver will simply cancel the beep
                process without notification.

                If I14RBeepFrequency is 0, a "default" value of 1000 Hertz
                will be used.  If I14RTimeout is 0, a "default" value of 3
                deciseconds will be used.



                BIOS-LEVEL USB API 0.05            Page 155 of 168

                The maximum value allowed for I14RTimeout is 18000
                deciseconds (approximately 1/2 hour), though a beep will
                typically only last a few deciseconds.

                If this request is issued with I14RHostIndex = 255 (any
                host), the first host driver to receive the request will
                simply process the request as if it had been issued with that
                host driver's specific host index.  It will not "pass on" the
                request to other host driver(s).












































                BIOS-LEVEL USB API 0.05            Page 156 of 168

       A New Host Driver Has Been Installed
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       InterHost
         Return Type: Immediate

         Entry:
           I14RRequestType = E1h (I14RRTHostAdded)
           I14RHostIndex   = Host Index (0-15, 255 = All Hosts)
                               (existing Host Index(es))
           I14RConfigValue = New Host Index (0-15)

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: This request is issued by a new host driver during its
                initialization process if other host driver(s) were installed
                before it was.

                The new host driver must assign itself a unique host index,
                one which has not already been assigned to an existing host
                driver.  It can determine which indexes have already been
                assigned by issuing a "Get Host Hardware Information" request
                (page 44) with I14RHostIndex = 255 (all hosts).

                The new host driver must inform ALL existing host drivers of
                its presence.  If it does not issue this request with
                I14RHostIndex = 255 (all hosts), it must issue separate
                requests to each existing host driver individually.

                If this request is issued with I14RHostIndex = 255 (all
                hosts), the first existing host driver to receive the request
                will "pass on" the request to all existing host drivers
                individually.












                BIOS-LEVEL USB API 0.05            Page 157 of 168

       An Existing Host Driver Has Been Removed
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       InterHost
         Return Type: Immediate

         Entry:
           I14RRequestType = E2h (I14RRTHostDeleted)
           I14RHostIndex   = Host Index (0-15, 255 = All Hosts)
                               (existing Host Index(es))
           I14RConfigValue = Host Index being Removed (0-15)

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: This request is issued by a host driver during its shutdown
                process if other host driver(s) will still be installed after
                it is gone.

                If the host driver being removed is the last (only) host
                driver remaining, it cannot be uninstalled if there are
                remaining registered device 0 owners.  Any program that
                requires a host driver to be installed in order to keep from
                "blowing up" must register as a device 0 owner.

                The host driver being removed must inform ALL remaining host
                drivers of its removal.  If it does not issue this request
                with I14RHostIndex = 255 (all hosts), it must issue separate
                requests to each host driver individually.

                If this request is issued with I14RHostIndex = 255 (all
                hosts), the first host driver to receive the request will
                "pass on" the request to all host drivers individually.













                BIOS-LEVEL USB API 0.05            Page 158 of 168

       InterHost Register As Device 0 Owner
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       InterHost
         Return Type: Immediate

         Entry:
           I14RRequestType   = E3h (I14RRTRegDvc0Host)
           I14RHostIndex     = Host Index (0-15)
           I14RDeviceAddress = 0 (Newly Attached Devices)
           I14RVendorID      = Dvc Vendor ID (FFFFh or 0000h = Don't Care)
           I14RProductID     = Dvc Product ID (FFFFh or 0000h = Don't Care)
           I14RDvcClass      = Device Class of Device (FFh = Don't Care)
           I14RDvcSubClass   = Device SubClass of Device (FFh = Don't Care)
           I14RDvcProtocol   = Device Protocol of Device (FFh = Don't Care)
           I14RIntfClass     = Interface Class of Alternate Interface
                                 (FFh = Don't Care)
           I14RIntfSubClass  = Interface SubClass of Alternate Interface
                                 (FFh = Don't Care)
           I14RIntfProtocol  = Interface Protocol of Alternate Interface
                                 (FFh = Don't Care)
           I14RRequestHandle = Device 0 Owner Handle Number
                                 (Device 0 Ownership Table Index)
                                 (Assigned by the first Host Driver to
                                  receive the "Register As Device 0 (New
                                  Interface) Owner" Request
           I14RCallBackAddr  = Notification Call Back Address (CS:IP)
                                 (Device 0 Owner)
           I14RUserPktID     = Value to return in BX on Notifications

         Return:
           CF = Clear
           AX = BX = CX = DX = 0

         Owner Notifications:
           AX = 0001h (OwnerCallNewDvc)
           BX = I14RUserPktID of Device 0 Owner
           CL = Host Index (0-15)
           CH = Device Address of Newly Attached Device (2-127)
           DL = Interface Number that matching Alternate Interface is on
           DH = Matching Alternate Interface Number

             Notifies all registered device 0 owners whose search criteria
             match the characteristics of the newly attached device
             (I14RVendorID, I14RProductID, I14RDvcClass, I14RDvcSubClass,
             I14RDvcProtocol, I14RIntfClass, I14RIntfSubClass, and
             I14RIntfProtocol).






                BIOS-LEVEL USB API 0.05            Page 159 of 168

           AX = 0003h (OwnerCallDvc0Disc)
           BX = I14RUserPktID of Device 0 Owner
           CL = Host Index (0-15)
           CH = Device Address of Detached Device (2-127)
           DL = Interface Number that matching Alternate Interface is on
           DH = Matching Alternate Interface Number

             Notifies all registered device 0 owners whose search criteria
             match the characteristics of the detached device (I14RVendorID,
             I14RProductID, I14RDvcClass, I14RDvcSubClass, I14RDvcProtocol,
             I14RIntfClass, I14RIntfSubClass, and I14RIntfProtocol).

         Notes: This request is issued by a host driver as a result of
                receiving a "Register As Device 0 (New Interface) Owner"
                request (page 123) from another "outside" program.  The first
                host driver to receive the initial "outside" request will
                assign the device 0 owner handle number (0-based device 0
                ownership table index number), put the handle number in
                I14RRequestHandle field, and then "pass on" this request to
                all host drivers individually.  Each individual host driver
                must update its own device 0 ownership table appropriately as
                a result of this request.

                Each individual host driver must "translate" a 0000h in the
                I14RVendorID and/or I14RProductID fields to FFFFh before
                storing them in the device 0 ownership table.  FFFFh (not
                0000h) must be stored in the device 0 ownership table for
                "Don't Care" in the vendor ID and product ID fields, but the
                host driver that received the initial "Register As Device 0
                (New Interface) Owner" request is not required to perform the
                translation before passing on this request.

                Each individual host driver must maintain its own copy of the
                device 0 ownership table, and each individual table must be
                EXACTLY the same as all the others.  The exact format of the
                table is discussed under the description of the "Copy The New
                Device Ownership Table" request below (page 163).

                This request registers an "outside" program to be notified
                when an interface (device) is first attached to or detached
                from the bus.

                Depending on the total number of alternate interfaces a
                device has, exactly how the search criteria are defined, as
                well as other factors, a device 0 owner may be notified
                multiple times for a single device attachment/detachment.







                BIOS-LEVEL USB API 0.05            Page 160 of 168

                If one (or more) of the search criteria is "Don't Care"
                (FFFFh or 0000h in the vendor/product ID, or FFh in the
                device/interface class/subclass/protocol), it will ALWAYS
                "match" the corresponding field from the actual device.  It
                is not possible to specifically look for a 0000h or FFFFh in
                the actual vendor/product ID fields, nor is it possible to
                specifically look for an FFh (vendor-specific) value in the
                actual device/interface class/subclass/protocol fields.

                This request will match all alternate interfaces on a device,
                even if those alternate interfaces are not actually selected.










































                BIOS-LEVEL USB API 0.05            Page 161 of 168

       InterHost Unregister As Device 0 Owner
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       InterHost
         Return Type: Immediate

         Entry:
           I14RRequestType   = E4h (I14RRTUnRegDvc0Host)
           I14RHostIndex     = Host Index (0-15)
           I14RRequestHandle = Device 0 Owner Handle
                                 (Device 0 Ownership Table Index)

         Return:
           CF = Clear
           AX = BX = CX = DX = 0

         Notes: This request is issued by a host driver as a result of
                receiving an "Unregister As Device 0 (New Interface) Owner"
                request (page 127) from another "outside" program.  The first
                host driver to receive the outside request (with
                I14RRequestType = 65h = I14RRTUnRegIntfOwner, and
                I14RHostIndex = 255 = All Hosts) will "translate" the request
                into this request (with I14RRequestType = E4h =
                I14RRTRegDvc0Host), and then issue the request to each host
                driver individually (with a specific host index of 0-15).  
                Each individual host driver must update its own device 0
                ownership table appropriately as a result of this request.

                Each individual host driver must maintain its own copy of the
                device 0 ownership table, and each individual table must be
                EXACTLY the same as all the others.  The exact format of the
                table is discussed under the description of the "Copy New
                Device Notification Table" request below (page 163).

                The device 0 owner handle (the 0-based device 0 ownership
                table index) is the value that was returned in the CX
                register during the "Register as Device 0 (New Interface)
                Owner" request (page 123).















                BIOS-LEVEL USB API 0.05            Page 162 of 168

       Copy the New Device Ownership Table
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       InterHost
         Return Type: Immediate

         Entry:
           I14RRequestType = E5h (I14RRTCopyNDTable)
           I14RHostIndex   = Host Index (0-15, 255 = Any Host)
                               (existing Host Index(es))
           I14RDataAddress = Address to copy the Table to (Segment:Offset)
           I14RDataSize    = 2048 (Number of bytes in the Table)

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Notes: This request is issued by a new host driver during its
                initialization process if other host driver(s) were installed
                before it was.

                This request tells an existing host driver to create a copy
                of its new device ownership table at a specific memory
                address (I14RDataAddress).  This is how a new host driver
                being installed would obtain a copy of the existing table.

                I14RDataAddress must be in a segment:offset format.  It
                cannot be a 32-bit physical address.  The I14RFlagAddrIsPhys
                bit of the I14RFlags field is ignored.

                If this request is issued with I14RHostIndex = 255 (any
                host), the first existing host driver to receive the request
                will respond as if it had received the request with its own
                specific host index.  The new host driver can either issue
                the request with a specific or non-specific host index and
                get the same result.

                Each individual host driver must maintain its own copy of the
                new device ownership table, and each individual table must be
                EXACTLY the same as all the others.  After the table has been
                initialized with this request, all host drivers will be
                notified of updates to the table with "InterHost Register as
                Device 0 Owner" and "Unregister as Device 0 Owner" requests
                (pages 159 and 162, respectively).



                BIOS-LEVEL USB API 0.05            Page 163 of 168

                Here is the exact format of the new device ownership table
                (as an A86-compatible structure definition).  Any program
                accessing/copying the table must use this exact format.  A
                table entry is unused (empty) if the high word (segment
                portion) of NDCallBackAddr is 0, regardless of the contents
                of any other fields.  The device 0 owner handle (used by
                various types of requests) is the 0-based index number of the
                table entry (it will always be a number between 0 and 127,
                inclusive).

       NewDvcNotifyStruc STRUC ;Table of New Device Owners (to be notified
                               ;  when a new Device is attached)
         NDVendorID       DW ? ;Vendor ID          |When these are filled
         NDProductID      DW ? ;Product ID         |  in, the Call will
         NDDvcClass       DB ? ;Device Class       |  only be made if the
         NDDvcSubClass    DB ? ;Device SubClass    |  right kind of device
         NDDvcProtocol    DB ? ;Device Protocol    |  is attached (not
         NDIntfClass      DB ? ;Interface Class    |  just any device)
         NDIntfSubClass   DB ? ;Interface SubClass |-1 = "don't care"
         NDIntfProtocol   DB ? ;Interface Protocol |
         NDUserPktID      DW ? ;User Pkt ID to have in BX during the Call
         NDCallBackAddr   DD ? ;Address (CS:IP format) to call when the
                               ;  Device is attached/detached
                               ;0 in Segment here is an Empty Table Entry
        ENDS

       NDEntries EQU 128                        ;Number of Table Entries
       NDSize    EQU (TYPE NewDvcNotifyStruc)   ;Size of each Table Entry
       NDTable    DB (NDEntries*NDSize) DUP (0) ;The Table itself
























                BIOS-LEVEL USB API 0.05            Page 164 of 168

       Put Host In Debug Mode
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Internal
         Return Type: Large

         Entry:
           I14RRequestType  = FDh (I14RRTHostDebug)
           I14RHostIndex    = Host Index (0-15, 255 = All Hosts)
           I14RCallBackAddr = Large Return Address (CS:IP)
           I14RUserPktID    = Value to return in BX on Large Return

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Large Return (Success):
           ZF = Set
           AX = CX = DX = 0
           BX = I14RUserPktID of Requester

         Large Return (Error):
           ZF = Clear
           AX = 8000h (TDStsLargeCallErr)
           BX = I14RUserPktID of Requester
           CX = DX = 0

         Owner Notifications (Success):
           AX = 001Dh (OwnerCallHostDebug)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = DX = 0

             Notifies interface owners of all devices attached to the
             host(s), all device 0 owners, and the frame timing owner.

         Notes: This request puts the host(s) into debug mode.  This will
                stop the host(s) from generating timing on the bus(es), but
                allows for single-step requests to be issued which will cause
                the bus(es) to increment one frame at a time.  A "Host Run"
                request (page 48) should be issued to cause the host to begin
                running "normally" again.





                BIOS-LEVEL USB API 0.05            Page 165 of 168

                If this request is issued with I14RHostIndex = 255 (all
                hosts), the first host driver to receive the request will
                "pass on" the request to all host drivers individually.

                This request may be specific to UHCI hosts.  It is unknown at
                this time if hosts other than UHCI even have debug modes, and
                if they do, if they are functionally equivalent to the debug
                mode for UHCI hosts.













































                BIOS-LEVEL USB API 0.05            Page 166 of 168

       Single Step Host (Debug Mode)
       ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

         Class:       Internal
         Return Type: Large

         Entry:
           I14RRequestType  = FEh (I14RRTHostSingleStep)
           I14RHostIndex    = Host Index (0-15, 255 = All Hosts)
           I14RCallBackAddr = Large Return Address (CS:IP)
           I14RUserPktID    = Value to return in BX on Large Return

         Return (Success):
           CF = Clear
           AX = 0
           BX = CX = DX = FFFFh

         Return (Error):
           CF = Set
           AX = Error Code (see Error Code Table on page 35)
           BX = CX = DX = FFFFh

         Large Return (Success):
           ZF = Set
           AX = CX = DX = 0
           BX = I14RUserPktID of Requester

         Large Return (Error):
           ZF = Clear
           AX = 8000h (TDStsLargeCallErr)
           BX = I14RUserPktID of Requester
           CX = DX = 0

         Owner Notifications (Success):
           AX = 001Eh (OwnerCallHostSST)
           BX = I14RUserPktID of Owner
           CL = Host Index (0-15)
           CH = DX = 0

             Notifies interface owners of all devices attached to the
             host(s), all device 0 owners, and the frame timing owner.

         Notes: This request single-steps the host(s), after a "Put Host In
                Debug Mode" request (page 165) has been issued.  This will
                cause the bus(es) to increment the frame index by one.

                This request requires that the host be in debug mode before
                it is issued.  If the host is not in debug mode, the request
                will return with a large call error.




                BIOS-LEVEL USB API 0.05            Page 167 of 168

                If this request is issued with I14RHostIndex = 255 (all
                hosts), the first host driver to receive the request will
                "pass on" the request to all host drivers individually.

                This request may be specific to UHCI hosts.  It is unknown at
                this time if hosts other than UHCI even have debug modes, and
                if they do, if they are functionally equivalent to the debug
                mode for UHCI hosts.













































                BIOS-LEVEL USB API 0.05            Page 168 of 168