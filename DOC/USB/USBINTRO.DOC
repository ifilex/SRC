

                        DOS USB DRIVER PACKAGE INTRODUCTION
                        อออออออออออออออออออออออออออออออออออ

                                  Bret E Johnson
                                 January 30, 2010



                                 TABLE OF CONTENTS
                                 อออออออออออออออออ


     INTRODUCTION  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5

     COPYRIGHTED FREEWARE  . . . . . . . . . . . . . . . . . . . . . . . .  7

     USB PRIMER  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  8
        USB TERMS  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  8
        DEVICES & INTERFACES . . . . . . . . . . . . . . . . . . . . . . .  9
           Common Device . . . . . . . . . . . . . . . . . . . . . . . . .  9
           Physical Device . . . . . . . . . . . . . . . . . . . . . . . . 10
           Logical Device  . . . . . . . . . . . . . . . . . . . . . . . . 10
           Device/Interface  . . . . . . . . . . . . . . . . . . . . . . . 11
           Examples  . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
           Device/Interface Configuration  . . . . . . . . . . . . . . . . 13
           Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
        USB HOST CONTROLLERS & HUBS  . . . . . . . . . . . . . . . . . . . 15
        HARDWARE & SOFTWARE  . . . . . . . . . . . . . . . . . . . . . . . 15
        VENDOR-SPECIFIC DEFINITIONS  . . . . . . . . . . . . . . . . . . . 16
        HOST SOFTWARE  . . . . . . . . . . . . . . . . . . . . . . . . . . 17
        DEVICE INITIALIZATION & ENUMERATION  . . . . . . . . . . . . . . . 18
        DESCRIPTORS  . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
        DISABLING & SUSPENDING PHYSICAL DEVICES  . . . . . . . . . . . . . 21
        STARTING & STOPPING HOSTS  . . . . . . . . . . . . . . . . . . . . 24
        POWER  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
        UHCI, OHCI, & EHCI . . . . . . . . . . . . . . . . . . . . . . . . 26
        PCI BUS MASTERING  . . . . . . . . . . . . . . . . . . . . . . . . 28
        ISOCHRONOUS, INTERRUPT, CONTROL, & BULK TRANSACTIONS . . . . . . . 30
        PACKET SCHEDULING  . . . . . . . . . . . . . . . . . . . . . . . . 31
        BUS TIMING . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
        LEGACY SUPPORT . . . . . . . . . . . . . . . . . . . . . . . . . . 34
           What is Legacy Support? . . . . . . . . . . . . . . . . . . . . 34
           How is Legacy Support Implemented?  . . . . . . . . . . . . . . 36

     PROGRAM ARCHITECTURE  . . . . . . . . . . . . . . . . . . . . . . . . 39
        TSR vs. CONFIG.SYS . . . . . . . . . . . . . . . . . . . . . . . . 39
        BACKGROUND vs. FOREGROUND  . . . . . . . . . . . . . . . . . . . . 40
        MODULAR vs. MONOLITHIC . . . . . . . . . . . . . . . . . . . . . . 40
        PLUG-AND-PLAY vs. STATIC . . . . . . . . . . . . . . . . . . . . . 41
        PROTECTED MODE vs. REAL MODE . . . . . . . . . . . . . . . . . . . 41
        LEGACY EMULATION vs. NEW PROGRAM DEVELOPMENT . . . . . . . . . . . 42


               DOS USB DRIVER INTRODUCTION            Page 1 of 186

        THE DOS USB API  . . . . . . . . . . . . . . . . . . . . . . . . . 43
        DRIVER, SUPPORT, & TEST PROGRAMS . . . . . . . . . . . . . . . . . 44
        THE DOS PATH . . . . . . . . . . . . . . . . . . . . . . . . . . . 46

     GENERAL OPTION SWITCHES . . . . . . . . . . . . . . . . . . . . . . . 47
        ALIASES  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
        INSTALLATION INTO LOW MEMORY . . . . . . . . . . . . . . . . . . . 47
        UNINSTALL FROM MEMORY  . . . . . . . . . . . . . . . . . . . . . . 48
        "BAD" DEVICES  . . . . . . . . . . . . . . . . . . . . . . . . . . 48
        VIEWING DESCRIPTORS  . . . . . . . . . . . . . . . . . . . . . . . 50
        ENVIRONMENT VARIABLES & REDIRECTED INPUT . . . . . . . . . . . . . 51

     INDIVIDUAL PROGRAMS . . . . . . . . . . . . . . . . . . . . . . . . . 52
        USBUHCI & USBUHCIL . . . . . . . . . . . . . . . . . . . . . . . . 53
           PCI Search Index  . . . . . . . . . . . . . . . . . . . . . . . 54
           Memory Usage  . . . . . . . . . . . . . . . . . . . . . . . . . 55
           IRQ & I/O Resources . . . . . . . . . . . . . . . . . . . . . . 56
           Other Host Controller Drivers . . . . . . . . . . . . . . . . . 58
           Disabling the Companion EHCI Host Controller  . . . . . . . . . 59
           Debugging Program Installation  . . . . . . . . . . . . . . . . 61
           Postponing Device Enumeration . . . . . . . . . . . . . . . . . 63
           Bus Timing Manipulation . . . . . . . . . . . . . . . . . . . . 64
           Device & Host Manipulation  . . . . . . . . . . . . . . . . . . 64
             Enable  . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
             Disable   . . . . . . . . . . . . . . . . . . . . . . . . . . 66
             Suspend   . . . . . . . . . . . . . . . . . . . . . . . . . . 66
             Resume  . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
             Remote Wakeup   . . . . . . . . . . . . . . . . . . . . . . . 68
             Reset   . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
             Configuration Value   . . . . . . . . . . . . . . . . . . . . 69
             PowerOn, PowerOff, & PowerReset   . . . . . . . . . . . . . . 69
             Test Mode   . . . . . . . . . . . . . . . . . . . . . . . . . 71
           Resetting "Bad" Devices . . . . . . . . . . . . . . . . . . . . 71
           Debug Mode  . . . . . . . . . . . . . . . . . . . . . . . . . . 72
           Attached Devices  . . . . . . . . . . . . . . . . . . . . . . . 73
           New Device Notifications  . . . . . . . . . . . . . . . . . . . 74
           Host Controller Hardware Status . . . . . . . . . . . . . . . . 75
           Schedule Status . . . . . . . . . . . . . . . . . . . . . . . . 76
             Frame List (FL)   . . . . . . . . . . . . . . . . . . . . . . 76
             Transfer Descriptor (TD)  . . . . . . . . . . . . . . . . . . 77
           Descriptors . . . . . . . . . . . . . . . . . . . . . . . . . . 79
           Miscellaneous Notes . . . . . . . . . . . . . . . . . . . . . . 80
        USBHOSTS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
           Showing Host Controller Status  . . . . . . . . . . . . . . . . 82
           Disabling EHCI Host Controllers . . . . . . . . . . . . . . . . 83
        USBDEVIC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
        IRQ  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
        USBHUB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
        USBKEYB  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
           Typing Methods  . . . . . . . . . . . . . . . . . . . . . . . . 90
           Keyboard Mapping  . . . . . . . . . . . . . . . . . . . . . . . 93


               DOS USB DRIVER INTRODUCTION            Page 2 of 186

             Translating USB Key Codes into Scan Codes   . . . . . . . . . 94
             Translating USB System Codes into Scan Codes  . . . . . . . . 96
             Setting Up a Keyboard Map   . . . . . . . . . . . . . . . . . 97
             Miscellaneous Notes about Keyboard Mapping  . . . . . . . . . 99
           Processing Special Keys . . . . . . . . . . . . . . . . . . .  100
           Changing the Typeamatic Rate  . . . . . . . . . . . . . . . .  101
           Enabling & Disabling Keyboards  . . . . . . . . . . . . . . .  102
           Descriptors . . . . . . . . . . . . . . . . . . . . . . . . .  103
           Miscellaneous Notes . . . . . . . . . . . . . . . . . . . . .  104
        SCANTEST . . . . . . . . . . . . . . . . . . . . . . . . . . . .  105
        USBMOUSE . . . . . . . . . . . . . . . . . . . . . . . . . . . .  107
           DOS Mouse Drivers . . . . . . . . . . . . . . . . . . . . . .  107
           PS2 Mouse BIOS  . . . . . . . . . . . . . . . . . . . . . . .  109
           IntelliMouse Protocols  . . . . . . . . . . . . . . . . . . .  110
           PS2 Mouse Hardware Emulation  . . . . . . . . . . . . . . . .  111
             Hardware Emulation Methods  . . . . . . . . . . . . . . . .  113
           Enabling & Disabling Mice . . . . . . . . . . . . . . . . . .  114
           Exchanging Left & Right Buttons . . . . . . . . . . . . . . .  114
           Descriptors . . . . . . . . . . . . . . . . . . . . . . . . .  116
           Displaying Raw Mouse Data . . . . . . . . . . . . . . . . . .  116
           Controlling Mouse Sensitivity . . . . . . . . . . . . . . . .  117
           Resetting the PS2 Mouse . . . . . . . . . . . . . . . . . . .  119
           Miscellaneous Notes . . . . . . . . . . . . . . . . . . . . .  119
        PS2MTEST . . . . . . . . . . . . . . . . . . . . . . . . . . . .  121
        USBJSTIK . . . . . . . . . . . . . . . . . . . . . . . . . . . .  123
           Joystick Protocols  . . . . . . . . . . . . . . . . . . . . .  124
           Analog Joystick Entity Names  . . . . . . . . . . . . . . . .  125
           USB Joystick Control Names  . . . . . . . . . . . . . . . . .  127
           Joystick Controls Mapping . . . . . . . . . . . . . . . . . .  129
             Special Notes About Controls Mapping  . . . . . . . . . . .  131
           Analog <-> Digital Conversions  . . . . . . . . . . . . . . .  133
           Normalizing Axis Entities . . . . . . . . . . . . . . . . . .  134
           I/O Virtualization  . . . . . . . . . . . . . . . . . . . . .  135
           Descriptors . . . . . . . . . . . . . . . . . . . . . . . . .  136
           Displaying Raw Joystick Data  . . . . . . . . . . . . . . . .  137
           Miscellaneous Notes . . . . . . . . . . . . . . . . . . . . .  138
        THRUST . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  139
        USBDRIVE . . . . . . . . . . . . . . . . . . . . . . . . . . . .  141
           Devices, LUNs, and Drive Letters  . . . . . . . . . . . . . .  142
             Device/Interfaces (Devices)   . . . . . . . . . . . . . . .  143
             LUNs (Disks)  . . . . . . . . . . . . . . . . . . . . . . .  144
             Drive Letters (Drives)  . . . . . . . . . . . . . . . . . .  145
           Viewing USBDRIVE Status . . . . . . . . . . . . . . . . . . .  146
           Assigning Drive Letters . . . . . . . . . . . . . . . . . . .  147
             Current Directory Structure (CDS)   . . . . . . . . . . . .  147
             FAT32 Partitions  . . . . . . . . . . . . . . . . . . . . .  149
             Legacy Support for Disks  . . . . . . . . . . . . . . . . .  150
           Assigning Physical Disk Numbers . . . . . . . . . . . . . . .  151
           SCSI Inquiry Responses  . . . . . . . . . . . . . . . . . . .  152
           Partitioning & Formatting . . . . . . . . . . . . . . . . . .  152
           Low-Level Formatting  . . . . . . . . . . . . . . . . . . . .  153


               DOS USB DRIVER INTRODUCTION            Page 3 of 186

           Resetting Disks . . . . . . . . . . . . . . . . . . . . . . .  155
           Troubleshooting . . . . . . . . . . . . . . . . . . . . . . .  155
             Bad Devices   . . . . . . . . . . . . . . . . . . . . . . .  156
             Internal Buffers  . . . . . . . . . . . . . . . . . . . . .  156
             SCSI Error Codes  . . . . . . . . . . . . . . . . . . . . .  157
             Delaying Initialization   . . . . . . . . . . . . . . . . .  157
             Sector Transfer Size  . . . . . . . . . . . . . . . . . . .  158
             Using USBASPI   . . . . . . . . . . . . . . . . . . . . . .  160
             Sandisk U3 Software   . . . . . . . . . . . . . . . . . . .  160
             Security Software   . . . . . . . . . . . . . . . . . . . .  161
             Wear Leveling   . . . . . . . . . . . . . . . . . . . . . .  161
             Sector Size   . . . . . . . . . . . . . . . . . . . . . . .  162
           Miscellaneous Notes . . . . . . . . . . . . . . . . . . . . .  162
        DRIVES . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  164
        USBPRINT . . . . . . . . . . . . . . . . . . . . . . . . . . . .  165
           Printer BIOS  . . . . . . . . . . . . . . . . . . . . . . . .  167
           Reassigning LPT Ports . . . . . . . . . . . . . . . . . . . .  170
           Printer Device ID's . . . . . . . . . . . . . . . . . . . . .  170
           Resetting a Printer . . . . . . . . . . . . . . . . . . . . .  171
           Epson Printer Initialization  . . . . . . . . . . . . . . . .  171
           Copying Files to a Printer  . . . . . . . . . . . . . . . . .  172
           The CPU BOUND Bug . . . . . . . . . . . . . . . . . . . . . .  173
           Miscellaneous Notes . . . . . . . . . . . . . . . . . . . . .  174
        BOUNDTST . . . . . . . . . . . . . . . . . . . . . . . . . . . .  175
        INKLEVEL . . . . . . . . . . . . . . . . . . . . . . . . . . . .  176
        USBSUPT1 . . . . . . . . . . . . . . . . . . . . . . . . . . . .  178
        HIDSUPT1 . . . . . . . . . . . . . . . . . . . . . . . . . . . .  180
        UNI2ASCI . . . . . . . . . . . . . . . . . . . . . . . . . . . .  181
        VENDORID . . . . . . . . . . . . . . . . . . . . . . . . . . . .  184
























               DOS USB DRIVER INTRODUCTION            Page 4 of 186

                                   INTRODUCTION
                                   ออออออออออออ

     Not DPMI as such, but multi-taskers that cause problems.
     Removed Disable/Enable from USBPRINT (never there).


     This was intended to be a "short and sweet" document describing the
     usage of the DOS USB drivers and associated utilities created by Bret
     Johnson.  Though the intention was to be short, the reality is that it's
     not very short at all -- there are just too many details that need to be
     discussed.  These programs are still in a testing (alpha/beta) stage, so
     there may be errors, omissions, idiosynchrocies, and inconsistencies
     with them.

     None of the programs have official, complete documentation yet.  Final
     documents will be produced when they are ready to be officially
     released.

     One of the main purposes of this document is to give a brief description
     of each program, yet to include details on their major options, and on
     the interactions between the different programs.  This document should
     provide enough detail for someone with a technical DOS background to be
     able to install, test, and use the programs.  However, it will not
     discuss every option for each program.  It is assumed that the user has
     a basic understanding of how DOS command-line utilities work, and how to
     request basic help from a program by using the "/?" switch.

     Undoubtedly, this document will not answer every possible question or
     problem that will arise, so queries can be addressed to:

                   Bret Johnson
                   bretjohn@juno.com
                   http://bretjohnson.us
                   505-994-3023 (New Mexico, USA)

     The web site also has a Forum, which is probably the best place to ask
     about the programs:

                   http://bretjohnson.us/forum

     By posting questions there, other people can see what you're asking and
     suggest answers.  Inevitably, if one person has a question, there are
     many others with that same question.  This way, everyone can learn from
     everyone else.

     Another major purpose of this document is to introduce some of the
     concepts involved in the USB architecture, as well as the design
     architecture of the included USB programs.  USB architecture is
     EXTREMELY complicated, and some of that complexity needs to be explained
     before a user can understand why some of the programs are designed the


               DOS USB DRIVER INTRODUCTION            Page 5 of 186

     way they are, what some of the different terms mean, and how all of the
     pieces fit together.  It is intended that this document contains enough
     information so that the user will not need to pursue outside
     documentation to any great degree.

















































               DOS USB DRIVER INTRODUCTION            Page 6 of 186

                               COPYRIGHTED FREEWARE
                               ออออออออออออออออออออ

     The accompanying programs are authored by Bret Johnson with suggestions,
     programming, documentation, and testing help from Richard Bonner
     (http://www.chebucto.ns.ca/~ak621).

     This section contains the license for all of the enclosed programs.  I'm
     not going to inject a bunch of legal language in here that a smart
     lawyer can find a loophole in.  I'm writing down the intent of how I
     want the programs to be distributed and used in my own words, and hope
     that the intent is clear, no matter how the literal words can be twisted
     to mean different things (remember when President Bill Clinton, a
     lawyer, claimed he didn't understand the meaning of "is" during the
     Lewinsky hearings?).

     All of these programs, as well as their documentation and source code,
     are freely available to anyone who wants them.  You can use the programs
     without restriction, but you cannot directly or indirectly use the
     executable programs, documentation, or source code to create or
     distribute new programs that are not also freely available.  You also
     cannot distribute the programs, documentation, or source code and charge
     (even indirectly) for their distribution.  You can charge someone enough
     to cover your actual, direct costs for distribution (disks, shipping
     materials, postage, etc.), but cannot charge for "handling".  This also
     means that you cannot distribute the programs, documentation, or source
     code directly from a web site that charges a "registration fee" in an
     attempt to make a profit or to recover direct or indirect costs for
     maintaining the web site.

     If you distribute related or derivative programs, you must use
     essentially the same license.  You must provide and distribute the
     programs and documentation for free, and you must include the
     documentation with the program.  You must give credit where it is due,
     and must make the source code freely available to anyone who wants it.


     Perhaps a good test of whether your program is adhering to the license
     or not would be if you are willing to let me post the program,
     documentation, and source code on my web site, to be downloaded by
     anyone who wants it.  In fact, if you create any new related or
     ancillary DOS USB programs, I would like the opportunity to distribute
     them from my web site.  I won't guarantee that I will necessarily do it,
     but would like the opportunity.  Distribution from my web site
     (http://bretjohnson.us) is not required by the license.








               DOS USB DRIVER INTRODUCTION            Page 7 of 186

                                    USB PRIMER
                                    ออออออออออ

     The USB architecture is EXTREMELY complicated.  It's way too complicated
     to explain in detail -- trust me, you'd end up falling asleep many times
     before you got done.  This particular section of the document attempts
     to explain some basic concepts about USB.  The concepts and details
     described here are not intended to explain everything there is to know
     about USB (in fact, that would be impossible -- nobody knows everything
     there is to know about USB).  Rather, this section is simply intended to
     explain enough about the USB architecture that you can understand what
     the attached programs are doing (and not doing) and get a sense of how
     all the different pieces fit together.  If some major concept is still
     baffling to you or isn't explained clearly enough, write me (preferably
     using the Forum available at http://bretjohnson.us/forum) and somebody
     will try to explain it.


     USB TERMS
     ฤฤฤฤฤฤฤฤฤ

     As you are reading this document and using the various DOS USB Driver
     programs, you may see many different terms used from time to time and
     may not understand exactly what they mean.  Here is a non-comprehensive
     list of some terms you will run across at various times as you are
     "messing around" with USB.  If you already have a pretty good
     understanding of what these mean (in a USB context), you probably have a
     pretty good working knowledge of USB:

     Host
     Descriptor
     Report
     Hub
     Port
     Device
     Configuration
     Interface
     Alternate Interface
     End Point
     Class
     SubClass
     Protocol
     Packet
     Schedule
     Frame
     Queue
     Control
     Bulk
     Interrupt
     Isochronous
     Transaction


               DOS USB DRIVER INTRODUCTION            Page 8 of 186

     Legacy

     In this document, we do not provide a condensed Glossary of these terms
     and their definitions.  Rather, we will use many of these terms (and
     others) throughout this document, and define them in a specific context.
     Some of these terms have more than one definition, depending on the
     context.  In addition, some of these terms have a special meaning inside
     the USB architecture, which may not necessarily correspond to your
     common understanding of the term.

     This document is not intended to give a detailed description of USB, but
     rather just to give enough of an overview that you can successfully use
     the DOS USB Drivers.  If there's something that you come across that you
     don't understand, do some studying and ask some questions, and you may
     be amazed at what you find out.


     DEVICES & INTERFACES
     ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

     I'm going to start off by attempting to explain one of the most
     fundamental, and yet most confusing, concepts in USB: the concept of a
     "Device".  In the USB architecture, there are multiple definitions and
     concepts of what a "Device" is, and none of them necessarily correspond
     to what you would commonly think of as a "Device".  It is pretty
     critical that you can understand and differentiate between the multiple
     definitions of a "Device", or when something goes wrong you won't be
     able to troubleshoot and fix it.  You'll end up chasing your own tail
     because you'll get bogged down is USB complexities and won't understand
     what anything means.  Trust me, I've already struggled (and still
     struggle) through this, and would like you to avoid struggling
     unnecessarily.  Unfortunately, this is going to take quite a bit of
     explaining, so please bear with me for awhile.

        Common Device
        ฤฤฤฤฤฤฤฤฤฤฤฤฤ

        In this document, we will differentiate between four different
        definitions of "Device": Physical Device, Logical Device,
        Device/Interface, and Common Device.  Common Device, in this
        document, will correspond to what you as a computer user (not a USB
        programmer) would commonly think of as a "Device".  For example, a
        mouse, keyboard, camera, and multi-function printer (printer-scanner-
        copier-fax) are each considered a single Common Device.









               DOS USB DRIVER INTRODUCTION            Page 9 of 186

        Physical Device
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        USB is designed to allow many different kinds of "things" to plug
        into it (everything from mice to disk drives to video cameras to
        ethernet ports).  These different "things" do not have much in
        common, other than the fact that they need to send data back and
        forth to the computer.  In this document, we will call the "thing"
        that gets plugged into a single USB port (with a single USB cable or
        connector) a Physical Device.


        Logical Device
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        One of the marketing phrases that USB uses is that up to 127
        "Devices" can be attached to a single USB bus.  The "Device" that is
        being referred to here will be in this document called a Logical
        Device.  A Logical Device is the "thing" that gets assigned a USB
        Address by the software on the computer after a Physical Device gets
        plugged into the bus.  The assigned Address is a number between 1 and
        127, which is where the "magic" 127 number comes from.

        When you first plug a Physical Device into a USB port, the bus simply
        recognizes that a Physical Device got plugged in, but has no idea
        what kind of "Device" it is (not at first, anyway).  The software on
        the computer Enables the Physical Device, which in turn causes the
        Logical Device ("inside" the Physical Device) to assume Address 0.
        The Logical Device then goes through a lengthy and complicated
        initialization & enumeration process (discussed later in this
        document).  During the enumeration process, the Logical Device is
        assigned a "real" Address (a number between 1 and 127).

        Also as part of the enumeration process, the software on the computer
        "asks" the Logical Device exactly what kind of "Device" it is.  The
        Logical Device sends a bunch of data back to the computer, organized
        into sub-groups called Descriptors.  One of those Descriptors is
        called a Device Descriptor, which contains some basic information
        about the Logical Device (USB version compatibility, manufacturer &
        model number, etc.).  A Physical Device must have at least one Device
        Descriptor "inside" it.  If a Physical Device has more than one
        Device Descriptor "inside" it, USB refers to it as a Compound Device.
        Each Device Descriptor corresponds to a Logical Device, and is
        assigned a separate Address.









               DOS USB DRIVER INTRODUCTION            Page 10 of 186

        Device/Interface
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        Even after the Device Descriptor has been downloaded and an Address
        has been assigned to a Logical Device, the software on the computer
        still does not know what "kind" of Device it is.  USB uses a
        complicated, hierarchial classification system to describe the
        various "kinds" of Devices.

        The top tier of this hierarchy is called the "Device", and is defined
        by some of the data that is in the Device Descriptor (specifically,
        the Device Class, Device SubClass, and Device Protocol).  USB calling
        this hierarchy tier a "Device" is very unfortunate, however, because
        it has absolutely nothing to do with what anybody would normally call
        a "Device".  This is where most of the confusion regarding the term
        "Device" comes from.

        In addition to the Device Descriptor, there are also several other
        Descriptors downloaded during the enumeration process.  One of these
        is called an Interface Descriptor (and a Logical Device can have more
        than one Interface Descriptor).  The second tier of the hierarchy is
        called the "Interface", and is defined by some of the data that is in
        the Interface Descriptor (specifically, the Interface Class,
        Interface SubClass, and Interface Protocol).  A Logical Device
        (Device Descriptor) must also have at least one Interface (Interface
        Descriptor).  In some cases, the COMBINED six bytes of data from the
        Device Descriptor and Interface Descriptor (Device Class, Device
        SubClass, Device Protocol, Interface Class, Interface SubClass, and
        Interface Protocol) is enough to determine what "kind" of Device it
        is.  In this document, we will call this the Device/Interface, and is
        the closest thing there is to a Common Device (the "thing" that you
        would normally call a "Device").  The three bytes of data from the
        Device Descriptor alone is NEVER enough to describe what a "Device"
        is or does (in spite of the fact that it's called a Device
        Descriptor).

        Unfortunately, the story does not end there.  Sometimes, the
        combination of data in the Device Descriptor and Interface Descriptor
        still is not enough to define what "kind" of Device it is.  There are
        times when additional hierarchy tiers are needed before you know what
        a "Device" actually is and does.  As you might expect, these are
        defined with more Descriptors which must be downloaded from the
        Logical Device.  In this document, we will still refer to the "kind"
        of Device as the Device/Interface, even when it requires more than
        the Device tier and Interface tier to figure out what it is.








               DOS USB DRIVER INTRODUCTION            Page 11 of 186

        A common example of this is what USB calls Human Interface Devices or
        HID's (mice, keyboards, and joysticks are all "types" of HID's).
        Human Interface Devices have a Device Descriptor, but what's
        contained in the Device Descriptor essentially says, "This isn't a
        Device -- You need to look at the Interface Descriptor to figure out
        what this 'thing' is."  So, even though the word "Device" appears in
        the title "Human Interface Device", an HID is not considered to be a
        "Device" in any USB-defined sense of the word.

        Because there is nothing of substance in the Device Descriptor for an
        HID, you must look at the Interface Descriptor.  Well, with an HID,
        it turns out that the Interface Descriptor usually doesn't tell you
        anything you need to know, either.  For most HID's, an Interface
        Descriptor essentially says, "This Interface is a Human Interface
        Device."  Because that's pretty useless information, you must
        download yet another Descriptor, called an HID Report Descriptor
        (which is unique to the HID "class" of Interfaces).  In the HID
        Report Descriptor is where you finally learn that the "thing" is a
        joystick, credit card reader, telephone keypad, or one of the myriad
        of other things that USB generically classifies as HID's.  A joystick
        would be an example of a Device/Interface in this document.


        Examples
        ฤฤฤฤฤฤฤฤ

        Let's go into some specific examples of the different definitions of
        "Device".  I've seen a "thing" that is a combination keyboard and
        mouse in one unit.  This one Physical Device (a single USB cord gets
        plugged into a single USB port), one Logical Device (it gets assigned
        a single USB Address), and two Device/Interfaces (one each for the
        keyboard and the mouse).  Most people would consider a mouse and a
        keyboard to be two separate Common Devices, even though only one USB
        cord gets plugged into a USB port.

        I've also seen a "thing" that is a keyboard with extra USB ports on
        it, which can be used to plug other Physical Devices into.  The ports
        that Physical Devices plug into are associated with special
        Device/Interfaces called USB Hubs, which are described later in this
        document.  A keyboard with extra USB ports is a single Physical
        Device, two Logical Devices (the keyboard and the Hub are assigned
        different Addresses), and two different Device/Interfaces.  This
        would be considered one Common Device by most people.

        Although I've never actually seen a USB modem, based on what the USB
        specifications say, it would work like this.  A USB modem would be a
        single Physical Device, a single Logical Device, but it would have
        two Device/Interfaces -- on for the "data" and one for the "control"
        (e.g., the Hayes "AT" commands that you usually use to control a
        modem).  Of course, a modem is a single Common Device.



               DOS USB DRIVER INTRODUCTION            Page 12 of 186

        There are also Physical Devices like "reading lights" that plug into
        a port on the USB bus, but are not a "Device" in any kind of USB
        architecture (software) sense at all.  These Physical Devices simply
        "steal" power from the bus, but do not require any software to
        operate.  Such Physical Devices are not Logical Devices, nor are they
        Device/Interfaces.  Depending on your perspective, they may be
        considered a Common Device, or you may instead consider them to be
        more of an "accessory" or a "power leach" than a "Device".  As far as
        the USB architecture is concerned, such "Physical-only Devices" don't
        even exist, even though they use USB-provided resources (power).


        Device/Interface Configuration
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        Sometimes, a Physical Device can be two different "things", but can
        only be one of them at a time.  For example, you may have a camera
        that can either be a video camera or a still camera, but not both at
        the same time.  In the USB architecture, this could be set up as two
        different Configurations of the same "Device" (as defined in the
        "Device" part of Device/Interface).  As the "Device" part of the
        Device/Interface is being "set up", only one of the Configurations
        can be selected at a time.

        In addition, an Interface (as defined in the "Interface" part of
        Device/Interface) can have multiple "configurations", only one of
        which can be selected at a time.  In the USB architecture, these are
        called "Alternate Interfaces".  An example of this could be a video
        camera with different "resolutions" (number of pixels, number of
        colors, frames rates, etc).  As the "Interface" part of the
        Device/Interface is being "set up", only one of the Alternate
        Interfaces can be selected at a time.

        Note that not all Device/Interfaces have multiple "configurations",
        but some of them do.  Generally, "simpler" Device/Interfaces (mice,
        keyboards) do not, while more "complicated" Device/Interfaces
        (printers, cameras) do.
















               DOS USB DRIVER INTRODUCTION            Page 13 of 186

        Summary
        ฤฤฤฤฤฤฤ

        This was a long section, and I certainly hope you are not even more
        confused or bored than you were when you started (that was definitely
        my intent).  The main point I want you to take from this is that USB
        is EXTREMELY complicated and confusing, and that you must be VERY
        careful when the terms "Device" and "USB" are used at the same time.
        They can sometimes mean very different things depending on the
        audience and the context, and you must make sure that both sides
        understand what kind of "Device" is being referred to.  In this
        document, we will try to use the most appropriate term (Physical
        Device, Logical Device, Device/Interface, and Common Device) in the
        context, as defined here.  The terms do overlap to some degree, so
        there will be cases where the terms might be somewhat ambiguous
        (interchangeable).  Let me know if there's an instance where I don't
        appear to be using the correct term, and I will try to fix it or
        explain it.

        I want to also point out that most other USB Drivers and
        Documentation (DOS, Windows, etc.) try to "hide" all of these kinds
        of details from you (especially Windows).  That certainly makes
        things "easier" to use, at least when everything works like it's
        supposed to.  Unfortunately, in USB, almost nothing works like it's
        supposed to all the time.  When something doesn't work in Windows,
        the way you "fix" problems is to "reinstall or update the software,
        reboot, and see what happens".  That isn't really "fixing" anything
        at all.

        These DOS USB programs provide you a lot of detail, many times much
        more detail ("clutter") than really want to see.  This detail is
        provided to help you figure out how things work, especially when
        things aren't working like you think they're supposed to.  The detail
        is provided to help you figure out what's wrong, fix it, and move on
        to something productive.


















               DOS USB DRIVER INTRODUCTION            Page 14 of 186

     USB HOST CONTROLLERS & HUBS
     ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

     USB is designed as a host-centric (poll & response), tree-shaped Bus.
     There is a Host Controller at the top of the tree (and a computer can
     have more than one Host Controller).  Embedded with the Host Controller
     electronics is a "thing" called the Root Hub, which is what actually
     contains the ports that the Physical Devices plug into.  A Root Hub is a
     "logical entity", in the sense that it is physically inseparable from
     the Host Controller, but is treated as a different "entity" (performs
     entirely different functions) in the software.

     A Root Hub typically only contains a few physical ports.  If the Root
     Hub does not contain enough physical ports to support all of the
     Physical Devices that a user wants to plug in, the number of available
     ports can be expanded by plugging in a special Device/Interface called a
     USB Hub.  According to the USB specifications, there can be up to five
     "levels" of USB Hubs between a Physical Device and the Root Hub.

     In one sense, a USB Hub is simply another Device/Interface that can be
     attached to the Bus.  However, it is a very special Device/Interface,
     because it increases the port capacity of the entire bus.  There are
     some special communications that need to take place between a Host
     Controller and a USB Hub to manage these port expansions.
     Theoretically, there can be up to 127 Logical Devices attached to a
     particular Bus (the 127 number includes the USB Hubs), though in
     practice the number of useful Logical Devices is usually much smaller
     than that (largely due to the limited bandwidth of the Bus).


     HARDWARE & SOFTWARE
     ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

     For a USB Bus to actually be of benefit to anyone, there are two
     different aspects that must be addressed: hardware and software.  The
     hardware includes the PCI bus inside the computer that the Host
     Controller plugs into, the Host Controller itself, the embedded Root Hub
     and its physical ports, any Physical Devices that get plugged into the
     Bus (including USB Hubs), all associated cabling required to connect
     things together, and in some cases power cables, power supplies, or
     batteries to power the Physical Devices.

     It is not enough, however, to simply have the hardware.  USB also
     requires a large amount of software before it can do anything useful.
     For our purposes, we will define software to be the special software
     that is installed in memory on the computer.  All USB hardware actually
     has embedded software (technically, firmware), but in this document we
     will not usually differentiate between the hardware and its embedded
     firmware -- we will just call it the hardware.




               DOS USB DRIVER INTRODUCTION            Page 15 of 186

     USB is specifically designed to be very software-centric.  A Physical
     Device simply plugged into the Bus with no software will not even "turn
     on".  There is a complicated, software-driven initialization &
     enumeration process that takes place after a Physical Device is plugged
     into the bus.  This process actually takes place between the Host
     Controller Driver (software) and the firmware in the Physical Device,
     using the USB bus to transport the signals back and forth.  The entire
     enumeration process must be completed successfully before the Physical
     Device is even considered a "USB Device".

     After a successful enumeration process, the Physical Device will be
     "enabled", but still will not do anything useful.  There must then be
     some Device/Interface-specific software installed to recognize what the
     Device/Interface(s) actually are (Hub, Mouse, Keyboard, Printer, Disk
     Drive, Joystick, etc.) and perform functions with them that end up
     benefitting the computer user in some fashion.  In the more "advanced"
     Operating Systems (Linux/Mac, Windows, etc.), the Operating System may
     attempt to load appropriate software automatically after the Logical
     Devices have been enumerated.  In DOS, that is not the case.  The user
     is responsible for loading the appropriate DOS software drivers -- the
     Operating System cannot do it automatically.


     VENDOR-SPECIFIC DEFINITIONS
     ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

     USB makes an attempt to "classify" all Devices that get attached to a
     USB bus.  There are multiple levels of these classifications, with the
     top level of classification being the Device Class (one of the items
     contained in the Device Descriptor).  There are far too many types of
     "sub-classifications", and even too many ways of defining and
     enumerating the classifications, to go into here.  And, even if we
     detailed all of the classifications that are strictly defined with
     official USB standards documents (of which there are many), we still
     wouldn't have all of our bases covered.

     While USB is intended to be "standards-based", it is also intended to be
     "flexible".  Therefore, even if an official standard exists for how a
     particular "class" or "type" of Device/Interface should work, a
     Device/Interface doesn't necessarily need to follow the standard.  USB
     also allows a classification of "Vendor-Defined" to be used almost
     anywhere that a manufacturer sees fit.  As you might imagine, any
     Device/Interface that falls into the "Vendor-Defined" category requires
     a special "Vendor-Written" software Driver, since the Vendor is the only
     one who knows how the Device/Interface really works.  As it turns out,
     there are a LOT of USB Device/Interfaces that fall into this "Vendor-
     Defined" category, and require custom software Drivers to use them.
     Usually, the manufacturer of the Device/Interface is the one that needs
     to write the Driver, and you can have a lot of fun trying to talk them
     into even bothering to write a Driver for DOS.



               DOS USB DRIVER INTRODUCTION            Page 16 of 186

     All of the DOS Drivers written so far have been written for "generic"
     USB Device/Interfaces (Mice, Keyboards, Printers, etc.) that follow the
     USB standards.  Most "generic" Device/Interfaces should work with these
     generic Drivers, as long as the Device/Interface doesn't do anything too
     unusual.  Again, USB is flexible, so sometimes hardware manufacturers do
     strange things with their Device/Interfaces that a generic Driver does
     not understand.  Sometimes, the Driver can be "tweaked" to accommodate
     the almost-generic Device/Interface, and sometimes you're better off
     getting a different Device/Interface made by a different manufacturer
     that is truly "generic".

     In addition, the entire USB architecture is widely recognized as being
     "flaky".  In fact, when USB version 2 was being worked on (several years
     ago), Via Technologies (a large manufacturer of USB Host Controllers)
     tried to talk the industry out of it because of all the problems there
     were with USB version 1.  There are a lot of times when Physical Devices
     simply aren't recognized correctly when plugged in (even under Windows),
     with no apparent or legitimate reason why they shouldn't work.  I do not
     know if it's because the USB specifications are faulty, or the
     specifications are just fine and the manufacturers simply don't follow
     them.  I just know that USB doesn't work correctly all of the time, and
     anybody who has been around USB very much will tell you the same thing.


     HOST SOFTWARE
     ฤฤฤฤฤฤฤฤฤฤฤฤฤ

     The Host software is responsible for managing everything that happens on
     the bus.  This includes things like Physical Device connects &
     disconnects, assigning & maintaining Addresses, notifying other software
     (such as individual Device/Interface Drivers) of changes to the bus,
     data packet scheduling, etc.  The Host software literally contains a
     "map" of the entire bus: which Physical Devices are attached to which
     ports of which Hubs, what kinds of Device/Interfaces they are, and
     whether or not there is a software Driver currently "controlling" the
     individual Device/Interface.  Host software is quite complicated, and
     requires a significant amount of memory.
















               DOS USB DRIVER INTRODUCTION            Page 17 of 186

     As part of managing the bus, the Host software needs to "do" things to
     an individual Physical Device, Logical Device, or Device/Interface at
     various times (assign Addresses, Enable/Disable, Reset, Suspend/Resume,
     etc.).  For some of these things, the Host software "talks" (sends a
     data packet across the bus hardware) directly to the Logical Device (the
     firmware) it is trying to control.  An example of this is when the Host
     software assigns an Address to a Logical Device.  In some cases,
     however, the Host software does not interact directly with the Physical
     Device it is trying to control, but rather "talks" to the Hub software
     of the Hub that the Physical Device is plugged in to.  For example, to
     Enable or Disable a particular Physical Device, what the Host software
     actually does is Enable or Disable the port on the Hub that the Physical
     Device is attached to.  It doesn't directly tell the Physical Device
     "Enable or Disable yourself".  Similarly, to Reset a Physical Device,
     the Host software tells the appropriate Hub to send a special Reset
     Signal out of the port that the Physical Device is attached to.

     When the Host software wants to send a data packet to a particular
     Logical Device, it essentially sends a "broadcast" packet that goes out
     over the bus hardware.  All Logical Devices attached to the bus will see
     the data packet.  However, part of the data in the header of the packet
     is the address of the Logical Device that the packet is intended for,
     and only the Logical Device with the correct address is allowed to
     respond to the packet.  Unlike an ethernet bus, there is no "broadcast
     address" that every Logical Device on the bus will respond to -- each
     data packet is intended for only one specific, unique Logical Device.


     DEVICE INITIALIZATION & ENUMERATION
     ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

     When a Physical Device is first attached to the bus (plugged into a port
     on one of the Hubs), the Host software is notified that a Physical
     Device has been attached.  However, the Physical Device is not "enabled"
     in any fashion whatsoever, and will not actually do anything yet.  The
     Physical Device must wait for the Host software to initialize and
     enumerate it.

     The Host software Resets and Enables the Physical Device, at which time
     the Logical Device automatically assumes Address 0.  The Host software
     will download several Descriptors from the Logical Device, to determine
     exactly what kind of Device/Interface it is and configure it
     appropriately.  During the enumeration process, the Host software will
     assign the Logical Device a "real" Address (something other than 0).
     After the enumeration process is complete, the Host software will allow
     an appropriate software Driver to begin to control the Device/Interface
     and make it useful.






               DOS USB DRIVER INTRODUCTION            Page 18 of 186

     Each Logical Device on the bus must have a unique address, so that the
     Host software knows exactly which Logical Device it is talking to.
     Because of this, it is only possible to enumerate one Logical Device at
     a time (only one Logical Device at a time can respond to Address 0).  As
     noted before, USB Devices are not always very reliable, and may fail
     during the complicated enumeration process (for any number of reasons).
     The Host software will try multiple times to enumerate a Logical Device
     that is not responding correctly, in hopes that it may work better the
     second or third time than it did the first.  An unreliable Logical
     Device can take several seconds (or even tens of seconds) to go through
     the entire enumeration process multiple times.  Unfortunately, some
     Logical Devices still fail to respond even after several attempts, and
     the Host software will finally give up and declare a Logical Device to
     be "bad".

     The Host software must remember that a particular Logical Device is
     "bad", so that it will not try to enumerate it again.  In these DOS
     Drivers, the Host software does this by assigning a "fake" Address to
     the Logical Device.  That is, the Host software keeps track of the
     Physical Device much as if it were a valid Logical Device, including
     storing an Address associated with the Logical Device.  However, the
     Host software internally flags the Logical Device as "bad", and the
     Logical Device itself is actually Disabled and does not know anything
     about the fake Address.  Among other things, the fake Address gives you
     (the user) a way to tell the Host software to try and enumerate the
     Logical Device again (you do this by telling the Host software to Reset
     the Logical Device, using the fake Address).  Some Logical Devices will
     eventually enumerate properly if you Reset them enough times, and some
     will never work no matter how many times you do it.  Such is the nature
     of USB.

     While a particular Logical Device is in the enumeration process, all
     other Logical Devices which are waiting to be enumerated must simply
     continue to wait until the first one is finished.  If you have several
     Logical Devices attached to a bus, it can take a long time (many
     seconds) to enumerate all of them, even if they all work properly and
     enumerate correctly the first time.  If you have any unreliable Physical
     Devices, though, this takes even longer and can seem to drag on into
     eternity.  If you have a Physical Device that turns out to be
     unreliable, and you have other Physical Devices that work just fine, you
     should try to arrange them on the Hub ports so that the unreliable
     Physical Device gets enumerated last rather than first.  That way, you
     can begin to use the reliable Physical Devices much sooner.










               DOS USB DRIVER INTRODUCTION            Page 19 of 186

     In these DOS USB Drivers, Address 1 is assigned to the Root Hub.
     Technically, the Root Hub does not need to be assigned an Address at all
     (at least according to the USB specifications), but assigning it an
     Address makes management of the bus much more convenient.  To you (the
     user) the Root Hub appears and reacts in the software much like any
     other Hub Device/Interface, and you don't need to refer to it in some
     special way.  In the DOS USB Drivers, therefore, all "real" Logical
     Devices will be assigned Addresses between 2 and 127.  Address 1 always
     refers to the Root Hub.

     Some Physical Devices will work correctly (enumerate properly) in MS
     Windows (or some other Operating System), when the exact same hardware
     setup doesn't work with these DOS USB Drivers.  There are also times
     when something works in DOS more reliably than it does in Windows.  To
     be frank, I have no idea why this happens.  However, I can tell you that
     the Windows software is technically not USB-compliant (it doesn't do
     everything the way the USB specifications say it's supposed to).  Just
     because a Physical Device works in Windows doesn't necessarily mean it's
     truly USB-compliant, in spite of what Microsoft (or the USB
     organization) might say or believe.


     DESCRIPTORS
     ฤฤฤฤฤฤฤฤฤฤฤ

     Embedded in the firmware of every USB Device is a set of data divided
     into Descriptors.  As the name implies, the intent of a Descriptor is to
     "describe" to the software on the computer something it needs to know
     about the Device/Interface.

     Descriptors can be divided into two different types: General and
     Specific.  General Descriptors are the ones that the Host Driver
     software downloads and uses to initialize & enumerate the Logical
     Device, and describe things like power requirements, manufacturer &
     model information, and general Device Classification.  General
     Descriptors have specific names (Device Descriptor, Configuration
     Descriptor, String Descriptor, Interface Descriptor, Endpoint
     Descriptor, etc.).  ALL Logical Devices have General Descriptors.  These
     DOS USB Drivers have options that allow you to view the Descriptors for
     specific Device/Interfaces if you have an interest in that.













               DOS USB DRIVER INTRODUCTION            Page 20 of 186

     In addition to the General Descriptors that ALL Physical Devices must
     have, most Device/Interfaces also contain Specific Descriptors.  The
     most common of these are called Class-Specific Descriptors.  For
     example, Device/Interfaces that declare themselves to be in the Printer
     Class will have Printer-Class-Specific Descriptors, in a format as
     defined by the official USB Printer Class Specifications.  Printer-
     Class-Specific Descriptors will contain details about things that are
     unique to Printers, and that would make absolutely no sense if you were
     trying to describe some other type of Device/Interface (say, a
     microphone or a mouse).  The Printer Device/Interface Driver will
     download the Printer-Class-Specific Descriptors in order to effectively
     manage the Printer and make it useful (to allow it to print things).

     In addition to the Class-Specific Descriptors, a Device/Interface may
     also contain other Specific Descriptors.  These are usually Vendor-
     Specific or Model-Specific Descriptors, and they do not have any kind of
     "standard" format.  Rather, they are in a proprietary format that is
     unique to the Vendor or Model of a particular Device/Interface.  In such
     cases, it is usually not possible to create a Driver for the
     Device/Interface unless the vendor publishes the details about the
     Descriptor, which they rarely do.

     Because a Device/Interface Driver needs to know more specific
     information about a Device/Interface than the Host software does, it
     must interact with the Device/Interface at an extended level (download
     additional Descriptors, set special configuration items, etc.).
     Therefore, even if a Logical Device is successfully initialized and
     enumerated by the Host software, it does not necessarily mean that it
     can be successfully controlled by a Device/Interface Driver.  You must
     always remember in the back of your mind that USB is "flaky" and
     unreliable, and things that should work sometimes don't, and there is
     not always a logical reason for it.


     DISABLING & SUSPENDING PHYSICAL DEVICES
     ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

     There are several special "states" that a Physical Device can be in.
     These states are not entered by "talking" directly to the Physical
     Device, but rather are entered by "talking" to the Hub that the Physical
     Device is attached to (which may be the Root Hub/Host Controller).  The
     Hub responds to the request by generating the appropriate special signal
     on the designated port.

        Enabled:
           The Physical Device is "turned on", but is not necessarily
           Configured or Enumerated.  If Enabled but not Configured, a
           Physical Device cannot draw more than 500 mW (100 mA) of power
           from the bus.




               DOS USB DRIVER INTRODUCTION            Page 21 of 186

        Disabled:
           The Physical Device is "turned off", and is not allowed to respond
           to any commands or data that may be on the bus.  It cannot draw
           more than 500 mW (100 mA) of power from the bus.  From a Disabled
           state, a Physical Device must be Reset in order to start running
           "normally" again.  Enabling a Disabled Physical Device is not
           sufficient to begin normal operation.

           If the Disabled Physical Device is a Hub, all Physical Devices
           downstream of the Hub are also Disabled.

        Suspended:
           The Physical Device has been Enabled and Configured, but is not
           allowed to draw more than 2.5 mW (0.5 mA) from the Bus.  The
           Physical Device must remain in this low-power state until it is
           told to Resume (usually with a Resume signal).  Suspending a
           Physical Device is generally the result of some sort of "power-
           saving" mode that the computer has entered.

           If the Suspended Physical Device is a Hub, all Physical Devices
           downstream of the Hub are also Suspended.

        Resuming:
           Once a Physical Device has been Suspended, the normal way of "un-
           Suspending" it is to issue a Resume signal.  However, a Physical
           Device will "un-Suspend" as a result of any special signal on the
           bus, including a Reset.

           Some Device/Interfaces, such as Mice, Keyboards, and Hubs also
           have a capability called "Remote Wakeup".  If Remote Wakeup is
           supported and enabled in a Device/Interface, and the Physical
           Device is currently Suspended, the Device/Interface will generate
           a "Wakeup" signal back towards the Root Hub under certain
           circumstances (such as if the mouse is moved, a key on the
           keyboard is pressed, or a Physical Device is plugged or unplugged
           from the Hub).  The Physical Device will automatically Resume
           itself, and the Wakeup signal will be recognized by the
           appropriate software Driver and Resume all other Suspended
           Physical Devices.  These DOS USB Drivers, by default, always
           enable Remote Wakeup in Device/Interfaces that support it.

           If the Resuming Physical Device is a Hub, all Physical Devices
           downstream of the Hub are also Resumed.










               DOS USB DRIVER INTRODUCTION            Page 22 of 186

        Resetting:
           A Reset is the software equivalent of physically unplugging and
           then re-plugging a Physical Device into a Hub port.  It will cause
           the Physical Device to be un-configured and Disabled.  If the
           Driver architecture supports plug-and-play, the Physical Device
           will automatically go through the entire initialization and
           enumeration process again.

           If the Physical Device being Reset is a Hub, all Physical Devices
           downstream of the Hub will be Disabled.  If the architecture of
           the Drivers supports plug-and-play, the downstream Physical
           Devices will automatically be re-initialized and re-enumerated
           after the Hub.  If the architecture does not support plug-and-
           play, the downstream Physical Devices will remain Disabled.

        Power On & Power Off:
           Depending on the type of Hub hardware installed, it is sometimes
           possible to control (turn on or off) the bus power to a particular
           Physical Device.  However, if the Physical Device is self-powered,
           it should continue to work whether bus power is provided or not.
           If bus power is turned off to a bus-powered Physical Device,
           however, it will cease to function (much as if you had physically
           unplugged it).

           UHCI Host Controllers (Root Hubs) do not provide any means at all
           to control the power -- the power is always on, and there is no
           way to turn it off.  USB Hubs ("remote" Hubs) can be manufactured
           either with per-port-power-switching or global-power-switching.
           With per-port-power-switching, the power to an individual port
           (Physical Device) can be controlled independently of the other
           ports.  With global-power-switching, the downstream ports are
           "tied together" from a power perspective -- they either all have
           power or they all do not.  It is therefore not possible to control
           the power to an individual port (Physical Device) without
           potentially affecting several other Physical Devices at the same
           time.

           It is usually best to avoid the powering on and off of Physical
           Devices, because the end results may not always be what you
           expect.













               DOS USB DRIVER INTRODUCTION            Page 23 of 186

     STARTING & STOPPING HOSTS
     ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

     Much like the different "states" that an individual Physical Device can
     be in (discussed in the previous section, "DISABLING & SUSPENDING
     PHYSICAL DEVICES"), a Host Controller (and its integral Root Hub) can
     also be in different "states".

        Running:
           This is the "normal" state for a Host Controller.  It is
           generating frames, accessing the Schedule in memory, sending data
           packets across the bus, etc.

        Stopped:
           When Stopped, the Host Controller is essentially "paused".  It is
           not sending any data at all down the bus, and frames are no longer
           being generated.  If a "Run" command is received, the Host
           Controller will begin processing things (such as the Schedule) in
           the same place it was just before it was Stopped (paused).

        Suspended:
           This is the same thing as a Suspend to an individual Physical
           Device as discussed in the previous section, but is generated by
           the Root Hub.  When it is sent to a specific Physical Device, it
           is called a "Selective Suspend".  When sent to all Physical
           Devices via the Root Hub, it is called a "Global Suspend".

        Resuming:
           This is the same thing as a Resume to an individual Physical
           Device as discussed in the previous section, but is generated by
           the Root Hub.  When it is sent to a specific Physical Device, it
           is called a "Selective Resume".  When sent to all Physical Devices
           via the Root Hub, it is called a "Global Resume".

        Resetting:
           Upon receiving a Reset command, the Host Controller will disable
           and disconnect all downstream Physical Devices (via the Root Hub),
           and then "reboot" itself.  This will reset internal registers and
           parameters to their default values, and start the Host Controller
           running much like it was when the computer was first turned on.
           Any Physical Devices attached to the bus will be required to go
           through the entire initialization and enumeration process again.

        Power On & Power Off:
           This is the same thing as the Power On and Power Off discussed in
           the previous section, but is generated by the Root Hub.  This is
           not supported by the Root Hubs associated with UHCI Host
           Controllers.





               DOS USB DRIVER INTRODUCTION            Page 24 of 186

        Debug Mode:
           This is a special mode of the Host Controller that allows hardware
           and software manufacturers to debug (troubleshoot) things as they
           are being developed.  Exactly what "Debug Mode" does depends on
           the hardware specification being used; i.e., UHCI, OHCI, and EHCI
           all have different interpretations and implementations of Debug
           Mode.

           In UHCI Host Controllers (the only ones currently supported by the
           DOS USB Drivers), Debug Mode Stops (pauses) the Host Controller as
           defined a few paragraphs up above under "Stopped".  The Host
           Controller can then be told to Single-Step, where it will generate
           a single frame across the bus, and then Stop (pause) again.  The
           single frame will do everything a frame running in "normal" mode
           would do (read the schedule, generate and send packets down the
           bus, generate IRQ's, etc.).  In UHCI Host Controllers, Debug Mode
           works very much like the Debug/Single-Step operation in the CPU
           familiar to all programmers.


     POWER
     ฤฤฤฤฤ

     Built into the USB architecture (hardware & software) is the concept of
     power management.  Unfortunately, there are several flaws in the actual
     implementation that prevent it from being very useful.

     The cables used to connect a downstream Physical Device to its upstream
     Hub (either a Root Hub or a USB Hub) contain four wires.  Two of the
     wires are the actual USB communications bus, which allow two-way
     communication to take place between the Physical Device and the Host
     Controller.  The other two wires contain 5 VDC power generated by the
     upstream Hub, which may be used by the downstream Physical Device to
     power itself.  If the Physical Device uses the power generated by the
     upstream Hub to power itself, it is called a bus-powered Physical
     Device.  If it uses an external power source of some sort (usually, a
     power cord or transformer that plugs into an AC outlet on the wall), it
     is called a self-powered Physical Device.

     Hubs themselves are simply another type of Device/Interface, and can be
     bus- or self-powered.  A self-powered Hub (including Root Hubs) can
     deliver up to 500 mA (2.5 W) of current on each of its downstream ports.
     A bus-powered Hub draws the power to operate itself from its upstream
     Hub, and then also uses whatever available power is left over from the
     upstream Hub to power any bus-powered downstream Physical Devices that
     may be attached to it.  During the enumeration process, one of the
     things that a Physical Device "tells" the Host software is whether it is
     self-powered or bus-powered, and if it is bus-powered, how much power it
     uses (in amperes).




               DOS USB DRIVER INTRODUCTION            Page 25 of 186

     Theoretically, the Host software can use this information to determine
     when the addition of a downstream Physical Device will overload the
     power supply of its upstream Hub, and not even bother to enumerate the
     Logical Device.  There a couple of problems with this approach, the main
     one being that some Physical Devices lie about their power requirements.
     I have personally tested a few dozen different Physical Devices, and at
     least two of them claim (in their Descriptors) they are self-powered
     when I know for a fact that they are bus-powered.  In addition, there is
     also a concept in USB known as a "Unit of Power", which is equal to 500
     mW (100 mA).  Many Physical Devices report their power requirements in
     Units of Power (multiples of 100 mA), instead of reporting their actual
     power requirements (something less than 100 mA).  There are also
     Physical Devices (such as "reading lights") that simply "steal" power
     from the bus, and do not report their power draw from the bus in any
     manner whatsoever.  The bottom line on all of this is that you really
     can't believe what any particular Physical Device tells you about its
     power requirements.  Some Physical Devices tell the truth, some don't,
     and you don't know which are which.

     Because the information received from the Physical Devices about their
     power requirements cannot be trusted, it is impossible to correctly
     manage the power distribution on the bus through software.  Therefore,
     in these DOS USB Drivers, we do not even attempt to manage the power.
     Instead (and unfortunately), the software will provide the information
     about declared power requirements to the user when requested, but the
     actual management and resolution of power-related problems are left to
     the discretion of the user.  It is simply impossible to do it in a
     reliable, efficient, trustworthy manner using software.


     UHCI, OHCI, & EHCI
     ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

     The following chart shows the progression of the USB standards that have
     occurred over the years.  The main intent of each new major revision
     number has been to increase speed.  As of the writing of this document
     (July, 2009), Wireless USB (technically, Certified Wireless USB) is
     still in its infancy, and there are only a few real Wireless Logical
     Devices available.  There are no general-purpose Wireless drivers for MS
     Windows (or any other Operating System) yet, so all of the Wireless
     Logical Devices currently available use proprietary (vendor-provided)
     Drivers.  The official USB 3.0 standard was supposed to be released last
     year (2008), with no real USB 3.0 Physical Devices expected to be
     available until around 2010.









               DOS USB DRIVER INTRODUCTION            Page 26 of 186

                Host
       USB      Controller        Speed        Speed
       Version  Interface         Designation  Mbps
       ฤฤฤฤฤฤฤ  ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ  ฤฤฤฤฤฤฤฤฤฤฤ  ฤฤฤฤฤฤฤฤฤ
       1.0/1.1  Open & Universal  Low          1.5
                                  Full         12
       2.0      Enhanced          High         480
       2.5      Wireless          Wireless     480 (Max)
       3.0      Extensible        Super        4800

     The main purpose of this section is to talk about the Host Controller
     Interfaces (HCI's - the "protocols" used to manage the Controllers), so
     we won't go into a lot of other details about the different USB
     versions.  There is plenty of information available on the internet
     about that you can look up if you're so inclined.  The one thing I will
     point out, however, is that the different standards are all backward
     compatible (except for Wireless USB, which is an oddball).  What
     "backward compatible" means in the USB sense is that a USB 1.x-
     compatible Physical Device can be plugged into a 2.0- or 3.0-compatible
     Hub, and will work (albeit at a lower speed than the faster Hub is
     capable of).  It also means that a 2.0- or 3.0-compatible Physical
     Device can be plugged into a 1.x-compatible Hub and it will also work,
     although the Device/Interface will not transfer data as fast as it would
     if it were plugged into a newer version of Hub.

     The different Host Controller Interfaces (HCI's) have acronyms based on
     the first or second letter of their description.  For instance,
     Universal Host Controller Interface = UHCI.  So, there are currently 5
     different ones (UHCI, OHCI, EHCI, WHCI, and XHCI).

     Embedded in the USB Host Controller architecture is the concept of
     "companion controllers".  As the above chart indicates, a Host
     Controller that is capable of USB 2.0 speeds will have an EHCI-
     compatible controller.  However, the only Physical Devices that the EHCI
     controller (and software) manages are the ones that are actually
     operating at high-speed (480 Mbps).  A Physical Device that is not
     capable of high-speed operation, or is attached downstream of a Hub that
     is not capable of high-speed operation, or does not have a high-speed
     compatible software Driver installed, will not operate at high-speed,
     and the EHCI controller will not manage it.  Instead, the EHCI
     controller "transfers" control of the Physical Device to the appropriate
     full-speed/low-speed companion controller (which uses the OHCI or UHCI
     protocol).  The high-speed EHCI controller and its associated low-speed
     companion controller(s) (UHCI or OHCI) are built into the same chip set.
     So, if you have an EHCI (USB 2.0/high-speed) controller, you will also
     have at least one OHCI or UHCI (USB 1.x/low-speed/full-speed) controller
     -- you don't need to buy them separately.






               DOS USB DRIVER INTRODUCTION            Page 27 of 186

     Currently, these DOS USB Drivers only support one type of Host
     Interface: UHCI.  There are plans to update the Drivers to include the
     later standards (at least OHCI & EHCI), though that will not happen any
     time in the near future (don't try to hold your breath until then).  As
     far as I know, the only manufacturers who make UHCI-compatible
     controllers are Intel and Via Technologies (Via).  All the other
     manufacturers make OHCI-compatible controllers.

     If you're like most people, and have absolutely no idea what kind of USB
     controllers you have, the enclosed USBHOSTS program will help you find
     out.  If yours aren't UHCI (made by Intel or Via), you won't be able to
     use these DOS USB Drivers as they currently stand.  However, if you have
     an extra PCI slot available on your computer, you can purchase a USB
     Host Controller card that you can plug into the PCI slot.  Of course,
     you must you must make certain that it is UHCI-compatible.  You can
     either look at the specifications for the card (make sure it says "UHCI"
     or "Universal", and not "OHCI" or "Open").  You can also look at the
     name that's stenciled on the main USB chip that's on the card, and make
     sure it says "Via" or "Intel".


     PCI BUS MASTERING
     ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

     All USB Host Controllers manufactured today are attached to the computer
     through the PCI (Peripheral Component Interconnect) Bus.  When data is
     being transferred from a Device/Interface into a program (such as a
     software Driver) to be used, the data first traverses the Bus from the
     Physical Device to the Host Controller.  The Host Controller then puts
     the data in the computer's memory (Random Access Memory or RAM).  The
     program (Device/Interface Driver) that needs the data then looks in RAM
     to see what data was transferred by the Device/Interface.  In essence,
     the RAM acts as a "middle man" between the world of the program
     (executing code on the CPU) and world of the USB Device/Interface (which
     understands the USB bus, but doesn't know anything about computer RAM).

     A problem arises because the CPU (where the program is running) speaks a
     different "language" than the PCI bus (where the Physical Device is
     attached) when it comes to RAM.  In the CPU world, there are different
     "kinds" of memory (Conventional/Lower, Upper, High, Expanded, Extended,
     Virtual, Paged, etc.), different addressing schemes (Segment:Offset,
     Linear, etc.), and different modes of CPU operation (Real Mode,
     Protected Mode, "Unreal" Mode, etc.).  In the CPU world, there can be
     many different ways to talk about (address) the same "chunk" of memory,
     depending on the situation.








               DOS USB DRIVER INTRODUCTION            Page 28 of 186

     The PCI bus uses a process called Bus Mastering to access RAM, which
     does not use the CPU.  The ONLY type of memory address that a PCI
     Controller understands is a Physical Address, which is something you
     normally never see in the CPU world.  As you might imagine, there must
     be a translation that occurs between the CPU language and the PCI
     language to make sure that the same "chunk" of memory is being used by
     both sides.  In these DOS USB Drivers, the Host Controller Driver
     (software) acts as the memory address translator.

     As it turns out, translating memory addresses in a DOS program is very
     easy in some situations, but virtually impossible in other situations.
     In these DOS USB Drivers, there are two different environments where the
     address translation works correctly.  The first environment is when the
     CPU is running in Real Mode.  This happens if you are using "basic" DOS,
     with no memory manager (like EMM386.EXE) installed.  Of course, using
     EMM386 offers many advantages (such as providing access to Upper Memory
     & Extended Memory), so computers rarely run in Real Mode.

     The other environment where the DOS USB Drivers can correctly translate
     memory addresses is when the computer is in Protected Mode with a VCPI-
     compliant (Virtual Control Program Interface) memory manager (like
     EMM386.EXE).  If you use Microsoft's EMM386.EXE program (loaded via your
     CONFIG.SYS file), you must make sure that you do NOT use the NOVCPI
     option, because that will disable the VCPI memory manager that these DOS
     USB Drivers need to translate memory addresses.  Also, unless you
     actually need Expanded Memory for some particular reason, I suggest that
     you DO use either the NOEMS or FRAME=NONE option to disable the Expanded
     Memory Page Frame.  Most modern DOS programs, if they require a large
     amount of memory, can use either Expanded Memory (EMS) or Extended
     Memory (XMS) to access the extra memory.  Extended Memory does not need
     a Page Frame the way Expanded Memory does, and consequently does not
     "steal" memory that other programs could use.

     It is NOT possible for the DOS USB Drivers to translate memory addresses
     in a DPMI (DOS Protected Mode Interface) environment, such as when you
     are running underneath Microsoft Windows.  Depending on exactly when a
     DOS USB Driver gets loaded into memory compared to when the DPMI
     environment starts, however, at least some of the DOS Device/Interface
     Drivers may still be able to work correctly.  If you "mess around" with
     DPMI programs, you may just need to experiment with things to see what
     happens.  Some of the USB-attached Physical Devices may work in your
     DPMI programs and some may not.  It is usually best to avoid DPMI
     altogether if you can, and just do things the "old-fashioned" way.










               DOS USB DRIVER INTRODUCTION            Page 29 of 186

     ISOCHRONOUS, INTERRUPT, CONTROL, & BULK TRANSACTIONS
     ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

     It is possible to attach many different kinds of Physical Devices to a
     USB Bus, everything from mice to disk drives to networks to video
     cameras.  The different kinds of Physical Devices are VERY different
     from each other in several respects.  For instance, mice only transfer
     small amounts of data at a time, need to do it tens or hundreds of times
     every second, usually don't ever get "turned off", and it's not a big
     deal if some of the data gets "lost".  A disk drive, on the other hand,
     usually transfers relatively large amounts of data, only needs to do it
     every once in awhile (when it is "asked" to do it for some reason),
     doesn't necessarily need to respond right away when it is asked for the
     data (it can take a little bit of time to "think" about it if it needs
     to), but must be assured that all of the data is transferred correctly
     with no errors.  The USB architecture is designed to handle all of these
     different requirements by using a hierarchial, prioritized packet
     scheduling scheme.

     Data gets transferred across the USB Bus in packets.  Unlike the "random
     access" packet scheme of the ethernet bus that many people are used to
     (CSMA/CD), USB uses a very structured scheme.  The Host Controller
     Driver (software) controls everything that happens on the bus, and it
     decides exactly when and where each packet will go.  The process of
     requesting, scheduling, and actually transferring a packet across the
     bus in USB jargon is called a Transaction.

     USB defines four different types of Transactions, which is what allows
     USB to properly process and prioritize the different "types" of data
     packets: Isochronous, Interrupt, Control, and Bulk.  Incidentally, those
     are listed in order of scheduling priority -- Isochronous Transactions
     are scheduled first, and Bulk Transactions are scheduled last.

     Isochronous Transactions are used to send data where there is a
     significant amount of data to be transferred, but WHEN the data is sent
     is more important than IF the data ever makes it to the other end.
     Device/Interfaces that use Isochronous Transactions are generally
     considered "real-time" or "streaming" Device/Interfaces, such as
     microphones, speakers, and video cameras.  Isochronous packets are sent
     (scheduled) at a very specific time, and the USB bus will make its best
     attempt to make sure the data successfully reaches the other end.
     However, if the data doesn't make it to the other end on the first
     attempt for some reason, the data is simply "lost".  USB doesn't even
     monitor whether the data actually makes it to the other end or not, and
     never bothers trying to resend it if it doesn't.








               DOS USB DRIVER INTRODUCTION            Page 30 of 186

     Interrupt Transactions are used to send data when there is a small
     amount of data to be transferred, the data is fairly continuous or comes
     in infrequent bursts, the EXACT timing of when the data is transferred
     is not critical (the timing can "slide" back and forth a little bit),
     and (similar to Isochronous Transactions) the data is not required to
     make it successfully to the other end.  Device/Interfaces that use
     Interrupt Transactions include mice, keyboards, and joysticks.  Unlike
     Isochronous packets, however, Interrupt packets ARE monitored and USB
     knows whether or not the data makes it to the other end.  However, USB
     does not automatically attempt to resend an Interrupt packet if it
     doesn't make it the first time.

     Bulk Transactions can be used to send either small or large amounts of
     data, exactly when the data gets transferred doesn't matter (it can get
     "delayed" a little bit), and the data must be "guaranteed" to reach the
     other end.  Device/Interfaces that use Bulk Transactions include disk
     drives, still cameras, and printers.  USB closely monitors Bulk packets,
     performs data integrity checks, and automatically retries multiple times
     (if needed) in an attempt to make certain the data is transferred
     successfully.

     Control Transactions are used to monitor and control the USB Bus and
     Devices.  All types of Device/Interfaces use Control Transactions.  For
     example, in the initialization and enumeration process discussed
     previously, Control Transactions are used to download the Descriptors
     from the Physical Device, to set the Logical Device Address, and to
     select various configuration options.  Like Bulk packets, Control
     packets are closely monitored and retried multiple times (if necessary)
     in an attempt to make certain that the packets are transferred
     successfully.


     PACKET SCHEDULING
     ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

     A USB 1.x Bus operates at a speed of 12 Mbps.  This is divided into 1000
     smaller "divisions" called Frames (each taking 1/1000 of a second).
     Therefore, each Frame can transmit 12,000 bits of data.  There is some
     overhead associated with maintaining the Bus and its packet-oriented
     data transfers, so it is not actually possible to transmit 12 million
     bits of "real" data every second.  The actual data throughput depends on
     many factors, but will always be something less than 12 Mbps.











               DOS USB DRIVER INTRODUCTION            Page 31 of 186

     The Host Controller hardware and Host Controller Driver (software)
     "communicate" with each other to transfer packets back and forth across
     the Bus using a Schedule.  The Software places items in the Schedule (a
     chunk of RAM) that tell the Hardware where to get data from (other
     chunks of RAM), where to send it (Logical Device address, end point,
     etc.), and how to send it (data integrity check and retry options,
     etc.).  At the start of each Frame (once every millisecond), the
     Hardware looks at the Schedule (in RAM), transfers data according to the
     Schedule (as defined by the Software), and notifies the Software when
     Transactions have been completed by modifying certain sections of RAM
     and generating hardware interrupts (IRQ's).  There is this constant
     back-and-forth between the Host Controller Software and Hardware that
     results in data packets getting sent across the USB Bus, but the control
     of everything that happens lies with the Host Software (the Hardware
     just does what the Software tells it to do in the Schedule).

     There are several requirements that the Host Controller Driver
     (software) must follow in determining how to set up the Schedule.  For
     instance, it must attempt to make sure that Isochronous packets get
     scheduled first, and Bulk packets get scheduled last.  In addition,
     according to the USB specifications, 10% of the Bus bandwidth must be
     "reserved" for non-time-critical Transactions (Control and Bulk).  In
     other words, the Isochronous and Interrupt Transactions cannot consume
     the entire Bus, even though they are considered higher priority than the
     Control and Bulk Transactions.  There are many other requirements as
     well, and as a result, the Host Software is very complicated and uses a
     substantial amount of memory.  Unfortunately, that is a "necessary evil"
     if you want to use something as advanced and flexible as USB.


     BUS TIMING
     ฤฤฤฤฤฤฤฤฤฤ

     A USB version 1.x bus normally operates at 12 Mbps.  The Host Controller
     has an on-board oscillator that controls the bus speed.  There are times
     when it may be necessary to adjust the speed (either slightly faster or
     slightly slower).  Usually, the only time this is required is when you
     are using an Isochronous Device/Interface (such as a telephone or video
     camera) with its own timing source, and you must synchronize the two
     timing sources together to avoid losing data.  The USB architecture
     allows the timing to be adjusted by small amounts around the "optimum"
     12 Mbps to allow for synchronization to outside sources.











               DOS USB DRIVER INTRODUCTION            Page 32 of 186

     The DOS Application Programming Interface (discussed below, page 43)
     provides a way for a program (presumably a software Driver for an
     Isochronous Device/Interface) to manipulate and control the bus Timing.
     One thing to keep in mind, however, is that there can be only one
     "Owner" of the bus Timing.  This means, for example, that you cannot
     install two different Device/Interfaces, both of which must be
     synchronized to two different external timing sources, on the same bus
     (they cannot be on the same Host Controller).  If you ever have such a
     situation, you must install the two Device/Interfaces onto two separate
     busses (two different Host Controllers).

     The way that the USB architecture controls the Timing of the bus is by
     manipulating the number of bits that are sent in a Frame.  There are
     1000 Frames per second, and (normally) 12,000 bits per Frame.  Each
     version of Host Controller (UHCI vs. OHCI) allows a different "range" of
     manipulation.  For example, in a UHCI Host Controller (the only one
     currently supported by the DOS USB Drivers), you can set the number of
     bits per Frame to any number between 11,936 and 12,063 (the default
     value, obviously, is 12,000).  Increasing the number of bits per Frame
     makes the bus run slower, and decreasing the number makes the bus run
     faster.

     In addition, the USB specification states that the Timing cannot be
     changed by a large amount instantaneously while the bus is running --
     the changes must occur smoothly and slowly.  Specifically, the USB
     specification states that the Timing cannot change by more than one bit
     per Frame for every six Frames.  The change from one extreme to the
     other (in UHCI, 11,936 to 12,063, or vice-versa), for example, takes
     approximately 3/4 of a second.  These DOS USB Drivers handle the bus
     Timing change process automatically, and perform Timing changes smoothly
     and slowly according to the USB specifications.  Basically, you just
     need to give the Driver a "target" Timing value, and it handles all of
     the details automatically.




















               DOS USB DRIVER INTRODUCTION            Page 33 of 186

     LEGACY SUPPORT
     ฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        What is Legacy Support?
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        USB has a term called "Legacy Support".  Exactly what that means has
        changed over the years since USB's introduction in the mid-1990's,
        and exactly how it is implemented also varies from computer to
        computer.

        One of the main goals of USB was an attempt to replace all of the
        different "Legacy" external ports on the computer with a new, single,
        "universal" port/bus architecture.  Legacy ports include PS2 ports
        for keyboards and mice, parallel ports for printers and scanners,
        serial ports for modems and terminal emulators, SCSI ports for
        external hard drives and CD-ROM's, and various other specialized
        ports dedicated to many different kinds of external Devices.  Also,
        as a rule, the software required to support Legacy hardware was
        fairly efficient (didn't require a lot of memory), and was usually
        installed in the BIOS.  The BIOS is loaded before the Operating
        System, so Legacy hardware and software was generally Operating
        System independent.

        From a user perspective, USB is "easier" because there is only one
        kind of physical port to connect to, instead of the multitudes of
        specialized and proprietary ports there were used before.  However,
        USB is very software-centric (memory-intensive), and is intentionally
        designed so that the software is loaded by the Operating System
        instead of the BIOS.  Of course, the only Operating System that
        anybody (especially Microsoft) thinks actually matters is MS Windows,
        so usually the only kind of vendor-provided USB Drivers you can find
        are made for the newer Windows Operating Systems.

        There is a major problem with this philosophy, however.  There are
        certain kinds of Device/Interfaces that need to work before the
        Operating System is even loaded.  For instance, in order to get into
        the computer's BIOS/CMOS settings when the computer first turns on,
        you need to be able to use a keyboard (and, on some computers, a
        mouse).  In fact, sometimes you need to be able to configure
        something in the BIOS before it is even POSSIBLE to load the
        Operating System.  There are also times when it is necessary to
        access a Disk Drive before an Operating System is loaded, such as
        when you are trying to install a new Operating System.









               DOS USB DRIVER INTRODUCTION            Page 34 of 186

        What "USB Legacy Support" means in a general sense is the ability to
        access and use a USB Keyboard, Mouse, or Disk Drive when the computer
        first turns on, before the part where the computer even decides which
        Operating System to load.  This also "spills over" into the ability
        to use certain Device/Interfaces (Keyboards, Mice, and Disk Drives)
        in Operating Systems that pre-date USB (e.g., DOS and older versions
        of Windows), though that is not its true intended purpose.

        Note, however, that "Legacy Support" means different things on
        different computers.  On some computers, it means all three
        Device/Interfaces can be used (Keyboards, Mice, and Disk Drives).  On
        others, it may mean just one or two of them, but not necessarily all
        three.  On some computers, it means "plug-and-play", and on others it
        means all of the Legacy Physical Devices you intend to use must be
        plugged in when the computer is first turned on.  On some computers,
        the Legacy Physical Devices must be attached directly to a Root Hub
        (or a specific port on a specific Root Hub if you have more than
        one), and on other computers you can have some "regular" USB Hubs
        between the Legacy Physical Device and the Root Hub.  So, even if you
        enable Legacy Support on your computer, it doesn't necessarily mean
        the computer will do exactly what you want or expect it to do.

        Also, FYI, you usually enable Legacy Support by getting into the
        BIOS/CMOS settings as the computer is first turning on (usually, by
        pressing some special key or combination of keys on the keyboard).
        This poses an interesting situation.  If the only kind of keyboard
        you have is a USB keyboard, and Legacy Support is turned off in the
        BIOS, it is impossible for you to get into the BIOS to enable the
        Keyboard.  Likewise, if you use the USB Keyboard to disable USB
        Legacy Support in the BIOS, the next time you try to get into the
        BIOS to change something, you won't be able to because your USB
        Keyboard won't work.

        In my opinion, all computers SHOULD have a PS2 keyboard port, and you
        should ALWAYS have a regular PS2 keyboard lying around somewhere that
        you can use. If you don't, you may find yourself in a situation where
        it is impossible to boot the computer, because you need a "real"
        keyboard to be able the turn on the USB keyboard.  Consider yourself
        warned -- USB is not the panacea it's advertised to be.














               DOS USB DRIVER INTRODUCTION            Page 35 of 186

        How is Legacy Support Implemented?
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        Now that we've talked about why Legacy Support is necessary and some
        of the problems you can have while using it, let's talk about how it
        actually works.  Most people have heard of some of the different
        "modes" the CPU can be in: Real Mode, Protected Mode, and Unreal
        Mode.  As it turns out, there is another obscure mode that modern
        CPU's can be in, called "System Management Mode".  I don't know very
        much about why System Management Mode actually exists or what exactly
        is supposed to be used for, though admittedly I haven't really looked
        very hard.

        When USB Legacy Support is turned on for Keyboards or Mice, and a USB
        key is pressed or a USB mouse is moved, the USB Host Controller sends
        a special signal via the PCI bus to the CPU that tells the CPU to go
        into System Management Mode.  While in this mode, the computer
        essentially "plays a bunch of games" with the motherboard hardware
        and is able to emulate a keystroke or mouse movement through the
        keyboard controller hardware.  Any software that is running on the
        computer thinks that the keystroke or mouse movement was generated by
        a "real" keyboard or mouse (attached to a "real" PS2 port).

        The advantage of Legacy Support is that it works at such a low level
        (direct hardware interaction) that the keyboard/mouse emulation
        should be able to fool ANY Operating System or Application into
        believing that the computer actually has a PS2 keyboard or mouse
        attached to it.  Unfortunately, there is a huge disadvantage to
        Legacy Support as well: Legacy Support is limited to Keyboards, Mice,
        and Disk Drives (or some subset thereof).  Legacy Support does not,
        and will probably never, include support for the myriad of other USB
        Device/Interfaces you may want to use (Printers, Joysticks, Cameras,
        etc.).

        There is another disadvantage to using Legacy Support as well.  In
        Legacy Support mode, mice and keyboards do not usually have complete
        functionality.  A "basic" mouse for a PC has just two buttons;
        however, almost all USB mice these days have a scrolling wheel (which
        inherently includes a third button), and many "fancy" mice have
        several additional buttons and wheels besides those.  A "basic"
        keyboard has 101 or 102 keys; however, most USB keyboards have
        additional "system control" keys (Power, Sleep, Wakeup) or
        "multimedia" keys (speaker volume/mute, CD player
        Stop/Start/Pause/Skip, etc.).









               DOS USB DRIVER INTRODUCTION            Page 36 of 186

        USB Mice and keyboards have two different modes they can operate in:
        Boot Mode and Report Mode.  A Mouse in Boot Mode is a simple two-
        button mouse, and any of the extra buttons or wheels it may have are
        completely ignored -- it's like they don't even exist.  Similarly, a
        Keyboard in Boot Mode has only 101 or 102 keys, and any of the
        "extra" keys it has are simply ignored.  When a USB Mouse or Keyboard
        is first enabled, it comes up in Boot Mode, and the BIOS (Legacy
        Support) software usually leaves it in Boot Mode.  The reason Boot
        Mode exists is to make the BIOS software simpler and smaller.  The
        Legacy Support software can simply assume a "basic" mouse or keyboard
        configuration, and doesn't need to download and decipher the special
        Descriptor (called a Report Descriptor) that tells it how many
        buttons and wheels and keys the Mouse or the Keyboard actually has.
        An Operating System driver will (or at least should) change the Mouse
        or Keyboard into Report Mode, and allow you to use the extra buttons
        and wheels and keys that exist on your Mouse or Keyboard.  If you
        want to (or need to) use the extra "features" that your Mouse or
        keyboard has, you usually can't use Legacy Support -- you must use an
        Operating System Driver.

        There can only be one Host Controller Driver (software) controlling a
        USB Host Controller.  If the Legacy Support Driver (in the BIOS) is
        controlling the Host, an Operating System Driver cannot try to
        control the Host at the same time.  Once the Operating System Driver
        takes control, it is usually not possible to revert back to the BIOS
        (Legacy Support) Driver without rebooting the computer.  It would
        have been possible to design a mechanism that allowed the Host
        Controller to "share" two Drivers (where the Legacy Support software
        controls the Keyboard and Mouse, and the Operating System software
        controls all the other Device/Interfaces), but that's not the way
        they did it.

        Most modern computers have more than one USB Host Controller
        installed in them.  When you enable or disable Legacy Support in the
        BIOS (at boot time), it usually affects the Legacy Support for ALL of
        the Host Controllers that are installed in the computer.  However,
        Legacy Support is actually configured independently on each
        Controller, so you can leave Legacy Support enabled on some
        Controllers and disable it on others.  So, if you have more than one
        Controller, and you connect and set things up correctly, you can have
        your keyboard and/or mouse on a BIOS (Legacy Support) Controller, and
        all of your other Device/Interfaces on an Operating System
        Controller.










               DOS USB DRIVER INTRODUCTION            Page 37 of 186

        These DOS USB Drivers for the Keyboard (USBKEYB) and Mouse (USBMOUSE)
        provide reasonably good functionality, but it is not nearly as
        comprehensive as the Legacy Support (the Operating System drivers do
        not have access to System Management Mode and the low-level hardware
        resources that the Legacy Support driver does).  These DOS Drivers
        should work in most situations and with most DOS programs, but there
        are times when they don't.  If you find yourself in a situation (such
        as in certain DPMI environments) where the DOS Keyboard or Mouse
        Drivers don't work, and that situation can't be avoided (by using a
        different program, or using a "real" PS2 keyboard or mouse), then you
        may need to use Legacy Support instead of using the Operating System
        Drivers.  Just keep in mind that if you do that, the "extra" buttons
        and wheels and keys that your Mouse and Keyboard may have will
        probably be ignored.  It would be very nice if you could have it both
        ways: to be able to use all of the buttons and wheels and keys that
        are available to you, and to be able to use them in any program at
        any time.  Unfortunately, that's simply not possible because of the
        inherently short-sighted design of USB.



































               DOS USB DRIVER INTRODUCTION            Page 38 of 186

                               PROGRAM ARCHITECTURE
                               ออออออออออออออออออออ

     This section will discuss the overall architecture and philosophy that
     was used while writing the DOS USB Driver programs.  There are more than
     20 programs altogether, and I'm sure you are wondering why there are so
     many.  Hopefully, this section will explain that.

     There are some other DOS USB Driver programs out there, some of which
     you are probably already using.  This section will compare the way these
     DOS USB Drivers are written with the ways the other Drivers are written,
     in an attempt to show you why my programs are, in several ways, far
     superior to the others.  I will admit that the programs still have
     several shortcomings and issues, but the overall design philosophy
     allows those to be addressed and overcome.  The architecture is open and
     extensible (not proprietary), which means that the improvements and
     additions can actually be written by anyone -- you don't necessarily
     need to wait for me to get around to it.


     TSR vs. CONFIG.SYS
     ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

     Most (if not all) of the other DOS USB Driver programs that are
     available require at least some of the Driver software to be loaded at
     boot time, using CONFIG.SYS.  If you want to change something, or if you
     just want to sometimes use the USB hardware and other times don't, you
     need to edit your CONFIG.SYS file and reboot.  Luckily, booting to DOS
     doesn't take very long (compared to any other "modern" Operating System,
     at least), but it's still a hassle and should be avoided unless it's
     absolutely necessary.

     These DOS USB Drivers are all TSR's, which can be loaded and unloaded
     from memory at any time without rebooting.  You can load some or all of
     the Drivers at boot time if you want to (using AUTOEXEC.BAT), but it's
     not required.  You can also load and unload the appropriate Drivers you
     need manually (from the command-line) or "automatically" (using batch
     files) just when you actually need them.  This way, you're only using
     precious memory for the Drivers when you're actually using them, and not
     wasting memory for something you only need every once in awhile.













               DOS USB DRIVER INTRODUCTION            Page 39 of 186

     BACKGROUND vs. FOREGROUND
     ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

     Most of the other DOS USB Driver programs that are available send data
     packets across the USB bus as a foreground operation.  That is, when you
     tell the Driver to send some data to a particular Logical Device, you
     must wait until the data transaction has been completed before you can
     do anything else.  The Driver can only do one thing at a time, and that
     thing must be "triggered" by a foreground operation.  That is why most
     of the other DOS USB Driver programs only support Device/Interfaces such
     as flash drives and CD-ROMs, which are inherently only accessed with
     foreground applications.  Driver programs that are designed to operate
     in the foreground will never to be able to support inherently background
     Device/Interfaces, such as mice and keyboards.

     These DOS USB Drivers are specifically designed to be run in the
     background.  That is, when you tell the Driver to send some data to a
     particular Logical Device, the Driver essentially says, "OK -- now go do
     something else and I'll let you know when it's done."  The Driver takes
     care of sending the data ENTIRELY in the background, while the computer
     is busy doing other things in the foreground.  As you might imagine,
     running a process in the background is much more complicated (requires
     more memory) than doing it in the foreground.  However, the advantages
     it provides (such as the ability to support mice and keyboards)
     generally makes it worth the extra complexity.  In addition, a
     background process can very easily "simulate" a foreground process in
     situations where that is required, while it is impossible for a
     foreground process to simulate a background process.


     MODULAR vs. MONOLITHIC
     ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

     Most of the other DOS USB Driver programs are monolithic in nature.
     That is, once they are installed, "what they do is what they do".  For
     instance, there are several DOS USB Drivers whose sole purpose is to
     allow you to use USB disk drives (flash drives, external hard drives,
     etc.).  They are not modular nor are they extensible, so if there is no
     internal support in the monolith for USB mice or keyboards or printers
     or whatever (and there almost never is), you'll never be able to use
     those other kinds of Device/Interfaces.

     These DOS USB Drivers are modular, not monolithic.  For instance, if you
     have more than one USB Host Controller (most modern computers do), you
     need to load a separate Driver for each Controller.  If you only want to
     "turn on" some of them rather than all of them (which is usually the
     case in DOS), you just load Drivers for the ones you want to use.






               DOS USB DRIVER INTRODUCTION            Page 40 of 186

     However, in this architecture, a Host Controller Driver "module" does
     not control ANY type of USB Device (not even disk drives, like the other
     Drivers do).  Rather, there are separate Drivers for each type of
     Device/Interface (hubs, disk drives, mice, etc.), and you just install
     the ones you want to use.  If you don't have any USB Hubs (or don't want
     to use any of the Physical Devices you have attached to the Hubs), you
     don't need to load the Hub Driver.  If you don't have any flash drives
     (or aren't using them right now), you don't need to load the disk drive
     "module".  You only load the Drivers for the Device/Interfaces that you
     want to use right now, and can simply uninstall them when you don't need
     the Logical Device any more.  There are currently Drivers for several
     kinds of common Device/Interfaces written (hubs, disk drives, mice,
     keyboards, joysticks, and printers).  Because of the modular and open
     nature of the architecture, however, Drivers can be written for almost
     any type of Device/Interface (you can even write one yourself).


     PLUG-AND-PLAY vs. STATIC
     ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

     Most of the other DOS USB Driver programs are "static".  That is, you
     must have the particular Physical Device that you want to control
     plugged into the USB bus before the Driver (software) is installed.  If
     the software can't find the correct hardware while the software is being
     loaded, the software just stops.

     These DOS USB Drivers are "Plug-and-Play".  It doesn't matter if the
     software is installed before the hardware, or vice-versa.  For instance,
     you can leave a USB joystick plugged in all the time, and just load the
     joystick driver immediately before you load the game that uses the
     joystick, and unload the drivers as soon as the game is done.  Or, you
     can load the disk drive software through your AUTOEXEC.BAT file, leave
     it running all the time, and just plug and unplug your flash drives when
     you want to use them (just like you do with floppy drives).  The program
     architecture allows the correct hardware and software to "find" each
     other, no matter which one gets installed first.


     PROTECTED MODE vs. REAL MODE
     ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

     Most of the other DOS USB Driver programs require the computer's CPU to
     be running in Real Mode.  In particular, that means you are unable to
     use the EMM386.EXE memory manager (or some equivalent), because it puts
     the CPU into Protected Mode.  Without something like EMM386 installed,
     you do not have access to Upper, Expanded, or Extended Memory, which
     greatly decreases the amount of available DOS memory.






               DOS USB DRIVER INTRODUCTION            Page 41 of 186

     These DOS USB Drivers do not require the CPU to be in Real Mode.
     However, if the CPU is in Protected Mode, it must be in a VCPI (Virtual
     Control Program Interface) environment.  This is exactly what happens if
     you install EMM386.EXE (as long as you don't use the NOVCPI option).
     While the programs won't work in a non-VCPI protected mode environment
     (like DPMI or DPMS), they do at least work in some protected mode cases.
     This greatly increases the amount of memory you have to run DOS programs
     while these USB Drivers are installed.


     LEGACY EMULATION vs. NEW PROGRAM DEVELOPMENT
     ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

     Some of the other DOS USB Driver programs are written with the idea in
     mind that in order to use them, you should create or update a new DOS
     program specifically designed to interface with their Driver.  For
     example, there is a DOS USB Driver program out there that has an example
     of how to start writing a program to use a USB-to-Serial cable.  The
     problem with this approach, of course, is that it requires you to write
     a new program.  There simply aren't very many new DOS programs being
     written these days.  I think what DOS users usually want is a way to use
     their existing DOS programs with newer hardware.  There may be
     absolutely nothing wrong with their existing program, except that it
     doesn't "understand" USB.  In fact, there are some DOS programs that are
     FAR superior to any Windows program that's ever been written, and there
     are also some DOS programs that do useful or unique things that nobody's
     ever even bothered writing a Windows program to accomplish.

     These DOS USB Drivers are written with the full intention of "emulating"
     the Legacy hardware that USB is trying to replace.  For example, USBKEYB
     (the USB DOS keyboard Driver) emulates, as well as it can, a "real" PS2
     keyboard.  A DOS program that expects to see a PS2 keyboard will think
     that's what it's seeing, and nothing about the program needs to change
     or be re-written in any way.  The problem, of course, is that emulating
     hardware, especially in a DOS environment, is extremely haphazard and
     difficult: sometimes it works and sometimes it doesn't.  I've garnered
     some "tricks" over the years that I use to try and improve the emulation
     for different kinds of Device/Interfaces, but the simple fact of the
     matter is that it's not perfect.














               DOS USB DRIVER INTRODUCTION            Page 42 of 186

     THE DOS USB API
     ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

     Many of these "features" that these DOS USB Drivers have and that others
     don't are available because of the sophisticated API (Application
     Programming Interface) that is installed with the Host Controller
     Drivers (USBUHCI or USBUHCIL).  There is a separate and lengthy document
     (USBAPI.DOC) that describes the API in detail.  USBAPI.DOC is intended
     to be read by programmers, so if you're not a programmer the details it
     contains will likely bore you to tears.  However, you may be interested
     in reading the first several pages of it (before it gets into all of the
     gory details about CPU registers and call-back notifications and such).
     The first part of the document may give you some insight into the inner
     workings and interactions of the programs that can help you use and
     troubleshoot them much more effectively.

     Because the API is described in detail in USBAPI.DOC, I will not go into
     a lot of details here.  I will tell you , however, that the API is very
     extensive.  It is extensive enough, in fact, that it allows almost
     complete control and management of the USB busses.  Using only API
     calls, you can develop a "map" and discover basic information about of
     all of the Host Controllers, Root Hubs, and Device/Interfaces that are
     attached to the busses.  Using only the API, you can also manage and
     control all of the Physical Devices (Reset, Enable/Disable, Suspend,
     etc.).  If someone had a burning desire, in fact, they could develop a
     "DOS GUI USB Manager" program that would allow display and manipulation
     of the entire USB structure on the computer.  I do not intend to write
     such a program, but somebody else certainly could.

     There is one specific thing I feel I should mention about the API here
     (just in case you don't read the API documentation), because it can be
     very confusing.  The Program Architecture allows for a total of 16 USB
     Host Controllers to be managed (each requiring a separate Host
     Controller Driver program).  Each managed Controller is assigned a "Host
     Index" number between 0 and 15, but the numbers are NOT assigned
     sequentially (starting with 0 and working up towards 15).  There is also
     another type of index, called a "PCI Search Index", that is used to
     identify individual Host Controllers at a hardware level.  A PCI Search
     Index is only unique to each type of controller -- e.g., you can have a
     UHCI PCI Search Index 0, an OHCI PCI Search Index 0, and an EHCI PCI
     Search Index 0, all on the same computer.  PCI Search Indexes ARE
     assigned sequentially, starting with 0, and are assigned by the PCI BIOS
     as the computer is booting up.










               DOS USB DRIVER INTRODUCTION            Page 43 of 186

     In various screen displays associated with the DOS USB Drivers, you will
     see both terms appear (Host Index and PCI Search Index), and they will
     always be the same number (Host Index 2 is always PCI Search Index 2).
     That is because there is only one type of Host Controller Driver
     currently available, for UHCI Host Controllers.  The UHCI Host
     Controller Driver program (called USBUHCI or USBUHCIL) purposely assigns
     the Host Index to match the PCI Search Index, in the hopes of avoiding
     confusion.  However, as other types of Host Controller Drivers are
     developed in the future (for OHCI & EHCI), that will change.  Therefore,
     although the Host Index and PCI Search Index are currently always the
     same number, it is incorrect to assume they always will be.


     DRIVER, SUPPORT, & TEST PROGRAMS
     ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

     The modular design of the DOS USB Driver architecture divides the
     programs into three different "classes" or "types": Device/Interface
     Drivers, Support Programs, and Test Programs.  We've already talked
     about the Device/Interface Drivers (the TSR's that actually "talk to"
     and control the various USB Controllers and Device/Interfaces).  There
     are also several Support and Test Programs included as well.

     There are two major purposes for a Support Program.  The first purpose
     is to "translate" some sort of code (number) into a plain language
     description that you (as a user) can understand.  In its attempt to be
     efficient (to not transfer more data than is necessary to perform the
     job), the USB architecture contains oodles of code numbers.  Just as an
     example, there are several different types of General Descriptors that
     are required to "describe" details about a Device/Interface to the
     software on the computer.  Rather than transferring long strings of data
     to describe the Descriptor Type, simple code numbers are used.  For
     example, here are the code numbers associated with some of the General
     Descriptor Types:

       1 = Device Descriptor
       2 = Configuration Descriptor
       3 = String Descriptor
       ...

     The second major purpose for a Support Program is to provide a "common"
     place to store things that a whole bunch of other programs may need.
     This ultimately makes each program smaller, and also makes things easier
     to update.  Let's use the General Descriptors again as an example.









               DOS USB DRIVER INTRODUCTION            Page 44 of 186

     All Device/Interfaces have General Descriptors, and all Device/Interface
     Drivers need to download the General Descriptors in order to configure
     and control the Device/Interfaces.  All of the DOS USB Drivers have
     options to let you view the Descriptors of the Device/Interfaces it is
     controlling.  You can view the Descriptors just for casual interest, or
     because something is not working correctly and you need to do some
     troubleshooting.  It actually takes quite a bit of programming to decode
     and print the various Descriptors in an understandable fashion.  So,
     rather than "copying" everything it takes to do that into every single
     program that needs it, it is much easier and more efficient to create a
     separate program (or set of programs) dedicated to that purpose.  When a
     Device/Interface Driver needs to decode and print a Descriptor for you
     to view, it just "calls" the Support Program instead of trying to do it
     internally.

     In these DOS USB Drivers, the program that actually decodes the General
     Descriptors is called USBSUPT1 (USB SUPporT program #1).  In turn, the
     Support Program USBSUPT1 at various times may call other "sub-support"
     programs, such as VENDORID (which translates USB or PCI Vendor ID's into
     Vendor Names) and UNI2ASCI (which translates Unicode strings into ASCII
     strings).  Of course, USBSUPT1 isn't the only program that may need the
     functions contained in the "sub-support" programs, which is why they are
     not "embedded" into USBSUPT1.  The Support Programs can be called by any
     other program that wants to use them, not necessarily just the ones
     contained in this DOS USB package.

     The Support Programs are written as stand-alone DOS programs, rather
     than simple "data files" or in some "special" format that can only be
     read or executed in some unique way.  This allows you, if you want, to
     run the Support Programs as a separate, stand-alone programs, and
     discern all sorts of interesting things about the USB structure and
     organization.

     In addition, to Support Programs, there are also several Test Programs
     included in this package.  A Test Program is designed to test a specific
     Device/Interface Driver to make sure it is operating properly.  An
     example of a Test Program is PS2MTEST (PS2 Mouse TEST), which is
     specifically designed to test USBMOUSE (the USB Mouse Driver).  Test
     programs are originally written as part of the program-writing process,
     in order to test and troubleshot all of the features and compatibilities
     of a Device/Interface Driver.  You can use them to test and troubleshoot
     things as well, or you can just "play around" with them to see how
     things work.










               DOS USB DRIVER INTRODUCTION            Page 45 of 186

     THE DOS PATH
     ฤฤฤฤฤฤฤฤฤฤฤฤ

     This DOS USB package contains many different programs (more than 20 of
     them).  As noted above, some of the programs are interdependent on each
     other to some degree (Device/Interface Drivers call Support Programs,
     which may in turn call other Support Programs).  Because of this, I
     recommend that you put all of the DOS USB related programs in the same
     directory (I personally use C:\UTIL\USB), and that you put that
     directory in your DOS PATH.

     As a program is trying to locate the Support Program it needs, it first
     searches in the same location (same directory) that it is in, and then
     searches all directories in the PATH.  If it can't locate the correct
     Support File, it will not crash, but will simply display some sort of
     error message indicating that it couldn't find the Support Program it
     was looking for.  Keeping all the files in the same directory keeps
     things running smoothly and efficiently, and also makes it easier when
     the time comes for program updates.


































               DOS USB DRIVER INTRODUCTION            Page 46 of 186

                              GENERAL OPTION SWITCHES
                              อออออออออออออออออออออออ

     All programs will accept option switches from the DOS command line.  A
     complete list of option switches is usually obtained with a "?" option
     switch, e.g.:

       USBUHCIL ?

     Following are details of some of the "common" option switches, that are
     available for most of the programs.


     ALIASES
     ฤฤฤฤฤฤฤ

     Many programs have several aliases for each option switch (e.g., "Help"
     is usually an alias for "?").  If the program supports aliases, there
     will be an alias option switch listed somewhere in the details obtained
     from the "?" option.


     INSTALLATION INTO LOW MEMORY
     ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

     If a program is listed as a Device/Interface Driver, it is also a TSR
     (Terminate-but-Stay-Resident).  By default, the TSR's will automatically
     try to load themselves into upper memory, if there is any upper memory
     available (which there should be if you have EMM386.EXE installed).  All
     of the TSR's have an option switch to override this behavior, and if the
     appropriate option switch is selected they will install themselves into
     Lower (Conventional) Memory even if Upper Memory is available.  For
     example, to force installation of USBUHCI into Low Memory, do the
     following:

       USBUHCI LowMemory:Yes

     This only has an effect when the TSR is first installed into memory.
     After it has been installed, the option switch will not "move" the TSR
     from Upper to Lower Memory (or vice-versa).  You can, however, "move"
     the TSR from Upper to Lower Memory by Uninstalling it from memory, and
     then re-installing it using the appropriate option switch.











               DOS USB DRIVER INTRODUCTION            Page 47 of 186

     UNINSTALL FROM MEMORY
     ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

     All TSR's have an option switch to Uninstall themselves from memory.
     For example, to uninstall USBKEYB from memory, you would do the
     following:

       USBKEYB Uninstall

     A TSR will not Uninstall itself from memory unless it is "safe" for it
     to do so.  In most cases, what makes it unsafe is for another TSR to be
     installed after it was, which is "blocking" it.  All of the TSR's in
     this package use the IBM Interrupt Sharing Protocol, which prevents them
     from "blocking" each other.  TSR's from other sources generally do not
     use the IBM Interrupt Sharing Protocol; therefore, it is usually better
     to install TSR's from other sources first, and install the USB TSR's
     last.  That will allow you almost complete control of which TSR's are in
     memory at any particular time.


     "BAD" DEVICES
     ฤฤฤฤฤฤฤฤฤฤฤฤฤ

     As discussed previously, the USB architecture is "flaky", and
     Device/Interfaces do not always initialize or enumerate properly.  When
     this happens, the Logical Device is declared to be "Bad" by the
     software.  This does not necessarily mean that the Physical Device needs
     to be scolded or replaced (though it could mean that).  Sometimes,
     resetting the Physical Device (either by physically unplugging it and
     then re-plugging it back in again, or by issuing a software Reset) will
     fix the problem.

     The Device/Interface Drivers (TSR's) all operate in the background,
     while you are doing other things in the foreground.  In DOS, it is
     usually not safe for a background process (TSR) to "write" anything to
     the screen, since doing so could possibly screw up something that is
     happening in the foreground.  Therefore, the only way safe way a
     Device/Interface Driver has of informing you that something "bad" has
     happened is to beep the speaker.














               DOS USB DRIVER INTRODUCTION            Page 48 of 186

     By default, all of the Device/Interface Drivers will beep the speaker
     when they encounter a "bad" Device/Interface.  If you hear the beep, the
     Device/Interface Driver programs have option switches to help you figure
     out which Device/Interface is "bad", and show you details as to where
     and why during the complex initialization process the problem occurred.
     Note, however, that the details as to where and why the problem occurred
     are somewhat cryptic, and will require you to scan through the even more
     cryptic source code of the Device/Interface Driver to do any effective
     troubleshooting.  The source code for all of the Device/Interface
     Drivers is available if you want it, but if you are not familiar with
     Assembly Language programming, it may confuse you more than it helps
     you.

     If you have a Physical Device that always seems to fail for some reason,
     and is always beeping and annoying you, but you still want to keep
     plugged in, you can turn off the beeping.  All of the Device/Interface
     Drivers have an option switch to disable beeping for "bad" Devices.  For
     example, to do it with USBUHCIL, you would do the following:

       USBUHCIL Beep:No


     In the Host Controller Drivers (USBUHCI & USBUHCIL), "bad" Logical
     Devices are assigned a "fake" Address.  Therefore, to view details about
     the "bad" Logical Devices, you simply tell USBUHCI or USBUHCIL that you
     want to view details about all of the Logical Devices, and the "good"
     ones and "bad" ones will all appear together.  For example:

       USBUHCI AddressData

     As noted above, however, even if a Logical Device makes it through the
     initialization and enumeration process of the Host Controller Driver, it
     may not necessarily make it through the configuration process of the
     specific Device/Interface Driver.  In the specific Device/Interface
     Drivers, the "bad" Device/Interfaces are stored separately from the
     "good" Device/Interfaces.  There will be an option switch to view the
     "bad" Device/Interfaces in the specific Device/Interface Driver.  For
     example:

       USBJSTIK Bad













               DOS USB DRIVER INTRODUCTION            Page 49 of 186

     VIEWING DESCRIPTORS
     ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

     All Device/Interface Drivers (TSR's) have switch options that allow you
     to view the Descriptors that were downloaded from a particular
     Device/Interface.  Something to keep in mind, however, is that any
     particular Device/Interface Driver will usually only let you view the
     Descriptors of the last Device/Interface that was enumerated or
     configured.  In order to use as little memory as possible, the TSR will
     only contain a buffer large enough to store the Descriptor data for the
     Device/Interface it is currently enumerating or configuring.  When it is
     done working with the Device/Interface, it will keep the data in the
     buffer until a new Device/Interface is detected.  The old
     Device/Interface data will then get overwritten by the new
     Device/Interface data, and the old data is forgotten.

     All Device/Interface Drivers have an option switch that will show you
     the data that is contained in the buffer of the TSR, which will only be
     valid for the last Device/Interface that was configured.  If you want to
     view the details for a particular Device/Interface, and it was not the
     last configured Device/Interface, you will need to Reset the Physical
     Device you're interested in so that it becomes the last
     Device/Interface.  You can Reset a Physical Device either by physically
     unplugging it and then re-plugging it back in again, or by issuing a
     Reset through the software.

     For example, to view the General Descriptors for the last mouse that
     USBMOUSE configured, you would do a:

       USBMOUSE Descriptors

     In addition to the General Descriptors, many Device/Interfaces also have
     class- or vendor-specific Descriptors that are downloaded during the
     configuration process.  If this is the case, the Device/Interface Driver
     will have an option switch that will allow you to view the specific
     Descriptors for the last configured Device/Interface.  For example,
     mice, keyboards, and joysticks are all part of a larger "class" of
     Device/Interfaces called Human Interface Devices or HID's.  HID's have a
     special, class-specific Descriptor called a Report Descriptor that
     "describes" details about the Device/Interface (numbers and types of
     buttons, wheels, keys, axes, LED's, etc.).  To view the Report
     Descriptor of the last keyboard configured by USBKEYB, for example, you
     would do a:

       USBKEYB ReportDescriptor








               DOS USB DRIVER INTRODUCTION            Page 50 of 186

     ENVIRONMENT VARIABLES & REDIRECTED INPUT
     ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

     Depending on the complexity and use of a particular program, in addition
     to accepting option switches from the command-line, it may also accept
     option switches from an environment variable or a redirected input file.
     The name of the environment variable is the same as the program name
     (e.g., the environment variable USBMOUSE is associated with the
     USBMOUSE.COM executable program).  The format of the options in the
     environment variable is exactly the same as the format on the command
     line.  For example, performing a:

       SET USBMOUSE=Resolution:8

     before running USBMOUSE would accomplish the same thing as:

       USBMOUSE Resolution:8

     Programs that use environment variables read the option switches from
     the environment variable first, before reading them from the command-
     line.  This allows environment variables to store the "default" option
     switches you normally use, but you can "override" the environment
     defaults at any time by using command-line option switches.

     The format option switches in a redirected input file are similar to
     those in an environment variable or on the command-line, but allows
     organization (such as blank lines and indents) and comments (anything on
     a line following a semicolon ";" is considered a comment).  For example,
     the following lines could be in an ASCII text file called USBMOUSE.IN:

         ;This is USBMOUSE.IN, an example of a redirected input file

           Resolution:8 ;Set Mouse Resolution to 8 Counts/mm

         ;This is the end of USBMOUSE.IN

     If you then did the following:

       USBMOUSE < USBMOUSE.IN

     you would accomplish the same thing as:

       USBMOUSE Resolution:8

     The main reason for allowing redirected input files is to allow many
     options switches to be entered at the same time, when there is simply
     not enough space on a single DOS command line (limited to 126
     characters) to do everything that needs to be done.  If a program allows
     option switches from a redirected input file, it reads the environment
     variable first, then the redirected input file, and finally the command-
     line.  Options switches on the command-line are always the "final word".


               DOS USB DRIVER INTRODUCTION            Page 51 of 186

                                INDIVIDUAL PROGRAMS
                                อออออออออออออออออออ

     Below are brief descriptions of each of the programs in the DOS USB
     "package".  These descriptions are not complete, but are simply intended
     to provide enough information for you to be able to use the program
     effectively (this document is a "ReadMe" file, not complete
     documentation).  This document will simply explain some of the more
     "obscure" or difficult-to-understand options, and discuss major
     interactions or idiosynchrocies related to the program's use.  Most of
     the "general" stuff you need to know about USB, program interactions,
     and "common" switch options are discussed above, and will not be
     repeated.

     The programs are in various stages of completion.  Some are considered
     "complete", which means that there are no current ideas or plans to
     update or upgrade them any further.  Some are essentially complete and
     fully functional, but have a few minor "tweaks" and adjustments that are
     planned for them.  Others are functional, but still have several major
     items that need to be changed or adjusted.  Comments are welcomed on any
     of the programs, no matter what stage of "completion" they are
     considered to be in.

     I would welcome some help from anybody interested in updating or adding
     to any or all of these programs.  You can freely download the source
     code for the programs, and as long as you continue to abide by the
     license (never charge anyone in any way for the programs, source code,
     or anything derived from them), you can do as you wish.  However, if you
     decide to update or create your own drivers, I would like you to PLEASE
     notify me of your intentions, and allow me to host your completed
     program on my web site.  This will be especially critical if more than
     one person decides to update the same program at the same time, which
     (for obvious reasons) should be coordinated.

     All of the programs are considered in alpha or beta.  It is expected
     that anyone using these programs is a "beta tester", and already has a
     basic understanding and mastery of common DOS and hardware mechanisms
     (BIOS configuration, booting, batch files, PATH, environment variables,
     TSR's, IRQ's, I/O Addresses, etc.).  If you do not already have a pretty
     good handle on these things, you will probably get confused very
     quickly.












               DOS USB DRIVER INTRODUCTION            Page 52 of 186

     One thing to keep in mind about the Device/Interface Drivers is that
     because they are TSR's, they are constantly doing things in the
     background while you are doing things (running other programs) in the
     foreground.  Therefore, when you have one of the programs show you a
     "status report" of some sort, it is simply giving you a "snapshot" of
     what is happening in the TSR at the particular moment in time that you
     ask it.  If you ask it to show you the status again a short time later
     (even a single millisecond), it may show you something completely
     different.  In USB, the Schedule is constantly being modified and
     processed, data packets are constantly being sent back and forth,
     Physical Devices are being inserted and removed and performing their
     dedicated functions, etc.  The whole concept of something running in the
     background where you can't "see" what's going on constantly may confuse
     you at first, but you'll eventually get used to it.


     USBUHCI & USBUHCIL
     ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

     Version:     0.14
     Prog Type:   Device/Interface Driver
     Source Code: ASM (A386 by Eric Isaacson)
     Status:      Complete, a few minor tweaks required
     Environment: USBUHCI (for USBUHCI.COM)
                  USBUHCIL (for USBUHCIL.COM)
     Redirection: Yes
     Overlay:     USBUHCI.OVL (for USBUHCI.COM)
                  USBUHCIL.OVL (for USBUHCIL.COM)
     Purpose:     Driver for Universal (UHCI) USB Host Controllers
     TSR Memory:  USBUHCIL: 29.7 kB (first Instance)
                            12.5 kB (instances 2+)
                  USBUHCI:  42.6 kB (first Instance)
                            24.6 kB (instances 2+)


     USBUHCI is the full USB Host Controller Driver program.  USBUHCIL is the
     "Lite" or "Limited" version.  The difference between the two is that
     USBUHCI can handle a full 126 Logical Devices (Addresses), and allows
     Isochronous Transactions to be scheduled.  USBUHCIL can only handle 16
     Logical Devices, and does not allow the scheduling of Isochronous
     Transactions.  Both programs implement the full Application Programming
     Interface (API) as described in USBAPI.DOC, and are equivalent in every
     other way.

     From now on, when we are referring to one or the other of the programs
     (USBUHCI or USBUHCIL), we will use the name of the individual program.
     When we are referring to a Host Controller Driver in general (and can be
     actually referring to either program), we will use USBUHCI{L}.





               DOS USB DRIVER INTRODUCTION            Page 53 of 186

     USBUHCIL uses substantially less memory than USBUHCI, and should be
     sufficient for most applications.  Most computers only have a few
     Physical Devices plugged into any particular USB bus, and there are no
     Drivers available yet for any type of Isochronous Device/Interface (such
     as a Video Camera).  Note, however, that because there has not yet been
     a Device/Interface Driver developed for a "real" Isochronous Device, the
     Isochronous capabilities of USBUHCI have not been tested with an actual
     Physical Device and may not work correctly.

     Both USBUHCI & USBUHCIL require an overlay file to operate properly.
     The overlay file for USBUHCI is called USBUHCI.OVL, and the overlay file
     for USBUHCIL is called USBUHCIL.OVL.  The overlay file must be in the
     same directory as the main executable file (USBUHCI.COM or
     USBUHCIL.COM).  If USBUHCI{L} cannot find the overlay file (or it is the
     wrong version of overlay file), the program will not work.


        PCI Search Index
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        A modern computer will typically have more than one UHCI Host
        Controller installed.  USBUHCI{L} will only control one UHCI Host
        Controller.  However, more than copy (instance) of USBUHCI{L} can be
        installed in memory at the same time, each controlling a different
        UHCI Host Controller.  When you have more than one instance of
        USBUHCI{L} in memory at the same time, you need to be able to
        identify which one is which, and which one is associated with which
        physical Host Controller.  This is done with an identifier called a
        "PCI Search Index".

        A PCI Search Index is a 0-based index number that is assigned by the
        PCI BIOS to enumerate and identify the different UHCI Host
        Controllers.  The "first" Host Controller is given PCI Search Index
        0, the "second" is given Index 1, etc.  If you only have one UHCI
        Host Controller, it is assigned PCI Search Index 0.  The USBHOSTS
        program (below, page 82) will show you the details of all the
        different Host Controllers on your computer, including the PCI Search
        Indexes.

        Keep in mind, however, that you do not necessarily need install an
        instance of USBUHCI{L} for each and every physical UHCI Host
        Controller you have.  You only need to install USBUHCI{L} for the
        Host Controllers that have USB Devices attached that you actually
        want to be able to use and control in DOS.  For example, to issue
        commands for the UHCI Host Controller with PCI Search Index 2 (the
        third one), you would do a:

           USBUHCIL Index 2 {other Options here}





               DOS USB DRIVER INTRODUCTION            Page 54 of 186

        If you do not give USBUHCI{L} an Index number with an option switch
        (either in the USBUHCI{L} environment variable, redirected input
        file, or command-line), it assumes you want to use Index 0.  Also
        note that the first instance of USBUHCI{L} you install into memory
        (if you install more than one) does not necessarily needed to be
        associated with Host Controller Index 0.  You can install the
        different instances of USBUHCI{L} in any order you want.


        Memory Usage
        ฤฤฤฤฤฤฤฤฤฤฤฤ

        The first instance of USBUHCI{L} that gets installed into memory uses
        quite a bit more memory than the later instances.  This is because
        all of the program code it takes to manage a Host Controller
        (including the sophisticated Application Programming Interface or
        API) is installed in the first instance.  In addition to the code,
        the first instance also contains all of the data required to manage
        the "first" Host Controller (data such as the Schedule and "map" of
        the attached Devices).  After the first instance is installed, any
        other instances that are installed "reuse" the program code that was
        installed in the first instance.  The only memory that the later
        instances use is the memory needed to store the data that is unique
        to the particular Host Controller -- they do not need another copy of
        the program code.  This allows the Host Controller Drivers to use as
        little total memory as possible.

        However, this can also cause you some problems when you want to
        Uninstall the first instance of USBUHCI{L}.  Because the first
        instance is the one the contains all of the program code (including
        all of the code for the API), it cannot be Uninstalled unless all the
        other programs that depend on it are Uninstalled first.  This
        obviously includes all further instances of USBUHCI{L}, but also
        includes any USB Device Drivers you have installed (which access the
        API).  The program architecture normally lets you install and
        Uninstall Device Drivers at any time and in any order, but that is
        not true for the first Host Controller Driver.  It is the
        "foundation" that all of the other programs depend on, and therefore
        must the last program that is Uninstalled.  Remember also that the
        first instance of USBUHCI{L} installed into memory does not
        necessarily need to be associated with the "first" UHCI Host
        Controller (the one with PCI Search Index 0).  The two concepts of
        "first" are very different from each other.










               DOS USB DRIVER INTRODUCTION            Page 55 of 186

        IRQ & I/O Resources
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        Each UHCI controller requires two hardware resources from the
        computer: an IRQ (Interrupt ReQuest line, a.k.a. hardware interrupt
        number), and 32 bytes of I/O (Input/Output) space.  Normally, these
        are assigned and configured during the boot process by the BIOS.  If
        they are not assigned by the BIOS, USBUHCI{L} will try to assign them
        automatically.  For the IRQ, USBUHCI{L} will use IRQ #9.  For the I/O
        space, USBUHCI{L} will start searching at I/O address 400h, and look
        for a 32-byte section of I/O space that appears to be unused.  Again,
        USBUHCI{L} will only do this if the IRQ & I/O space have not already
        been assigned by the BIOS.

        If the IRQ and I/O space were assigned by the BIOS, they will usually
        (but not always) work just fine and you will not have any conflicts.
        If USBUHCI{L} automatically assigns them, they will also probably
        also work just fine, but it's possible that they won't.  For example,
        if USBUHCI{L} is using IRQ #9, but IRQ #9 is already being used by
        some other port or device on the computer, and is not configured as a
        Sharable IRQ, trouble can result.  When USBUHCI{L} starts using IRQ
        #9, the computer will either crash or the other device will just stop
        working.  If there is no other device currently using IRQ #9, or it
        is set up as a Sharable IRQ, there should not be any problems.

        There is one particular IRQ number that will almost always cause you
        problems: IRQ #12.  On all modern computers, IRQ #12 is reserved for
        the PS2 mouse, and should NEVER be used for anything except the
        mouse.  Some BIOS s set up IRQ #12 to be used for other things
        besides (or in addition to) the mouse, including using IRQ #12 for a
        USB host controller.  This is almost always guaranteed to cause you
        problems, especially if you intend to use a USB mouse in DOS.  If one
        (or more) of your USB host controllers is using IRQ #12, and you ever
        intend to use a USB mouse on that computer, you should change the IRQ
        to something else.


        You are less likely to have a conflict in the I/O space than you are
        with the IRQ, but a conflict can happen there as well.  Unlike IRQ's,
        I/O space cannot be shared.  As USBUHCI{L} is scanning through the
        I/O space to find an empty range, it is possible (though very
        unlikely) that it will "screw up" some port or device that's already
        using the space it's trying to scan.










               DOS USB DRIVER INTRODUCTION            Page 56 of 186

        There is also a possibility that the IRQ or I/O space as assigned by
        the BIOS are actually wrong (that is, what the BIOS tells you it did
        and what it actually did are two different things).  This actually
        happened to me on a Sony laptop, and it took me quite awhile to
        figure out what the problem was.  Like many modern computers, the
        laptop uses highly integrated chip sets on the computer.  Rather than
        having individual chips for each function (such as a separate chip
        for each USB Host Controller), there is a single chip (manufactured
        by Intel) that combines a whole bunch of separate functions onto a
        single chip.  In my case, the chip contains several USB Host
        Controllers, along with several other functions.

        In the specification for UHCI Host Controllers (written by Intel),
        there is a specific location in the UHCI configuration space where
        the IRQ number is stored.  In a "regular" UHCI Controller, that is
        also how you configure the IRQ that is actually used.  If you change
        (write to) the IRQ number stored there, it literally changes the IRQ
        line that the Host Controller uses.  Unfortunately, in the integrated
        chip set used on the Sony laptop, that is not what happens.  The IRQ
        number that is stored in the UHCI configuration space is simply there
        "for show".  Changing it does not change anything -- the actual IRQ
        number is stored somewhere else in the configuration space, and
        exactly where it's stored is specific to that particular model of
        Intel chip (it is not "standard" the way UHCI is supposed to be).  As
        the Sony BIOS is setting up the USB Host Controllers during the boot
        process, it is supposed to copy the "real" IRQ number (stored in the
        proprietary location) into the (useless) UHCI configuration space.
        Well, the Sony BIOS does in fact put a number into the UHCI
        configuration space, but it puts the WRONG number.

        As you might expect, it took me some time to track this problem down.
        At first, I though there was something wrong with the USBUHCI{L}
        program, and just blew it off for a while.  When I finally got around
        to earnestly troubleshooting things, I discovered that the computer
        was lying to me about what IRQ it was using, and that if I tried
        changing the IRQ in the UHCI configuration space, it didn't actually
        do anything.  Incidentally, that's why I'm including the IRQ program
        (below, page 86).  It can be useful in helping you track down and
        trace IRQ's for situations such as this.














               DOS USB DRIVER INTRODUCTION            Page 57 of 186

        USBUHCI{L} has option switches that let you configure the IRQ and I/O
        space, if you want to do that.  Note, however, that if you use either
        of these option switches, they will override (overwrite) the settings
        of the BIOS, and USBUHCI{L} will not try to automatically configure
        anything.  USBUHCI{L} considers the IRQ and I/O space numbers you
        give it to be "gospel", and does no checking or testing of them.
        USBUHCI{L} simply stores the number(s) that you give it into the UHCI
        configuration space.  You can either use the switch options to change
        or manually configure the IRQ and I/O resources (usually to avoid
        conflicts), or, as in the case of my Sony laptop, to make sure that
        what it says in the UHCI configuration space (which is what
        USBUHCI{L} uses) matches how the computer hardware is actually set
        up.

        The IRQ number must be between 3 and 15 (though you should usually
        avoid IRQ 12 if you intend to use a USB mouse), e.g.:

           USBUHCI IRQ 11 {other options}

        The I/O base address must be between 100h and FFE0h, and must be
        evenly divisible by 32 (20h), e.g.:

           USBUHCIL IOAddress 420h {other options}

        Note that the IRQ and I/O space option switches only have an effect
        when USBUHCI{L} is first being installed into memory.  After it has
        been installed, you cannot change the IRQ or I/O resources without
        Uninstalling USBUHCI{L} from memory completely and the re-installing
        it with the new settings.


        Other Host Controller Drivers
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        There can be only one software Driver managing and scheduling each
        USB Host Controller.  The Driver can be the BIOS (Legacy Support),
        USBUHCI{L}, or another brand of DOS Driver (incompatible with
        USBUHCI{L}).  As you are attempting to install USBUHCI{L} into memory
        to start managing a particular UHCI-compatible Host Controller,
        USBUHCI{L} will detect if there is another Driver already installed.
        If there is, USBUHCI{L} will stop and ask you if you really want to
        "disable" the other Driver in order to install USBUHCI{L}.  If you
        tell USBUHCI{L} to continue with the installation, it will save the
        status of the current Driver before installing itself into memory.
        Later on, when you Uninstall USBUHCI{L} from memory, USBUHCI{L} will
        attempt to "restore" the state of the original Driver.
        Unfortunately, this doesn't usually return things back exactly to the
        way they were before you installed USBUHCI{L}, at least not in the
        way you think it would.




               DOS USB DRIVER INTRODUCTION            Page 58 of 186

        While USBUHCI{L} was installing, it had to Reset the Host Controller
        hardware and any Physical Devices that were attached to the bus
        (possibly multiple times).  While USBUHCI{L} is Uninstalling, it must
        also reset the Host Controller hardware.  As a result of all of this
        manipulation, the Host Controller hardware and the original (non-
        USBUHCI{L}) Host Controller Driver have become "unsynchronized", and
        the software doesn't actually know what the hardware looks like any
        more.  If you want any of the Physical Devices to start working
        again, you must usually tell the original Host Controller Driver to
        "reset" itself (some Host Controller Drivers provide a way to do that
        and some don't -- Legacy Support Drivers never do).  If you can't (or
        don't know how to) reset the original Driver, you can try unplugging
        and re-plugging each of the Physical Devices in an attempt to reset
        them.  Of course, that will only help if the original Driver supports
        plug-and-play, which most of them do not.

        Instead of having USBUHCI{L} stop to ask you if it should continue
        with the installation when it detects that another Driver is managing
        the Host Controller, there are option switches you can use to tell
        USBUHCI{L} to do it automatically.  If you want USBUHCI{L} to
        automatically replace a BIOS (Legacy Support) Driver, you would do
        the following:

           USBUHCI DisableLegacySupport {other options}

        If you want USBUHCI{L} to automatically replace another (non-BIOS)
        Driver, you would do the following:

           USBUHCIL DisableOtherProgram


        Disabling the Companion EHCI Host Controller
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        Most modern computers are capable of USB 2.0, which can transfer data
        at much higher speeds than USB 1.0.  USB 2.0 is designed to be
        backwards-compatible, which means that USB 2.0-capable devices can
        operate on a USB 1.x bus (managed by a USB 1.x host controller), and
        vice versa.  The mechanism used to perform this "sleight-of-hand" is
        what USB calls "Companion Controllers".

        A USB 2.0 host controller actually has two different "sections" in
        it.  It has a high-speed (USB 2.0) section, which uses the EHCI
        (Enhanced) protocol, and also has a full/low speed (USB 1.x) section,
        which uses either the UHCI (Universal) or OHCI (Open) protocol.  The
        two "companion" sections are integrated together as one unit, and
        they interact with each other very closely.






               DOS USB DRIVER INTRODUCTION            Page 59 of 186

        Assuming all of the correct software is installed and everything is
        working like it should, this is what happens when a Device is
        attached to a port on the root hub (the root hub is also a separate
        "section" of the host controller).  The EHCI (high-speed) section
        detects that a Device is attached, and determines whether the Device
        is USB 2.0-capable or not.  If it is, the EHCI section keeps control
        of the Device by keeping control of the root hub port (it never lets
        the full/low-speed section know that the Device is even there).  If
        the Device is not high-speed-capable (if it is a USB 1.x Device), the
        EHCI section "flips a switch" and transfers control of the Device to
        the full/low speed section (UHCI or OHCI).

        In most USB 2.0 implementations, the sole criteria used to determine
        which host controller (high-speed or full/low speed) should control
        the Device is the speed capability of the Device.  It doesn't matter
        if you can actually do anything useful with the Device or not -- all
        that matters is whether it is "fast".  This actually causes a problem
        in some cases when you're using USBUHCI{L}.  I'll provide some
        specific examples from my own experience.

        I have a relatively new computer that is USB 2.0-capable, and does
        not have any legacy PS2 ports for the keyboard or mouse (you must use
        a USB keyboard and mouse).  Obviously, the BIOS is set up with Legacy
        Support to handle the mouse and the keyboard, and also includes
        support for USB disk drives.  However, the USB support in the BIOS
        does not allow for any other types of USB Devices, like printers or
        joysticks.  Unfortunately, I have USB printers and joysticks that I
        want to use sometimes with my DOS programs, but that is impossible to
        do with the BIOS support.  The BIOS manufacturers apparently expect
        you to never run "real DOS" any more, but rather expect you to run
        DOS emulators under Windows or Linux.  This is completely
        unacceptable to me.

        Because my printer is USB 2-0 capable, the BIOS of the computer takes
        control of the printer (even though I don't want it to).  The BIOS
        never relinquishes control of the printer to the full/low-speed
        section of the host controller (UHCI), where I can install the
        drivers that let me actually use the printer.  I also cannot
        completely disable USB Legacy Support in the BIOS, because the USB
        keyboard is required to be able to boot.  So, what I need is a way to
        completely disable the EHCI (high-speed) section of the host
        controller after the computer has booted up, which forces all of the
        Devices to the full/low-speed (UHCI) section, so that I can install
        the DOS drivers, so that I can actually use the printer.









               DOS USB DRIVER INTRODUCTION            Page 60 of 186

        On the same computer, I also have another time when I need to disable
        the EHCI controller and force the USB devices onto the full/low-speed
        (UHCI) controllers.  As noted before, the BIOS does support USB disk
        drives, and also supports plug-and-play of the USB devices, but only
        to a limited degree.  The BIOS supports USB disks in DOS (DOS assigns
        a drive letter to them) only if a USB disk is plugged in when the
        computer is booted.  After the BIOS is done and DOS has taken over,
        it's too late to assign new DOS drive letters.  The BIOS does let you
        insert and change USB disks after DOS has booted, but can't assign a
        new drive letter to them.  So, instead of plugging in the USB disk
        and rebooting, I instead simply disable the EHCI controller so that I
        can install the DOS USB drivers contained herein and use the disk(s)
        (the disk driver, USBDRIVE, can assign new drive letters after DOS
        has booted).  The disadvantage to this is that the disks only operate
        at full-speed (12 Mbps) rather than high-speed (480 Mbps), since an
        EHCI driver has not yet been developed.  However, unless I'm needing
        transfer a bunch of data, it's much more acceptable to me to put up
        with the lower speeds for a little while than it is to wait for the
        computer to reboot.

        I have provided a way to disable an EHCI controller, which forces all
        of the USB devices onto the UHCI controllers, thereby allowing you to
        use the drivers contained herein.  The option to do this, however, is
        part of the USBHOSTS program (below, page 82), rather than part of
        this program (USBUHCI{L}).  You can read about the STOP option in
        USBHOSTS below on page 83.


        Debugging Program Installation
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        While USBUHCI{L} is installing itself into memory as a TSR, or while
        it is uninstalling itself from memory, there may be problems that
        keep it from being successful.  When this happens, USBUHCI{L} is
        usually able to display some sort of error message telling you what's
        wrong so that you can try and fix it.  Unfortunately, in rare cases,
        USBUHCI{L} will simply "lock up" when a problem occurs during
        installation or uninstallation.  The usual cause of this is a UHCI
        (or companion EHCI) host controller that doesn't exactly comply with
        the specifications, or a problem in the BIOS with the way it
        implements USB Legacy Support for keyboards, mice, and/or disk
        drives.

        USBUHCI{L} has an option that helps to narrow down exactly where the
        problem is occurring, to help you troubleshoot things.  What the
        option does is display (on screen) each of the major steps that
        USBUHCI{L} is currently performing during the installation or
        uninstallation process.  If USBUHCI{L} "locks up" on you, try doing
        the same thing again with the Program Debugging option turned on:

           USBUHCIL ProgramDebug {other options}


               DOS USB DRIVER INTRODUCTION            Page 61 of 186

        This will let you see what USBUHCI{L} is trying to do when the "lock
        up" happens, helping you to figure out what exactly might be
        "broken".  On my most recent computer, I had a problem when trying to
        uninstall USBUHCI{L}, and I used the ProgramDebug option to help
        isolate the problem and create a patch for it.

        You can also use the ProgramDebug option to slow down the
        installation or uninstallation process, by adding a number after the
        option.  The number must be between 0 and 2000 (with the default
        being 0), and is the number of milliseconds to delay between each
        major step.  For example:

           USBUHCIL ProgramDebug:10 {other options}

        This will cause USBUHCI{L} to delay 10 milliseconds between each of
        the major steps, slowing down the installation or uninstallation
        process slightly.  Slowing down the process may actually cause it to
        work (to not "lock up" any more), though I've never seen that happen
        in my limited experience.  Slowing things down also helps you see
        what''s going on a little bit clearer, instead of having things flash
        by on the screen so fast you can't make any sense out of it.

        Please do not confuse this ProgramDebug option with the Debug option
        discussed below (page 72).  This ProgramDebug option is designed to
        help troubleshoot installation and uninstallation of the executable
        program file itself (USBUHCI.COM or USBUHCIL.COM), while the Debug
        option below enables the Debug/SingleStep mode that is built into the
        UHCI host hardware.

























               DOS USB DRIVER INTRODUCTION            Page 62 of 186

        Postponing Device Enumeration
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        After USBUHCI{L} is installed into memory, it normally starts
        immediately enumerating any Logical Devices it finds attached to the
        bus.  However, there may be times when don't want the enumeration
        process to begin right away.  The most likely reason for this would
        be if you have a Physical Device that needs several seconds to
        "stabilize" before it will enumerate properly.

        I have a USB Printer attached to one of my older computers, and it is
        constantly giving me trouble.  It only initializes and enumerates
        properly about 10% of the time.  When it doesn't enumerate properly,
        I have to reset it (usually multiple times) before it will finally
        start working.  I don't use the computer (or the printer) very often,
        so I just put up with it instead of trying to replace it.  I thought
        that maybe if I just gave the printer more time to "stabilize" before
        I tried to enumerate it, it may work a lot better.  So, I added an
        option switch to USBUHCI{L} to wait a little while before starting to
        enumerate things instead of doing it right away.  Well, as it turns,
        out, it didn't help me at all with my printer -- and it still really
        annoys me when I try to use it.

        In spite of the fact that it didn't help me any, I've left the switch
        option in USBUHCI{L} to delay the start of the enumeration process.
        You may want to try it if you're having problems with a particular
        Physical Device, or if you want to delay things for some other
        reason.  In the option switch, you need to tell USBUHCI{L} how many
        deciseconds to delay (10 deciseconds = 1 second).  The number of
        deciseconds can be between 0 (no delay) and 255 (25.5 seconds).  For
        example, to delay the start of the enumeration process for 3.5
        seconds, you would do a:

           USBUHCIL Pause 35 {other options}

        You must use this option switch when you are first installing
        USBUHCI{L} into memory.  After it has already been installed, it is
        too late to tell it to delay anything.

        While the implementation of this option does not require a lot of
        memory, it does use some, and as a result the USBUHCI{L} TSR uses
        more memory than it would otherwise.  Since the option does not
        appear to do anything useful (at least to me), it may be
        unnecessarily wasting memory.  If nobody provides feedback stating
        that the option is somehow beneficial, it will probably be removed
        when the official (non-beta) release of USBUHCI{L} is issued.







               DOS USB DRIVER INTRODUCTION            Page 63 of 186

        Bus Timing Manipulation
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        The general concept of USB bus Timing is discussed above in the "BUS
        TIMING" section (page 32), and those details will not be repeated
        here.

        USBUHCI{L} provides an option switch that lets you temporarily be the
        "Owner" of the bus Timing.  That is, you can slow down or speed up
        the bus by a small amount (make it run at a slightly different speed
        than the normal 12 Mbps).  You can do this either because of a
        legitimate need, or just to "play around" and see what happens.
        Note, however, that if there is already a program (such as an
        Isochronous Device/Interface Driver) in control of the bus Timing,
        the option switch will not do anything.  UHCI Host Controllers allow
        you to control the bus Timing by setting the number of bits per Frame
        to a number between 11,936 and 12,063.  For example, to change the
        bus Timing from whatever it is to 12050 bits per Frame, you would do
        the following:

           USBUHCI Timing 12050


        Device & Host Manipulation
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        There are several different ways you can "manipulate" Physical
        Devices and Hosts in the USB architecture.  These are discussed in
        various places throughout this document, particularly in the sections
        called "DISABLING & SUSPENDING DEVICES" (page 21) and "STARTING &
        STOPPING HOSTS" (page 24).  Those details will not be repeated here.
        This section is simply intended to detail the option switches you may
        use in USBUHCI{L} to perform those functions.

        The way you specify which specific Logical Device you are trying to
        manipulate is to provide a Device Address.  Recall that a "real"
        Logical Device is always assigned an Address between 2 and 17 (in
        USBUHCIL), or between 2 and 127 (in USBUHCI).  Address 1 is always
        assigned to the Root Hub, which for our discussion here will be
        synonymous with the Host Controller.  That is, Address 1 will
        actually be referring to the logical entity called the Root Hub when
        it is a Hub-related function (such as Suspending Devices), and will
        actually be referring to the logical entity called the Host
        Controller when it is a Controller-related function (such as
        Resetting the Host Controller).

        In addition, we will consider Address 0 to be synonymous with Address
        1 (it will refer to the Root Hub/Host Controller).  Technically,
        Address 0 is the Address temporarily assumed by a Logical Device that
        is in the middle of the initialization & enumeration process, but in
        these option switches we will not use it that way.


               DOS USB DRIVER INTRODUCTION            Page 64 of 186

        As a final point, an Address larger than the maximum allowable
        Address (17 for USBUHCIL and 127 for USBUHCI) will usually perform
        the appropriate function for ALL Host Controllers that are being
        managed, not just the one that is identified with the PCI Search
        Index as declared in the command-line switch.  For example:

           USBUHCIL Index 2 Reset 500

        will Reset all of the Host Controllers that are currently being
        managed (including those with PCI Search Indexes 0 and 1).  This will
        Reset and re-initialize every Physical Device you have.  Compare this
        to:

           USBUHCIL Index 2 Reset 1

        which will just Reset and re-initialize the Host Controller with PCI
        Search Index 2, and:

           USBUHCIL Index 2 Reset 5

        will just Reset the individual Logical Device that has Address 5 on
        the bus associated with PCI Search Index 2.

        Here are the options switches you can use with USBUHCI{L} and a brief
        description of what the option switch does.

           Enable
           ฤฤฤฤฤฤ

           USBUHCI  Enable {0-1}
           USBUHCIL Enable {0-1}
             Starts the Host Controller running normally, whether it was
             Stopped (paused), in Debug Mode, or the Root Hub was in Global
             Suspend mode.

           USBUHCI  Enable {128-65535}
           USBUHCIL Enable { 18-65535}
             Starts ALL Host Controllers running normally, whether they were
             Stopped (paused), in Debug Mode, or the Root Hubs were in
             Global Suspend mode.













               DOS USB DRIVER INTRODUCTION            Page 65 of 186

           USBUHCI  Enable {2-127}
           USBUHCIL Enable {2- 17}
             Enables the appropriate Physical Device if it was Disabled.  A
             Physical Device that was Disabled will NOT start running
             "normally" again by simply Enabling it, however.  It must
             instead be Reset in order to be re-initialized and re-
             enumerated.

             Resumes the appropriate Physical Device if it was Suspended.  A
             Device that was Suspended WILL start running normally again by
             issuing an Enable (or Resume) command.


           Disable
           ฤฤฤฤฤฤฤ

           USBUHCI  Disable {0-1}
           USBUHCIL Disable {0-1}
             Stops the Host Controller from generating frames and sending
             data across the bus.

           USBUHCI  Disable {128-65535}
           USBUHCIL Disable { 18-65535}
             Stops ALL Host Controllers from generating frames and sending
             data across the busses.

           USBUHCI  Disable {2-127}
           USBUHCIL Disable {2- 17}
             Disables the appropriate Physical Device.  To recover from a
             Disable, a Physical Device must be Reset in order to start
             running "normally" again.  Simply Enabling it will not cause it
             to start working.


           Suspend
           ฤฤฤฤฤฤฤ

           USBUHCI  Suspend {0-1}
           USBUHCIL Suspend {0-1}
             Causes the Root Hub to send a Global Suspend signal across the
             bus, putting ALL Physical Devices on the bus into Suspend mode.

           USBUHCI  Suspend {128-65535}
           USBUHCIL Suspend { 18-65535}
             Causes ALL Root Hubs to send Global Suspend signals across ALL
             busses, putting ALL Physical Devices on ALL busses into Suspend
             mode.






               DOS USB DRIVER INTRODUCTION            Page 66 of 186

           USBUHCI  Suspend {2-127}
           USBUHCIL Suspend {2- 17}
             Puts the appropriate Physical Device into Suspend mode.  A
             Physical Device can "recover" from Suspend mode either by
             issuing a Resume or an Enable command.


           Resume
           ฤฤฤฤฤฤ

           USBUHCI  Resume {0-1}
           USBUHCIL Resume {0-1}
             Causes the Root Hub to send a Global Resume signal across the
             bus, Resuming ALL Physical Devices on the bus that are in
             Suspend mode.

           USBUHCI  Resume {128-65535}
           USBUHCIL Resume { 18-65535}
             Causes ALL Root Hubs to send Global Resume signals across ALL
             busses, Resuming ALL Physical Devices on ALL busses that are in
             Suspend mode.

           USBUHCI  Resume {2-127}
           USBUHCIL Resume {2- 17}
             Sends a Resume signal to the appropriate Physical Device.  This
             will cause a Physical Device to "recover" if it was in Suspend
             mode.


























               DOS USB DRIVER INTRODUCTION            Page 67 of 186

           Remote Wakeup
           ฤฤฤฤฤฤฤฤฤฤฤฤฤ

           Some USB Devices support a function called Remote Wakeup.  This
           allows the Device to indirectly issue a Resume signal on the bus
           when the Device is manipulated.  This is discussed in more detail
           above in the "DISABLING & SUSPENDING DEVICES" section (page 21).
           Host Controllers do not provide Remote Wakeup (they are not
           "remote"), only Devices.  Therefore, Addresses 0-1 (Host
           Controller/Root Hub) and Addresses greater than the maximum
           legitimate address (ALL Host Controllers/Root Hubs) are not
           allowed in this option switch.

           USBUHCI  RemoteWakeup {2-127} On|Off
           USBUHCIL RemoteWakeup {2- 17} On:Off
             By default, USBUHCI{L} enables the Remote Wakeup feature in all
             Devices that support it.  This option allows you to manipulate
             (enable or disable) the Remote Wakeup feature for an individual
             Device.  You can view the current state of the Remote Wakeup
             feature with the Addresses option, discussed below in "Attached
             Devices" (page 73).


           Reset
           ฤฤฤฤฤ

           USBUHCI  Reset {0-1}
           USBUHCIL Reset {0-1}
             Causes the Host Controller to perform a complete reset of
             itself, and "reboot" into its default state.  All Physical
             Devices attached to the bus will be Disabled while the Host
             Controller is re-initializing.  After the Host Controller has
             finished Resetting itself, all Physical Devices attached to the
             bus will be re-initialized & re-enumerated.

           USBUHCI  Reset {128-65535}
           USBUHCIL Reset { 18-65535}
             Causes ALL Host Controllers to perform a complete reset of
             themselves, and "reboot" into their default states.  ALL
             Physical Devices attached to ALL busses will be Disabled while
             the Host Controllers are re-initializing.  After the Host
             Controllers have finished Resetting themselves, ALL Physical
             Devices attached to ALL busses will be re-initialized & re-
             enumerated.

           USBUHCI  Reset {2-127}
           USBUHCIL Reset {2- 17}
             Sends a Reset signal to the appropriate Physical Device.  This
             will cause the Physical Device to be Disabled, and then go
             through the entire initialization & enumeration process again.



               DOS USB DRIVER INTRODUCTION            Page 68 of 186

           Configuration Value
           ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

           By default, USBUHCI{L} will configure a Device to configuration
           value 1 during the enumeration process.  Some Devices have more
           than one possible configuration value (though I have personally
           never seen one), and it is also possible to set a Device to
           configuration value 0 (unconfigured).  Host Controllers do not
           support multiple configurations, and cannot be unconfigured (at
           least not in the same sense that Devices are).  Therefore,
           Addresses 0-1 (Host Controller/Root Hub) and Addresses greater
           than the maximum legitimate address (ALL Host Controllers/Root
           Hubs) are not allowed in this option switch.

           USBUHCI  ConfigurationValue {2-127} #
           USBUHCIL ConfigurationValue {2-17}  #
             The configuration value (#) must be a legitimate configuration
             value for the Device, usually 0 (unconfigured) or 1 (default
             configuration).  The Device must be Reset in order to change
             the configuration value, so the reconfiguration process
             inherently includes a Device Reset.  If the Device does not
             accept the requested configuration value, USBUHCI{L} will use
             the default configuration value (1).


           PowerOn, PowerOff, & PowerReset
           ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

           UHCI Host Controllers (Root Hubs) do not support power control.
           Therefore, Addresses 0-1 (Host Controller/Root Hub) and Addresses
           greater than the maximum legitimate address (ALL Host
           Controllers/Root Hubs) are not allowed in these option switches.

           USBUHCI  PowerOn {2-127}
           USBUHCIL PowerOn {2- 17}
             If the Hub that the Physical Device is attached to supports
             per-port-power-control, the Hub will turn on the 5 VDC bus
             power to the Physical Device.  If the Hub does NOT support per-
             port-power-control, this does nothing.

             If the Physical Device is bus-powered, and the power is turned
             off before this PowerOn command is issued, the Physical Device
             will have been disconnected as a result of not having any
             power.  After the Physical Device receives power and becomes
             reconnected to the bus, it will go through the entire
             initialization and enumeration process again.

             If the Physical Device is self-powered, enabling power to the
             Physical Device will have no effect.




               DOS USB DRIVER INTRODUCTION            Page 69 of 186

           USBUHCI  PowerOff {2-127}
           USBUHCIL PowerOff {2- 17}
             If the Hub that the Physical Device is attached to supports
             per-port-power-control, the Hub will turn off the 5 VDC bus
             power to the Physical Device.  If the Hub does NOT support per-
             port-power-control, this does nothing.

             If the Physical Device is bus-powered, turning off power will
             cause the Physical Device to disconnect from the Bus (similar
             to unplugging the Physical Device).  Restoring power to the
             Physical Device (using the PowerOn option switch discussed
             above) will "reconnect" it to the bus, causing it to go through
             the initialization & enumeration process again.

             If the Physical Device is self-powered, disabling power to the
             Physical Device will have no effect.


           USBUHCI  PowerReset {2-127}
           USBUHCIL PowerReset {2- 17}
             If the Hub that the Physical Device is attached to supports
             per-port-power-control, the Hub will turn off the 5 VDC bus
             power to the Physical Device, wait approximately 250
             milliseconds, and then restore power to the Physical Device.
             If the Hub does NOT support per-port-power-control, this does
             nothing.

             If the Physical Device is bus-powered, resetting power will
             have the same effect as unplugging the Physical Device from the
             bus and then re-plugging the Physical Device back in again
             (causing it to go through the initialization & enumeration
             process again).  This is a more "complete" Reset process than
             the "software" Reset discussed a few paragraphs back, since the
             Physical Device will actually lose power during the transition.
             However, a Power Reset requires both that the Hub that the
             Physical Device is attached to supports per-port-power-control,
             and that the Physical Device itself is bus-powered.  Therefore,
             it will only work in certain situations.

             If the Physical Device is self-powered, resetting power to the
             Physical Device will have no effect.












               DOS USB DRIVER INTRODUCTION            Page 70 of 186

           Test Mode
           ฤฤฤฤฤฤฤฤฤ

           USB Devices can support something called Test Mode, which (as the
           name implies) allows the Device to be tested in special ways.
           There is usually not a good reason to put a Device into Test Mode
           unless you are the manufacturer of the Device in a special test
           environment.  Host Controllers have a Debug Mode (discussed
           directly below on page 72), but do not have a Test Mode the way
           Devices do.  Therefore, Addresses 0-1 (Host Controller/Root Hub)
           and Addresses greater than the maximum legitimate address (ALL
           Host Controllers/Root Hubs) are not allowed in this option switch.

           USBUHCI  TestMode {2-127} On|Off
           USBUHCIL TestMode {2- 17} On:Off
             You can view the current state of the Test Mode feature with
             the Addresses option, discussed below in "Attached Devices"
             (page 73).


        Resetting "Bad" Devices
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        A noted in various places in this document, there are times when a
        Device does not enumerate properly and is declared to be "bad".
        Sometimes, a bad Device can be made "good" by simply resetting it,
        causing it to go through the initialization and enumeration process
        again for a second (or third or fourth or ... time).  It can get
        really annoying.

        Normally, to Reset a Device (whether it's good or bad), you must
        provide USBUHCI{L} a specific device Address that you want it to
        Reset, and USBUHCI{L} will Reset that individual Device.  Because
        trying to figure out what the Address of the bad Device is can be a
        little bit cumbersome and annoying, USBUHCI{L} provides a way to
        simply Reset all of the bad Devices at the same time:

           USBUHCIL ResetBadDevices

        This will locate ALL of the bad Devices on ALL of the host
        controllers, and issue Reset requests for them.  Hopefully, after the
        Resets are complete, all Devices will be performing properly.











               DOS USB DRIVER INTRODUCTION            Page 71 of 186

        Note that this does NOT Reset devices that are considered bad by a
        specific device driver (e.g., USBHUB), only those that are considered
        bad by the host driver (USBUHCI{L}).  A device that is considered bad
        by USBUHCI{L} is truly bad (at the USB level), while one that is
        considered bad by a specific device driver may just be incompatible
        with the driver.  For example, the current version of USBHUB will
        reject (declare as "bad") a Hub that has more than 7 ports, even
        though there may be nothing actually wrong with the Hub.


        Debug Mode
        ฤฤฤฤฤฤฤฤฤฤ

        As discussed above in the section called "STARTING & STOPPING HOSTS"
        (page 24), a UHCI Host Controller can be put into Debug Mode.  In
        this mode, the Host Controller is essentially "paused", and is not
        issuing frames or sending data across the bus.  This is actually the
        same thing that happens when the Host is Stopped.

        However, while in Debug Mode, the UHCI Host Controller can be Single-
        Stepped (this cannot happen in Stopped Mode).  Single-stepping the
        Host Controller causes it to generate a single Frame sequence on the
        bus (reading from the Schedule, transmitting packets, generating
        IRQ's as appropriate, etc.).  After the single frame has been
        processed, the Host Stops and is in Debug Mode again.

        To enter Debug Mode, you would do the following:

           USBUHCIL Debug

        To have the Host Controller process a single Frame while in Debug
        Mode, you would do the following (you can do this as many times in a
        row as you want):

           USBUHCIL SingleStep

        To exit Debug Mode, you must re-Enable the Host Controller:

           USBUHCIL Enable 0

        Please do not confuse this Debug option with the ProgramDebug option
        discussed above (page 61).  This Debug option enables the
        Debug/SingleStep mode that is built into the UHCI host hardware,
        while the ProgramDebug option above is designed to help troubleshoot
        installation and uninstallation of the executable program file itself
        (USBUHCI.COM or USBUHCIL.COM).







               DOS USB DRIVER INTRODUCTION            Page 72 of 186

        Attached Devices
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        If you want to see a list of all of the different Logical Devices
        that are attached to the bus, you would do the following:

           USBUHCIL Addresses

        This will list all of the Logical Devices, sorted by Address, along
        with several details about the Device/Interface (the Device/Interface
        "type" or "class", power requirements, manufacturer, which port of
        which Hub the Physical Device is plugged into, etc.).  Most of the
        details that are listed will be fairly self-explanatory, at least if
        you're familiar with the USB architecture.  Some of them need further
        explanation, however.

        In the first column (ADRS - the Logical Device Address), the Address
        may be followed by another character: "T", "r", or "R".  A Logical
        Device Address that has a "T" after it is in Test Mode.  Test Mode is
        used with special testing equipment to verify that everything is
        operating correctly at the electrical level on the bus.  If you ever
        see a Device in Test Mode, and you are not trying to test it with
        special equipment, you (or one of your programs) has done something
        very wrong.  A small R ("r") means the Device/Interface supports
        Remote Wakeup (discussed in "DISABLING & SUSPENDING DEVICES" above,
        page 21), but Remote Wakeup functionality is currently disabled.  A
        capital R ("R") means that Remote Wakeup functionality is currently
        enabled.  By default, USBUHCI{L} enables Remote Wakeup on all
        Device/Interfaces that support it -- you will not normally see an
        "r".

        In the BUS POWR (Bus Power) column, there may be a small S ("s")
        preceding the milliamp number.  The "s" means that the Physical
        Device is self-powered (or at least claims that it is self-powered),
        rather than bus-powered.

        Between the columns labeled AltIn (Alternate Interface) & DESCRIPTION
        (Device/Interface "Class" or "Type"), there are asterisks ("*") in
        some, though not necessarily all, of the rows.  Interfaces (as
        defined in the USB sense -- see the "DEVICES & INTERFACE" section
        above, page 9) can have more than one "configuration", called an
        "Alternate Interface".  Only one Alternate Interface (Interface
        configuration) can be selected at a time for each Interface.  The
        Alternate Interface that is currently selected for an Interface is
        the one with the "*" next to it.  "Simple" Device/Interfaces like
        mice and keyboards usually don't have more than one Alternate
        Interface per Interface, but "complicated" Device/Interfaces (like
        multi-function printers) usually do.





               DOS USB DRIVER INTRODUCTION            Page 73 of 186

        If the Owned column has a "Y", it means that there is a specific
        Device/Interface Driver that "Owns" (is managing and controlling) the
        Device/Interface.  A Device/Interface that is not Owned will not do
        anything useful -- it will just sit there and take up space.  The
        concept of Ownership is critical to the Application Programming
        Interface (API), and is described in a separate document called
        USBAPI.DOC.  It will not be discussed in detail here.

        While a Device is in the middle of the initialization & enumeration
        process, USBUHCI{L} is still trying to figure out all of the details
        about a particular Logical Device (there is no detail yet to show).
        In this situation, the display will just say "Enumerating".  You must
        wait for the enumeration process to complete before any further
        details will be available about the Logical Device.

        If a Logical device was found to be "bad" during the enumeration
        process (see "BAD" DEVICES above, page 48), details about the Logical
        Device will not be shown.  Instead, cryptic details (codes) about
        exactly where and why the enumeration process failed will be shown.
        If you want to research further and possibly troubleshoot the
        problem, you can certainly do that, though this is usually a time-
        consuming, non-trivial process.  You will need to research the "Bad"
        Device detail codes, and compare them to the appropriate sections of
        the Assembly Language source code for USBUHCI{L}.  You can certainly
        learn a lot by doing it, though I would not recommend that road for
        most users.

        In order to list the Address data, USBUHCI{L} calls the support
        programs USBDEVIC (page 84 Below) and VENDORID (page 184 Below).


        New Device Notifications
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        New Device Notifications are one aspect of the Application
        Programming Interface (API), which is described in detail in a
        separate document called USBAPI.DOC.  Specific details will not be
        discussed here.

        A Device/Interface Driver can Register with the API to be
        automatically notified when the Host Driver software on the computer
        has successfully recognized and enumerated a new Logical Device.
        Part of the information provided by the Device/Interface Driver
        during the Registration process is a "filter" for which
        Device/Interfaces it wants to be notified of.  For example, the
        USBMOUSE Driver will Register with a Filter that essentially says,
        "Only notify me if the New Device/Interface is a Mouse -- If it's any
        other kind of Device/Interface, don't bother."





               DOS USB DRIVER INTRODUCTION            Page 74 of 186

        USBUHCI{L} keeps the New Device Notification details in memory (in
        the TSR), and you can view the details as follows:

           USBUHCIL NewDeviceStatus

        The New Device Notification table is actually a feature of the API
        itself, and is not directly associated with a particular instance of
        USBUHCI{L} in memory.  That is, all instances of USBUHCI{L} (and any
        other Host Controller Drivers that are developed in the future) must
        share the same table.  There is only one copy of the table, no matter
        how many instances of USBUHCI{L} you have in memory.

        In order to list the New Device Notification details, USBUHCI{L}
        calls the support program USBDEVIC (page 84 Below).


        Host Controller Hardware Status
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        There are many hardware level details associated with the
        configuration and operation of a UHCI Host Controller.  These include
        various memory & Input/Output resource addresses, Framing details,
        Root Hub Physical Device connection details, Legacy Support
        configuration, etc.  If you want to fully understand everything
        that's involved in running a UHCI Host Controller, you can read the
        UHCI Specification (available from Intel).  We are not going to
        discuss any of those ugly details here.

        However, if you want to view the current hardware configuration
        details of a UHCI Host Controller, you would do the following:

           USBUHCIL HostControllerStatus

        Even without reading the UHCI Specification, some of the information
        provided will probably make sense to you simply based on what you've
        seen so far in this document.  As you might imagine, I've used this
        option switch a LOT as I've been developing the USBUHCI{L} Driver.
        You may find it useful as well, even if just as a simple learning
        experiment to discover more about how USB really works.

        In order to list the UHCI Host Controller hardware configuration
        details, USBUHCI{L} calls the support program USBHOSTS (page 82
        below).










               DOS USB DRIVER INTRODUCTION            Page 75 of 186

        Schedule Status
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        One of the main functions that any USB Host Controller Driver (such
        as USBUHCI{L}) provides is a Schedule.  The Schedule is how the
        software (USBUHCI{L}) tells the hardware (the UHCI Host Controller)
        when and where to send each data packet.  In UHCI Host Controllers,
        this is done with three different data structures: Frame List (FL),
        Transfer Descriptor (TD), and Queue Head (QH).

        The data contained in these data structures is rather cryptic and
        uninteresting, unless you're doing some really "hard-core"
        troubleshooting.  As a rule, you probably won't want to look at these
        details unless you're having serious problems.  Of course, you may
        also be amazed at what you learn if you start looking at these kinds
        of details and try to figure out what it all really means.

        Also keep in mind that when you view these kind of details, you are
        simply looking at a "snapshot" of the data at one particular instant
        in time.  You are not monitoring things on a "real-time" basis.  The
        software and hardware are constantly running and updating the
        Schedule in the background, so you will usually not see the same
        display two times in a row.


           Frame List (FL)
           ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

           The basis of the Schedule is the Frame List (FL).  The FL is a
           data structure located in memory (RAM), which contains 1024
           entries (numbered 0-1023).  Each entry corresponds to a USB Frame.
           USBUHCI{L} places a pointer to the data structure describing the
           data that needs to get sent across the bus (TD or QH) into the
           appropriate place in the FL.  The UHCI hardware reads the
           information from the FL (placed there by the software), and sends
           data packets across the bus accordingly.  When it is time to start
           a new Frame (which happens 1000 times every second), the UHCI
           hardware simply looks at the "next" FL entry, and does whatever
           the Schedule tells it to do.  When the hardware gets to the end of
           the FL (entry number 1023), it simply "rolls over" and starts at
           the beginning again (entry number 0).












               DOS USB DRIVER INTRODUCTION            Page 76 of 186

           The Schedule is set up in the form of a linked list.  An FL entry
           simply contains a pointer (Physical Memory Address) to the first
           TD or QH that the Host hardware needs to process.  After the Host
           hardware finishes processing the first TD/QH, the TD/QH may then
           contain a Link Pointer to another (second) TD/QH, which the Host
           hardware will process.  The second TD/QH may contain a Link
           Pointer to a third TD/QH, etc.  The end of the linked list is
           indicated by a special Termination flag, which essentially tells
           the Host hardware, "the Link Pointer in this TD/QH is not valid --
           we're at the end of the linked list -- you can stop now."

           To view the contents of the Frame List (FL), you would do the
           following:

             USBUHCIL FrameList

           This will display the contents of the Frame List (FL).  However,
           rather than list all 1024 entries, it will only display the ones
           that have a valid TD/QH entry in them.  If you don't have a lot of
           Device/Interface Drivers installed in memory, you probably won't
           see very many items when you display the FL.


           Transfer Descriptor (TD)
           ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

           A Transfer Descriptor (TD) is a data structure located in memory
           (RAM) that describes a single data packet that needs to get sent
           across the bus.  The data structure contains enough information
           that the Host Controller hardware knows exactly what to do with
           the data.  This includes, among other things, where the data is
           coming from and going to (a Physical Memory Address on one end,
           and a Logical Device Address & End Point Number on the other end),
           how many bytes of data to transfer, and a place for the hardware
           to store the status (whether the data was successfully transferred
           or not).

           A TD data structure in RAM also contains information that the Host
           Controller hardware doesn't care about, but that the Driver
           (USBUHCI{L}) needs to know.  This includes the repeat rate
           (Periodicity) if the packet is associated with an Isochronous or
           Interrupt Transaction, a Timeout counter to keep track of a
           "stalled" packet that is taking too long to respond, and what to
           do when the Packet has been completed (which Device/Interface
           Driver to inform).  There is actually quite a bit of information
           associated with each TD.







               DOS USB DRIVER INTRODUCTION            Page 77 of 186

           To view the contents of all the "active" TD's (the TD's that are
           actually doing something), you would to the following:

             USBUHCIL TransferDescriptors

           To view the contents of a particular TD, you would do one of the
           following:

             USBUHCI  TransferDescriptor {0-255}
             USBUHCIL TransferDescriptor {0- 79}

           where the number (0-255 or 0-79) is the index number of the
           specific TD you want to view.  Figuring out the index number can
           be tricky (remember this is really designed for "hard core"
           troubleshooting), but once you figure out what it is, you can
           "track" it.


           Queue Head (QH)
           ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

           A Queue Head (QH) is a data structure located in memory (RAM) that
           describes a group of related data packets (TD's) that need to get
           sent across the bus.  There is a strict limit to the number of
           data bytes that can be sent in a single USB packet.  When there is
           a large amount of data to be transferred, it must be split up into
           a series of smaller, packet-sized "chunks".  The packets must be
           processed in the correct sequence, and if one packet gets
           "stalled" for some reason, the rest of the sequence is also
           "stalled" until the problem gets fixed.  In addition, it may be
           possible for the entire sequence of packets to take a long time to
           transfer, and it is not possible for all of the packets to be sent
           within a single Frame (1/1000 of a second).

           A QH is specifically designed to handle all of these "special"
           data requirements.  USBUHCI{L} uses QH's for Control Transactions
           and Bulk Transactions.  USBUHCI{L} will also use QH's for
           Interrupt Transactions, if the amount of data to be transferred
           will not fit into a single packet.  USBUHCI{L} does not use QH's
           for Isochronous Transactions, or for "small" Interrupt
           Transactions.

           To view the contents of all the QH's, you would do the following:

             USBUHCIL QueueHeads

           As a rule, most of the QH's will be empty (the Element Pointer
           will not point at a TD), since they are generally only used when a
           "large" Transaction is in progress.  Device/Interfaces that
           continuously operate in the background (such as mice and
           keyboards) do not generally use QH's.


               DOS USB DRIVER INTRODUCTION            Page 78 of 186


        Descriptors
        ฤฤฤฤฤฤฤฤฤฤฤ

        One very fundamental concept in the USB architecture is Descriptors.
        All USB Devices have Descriptors, which is how a Device "describes"
        itself to the computer.  Descriptors are how the software (device
        drivers) in the computer know whether the Device is a mouse or a
        keyboard or a printer, how much power it is supposed to use, who
        manufactured the Device, etc.  All Devices have at least 4
        Descriptors, and many Devices have even more than 4.  Unfortunately,
        the Descriptors are all encoded in special formats (numbers), so
        looking at them in their encoded format would not be very useful.
        USBUHCI{L} allows you to look at the Descriptors for any Device
        attached to the bus in a "translated" format that you can understand.

        USBUHCI{L} internally stores the Descriptors of the last Device that
        was enumerated (it needed to download them in order to enumerate the
        Device).  If you want to see the Descriptors of the last Device that
        was enumerated on the bus (usually, but not always, the one with the
        highest address), you simply do:

           USBUHCI Descriptors

        USBUHCI{L} will also download and let you view the Descriptors of any
        Device attached to the Bus, even if it was not the last one
        enumerated.  To do this, you simply follow the Descriptors option
        switch with a number indicating the assigned Address of the Device:

           USBUHCI  Descriptors {2-127}
           USBUHCIL Descriptors {2- 17}

        What's displayed with the Descriptors option switch are the general
        Descriptors, which all USB Devices must have.  In addition, some
        Devices have what are called class-specific Descriptors.  These only
        apply to certain types (classes) of Devices.  For example, there are
        certain items and parameters that you might use to describe a video
        camera, which would mean absolutely nothing if you tried to use them
        to describe a keyboard.














               DOS USB DRIVER INTRODUCTION            Page 79 of 186

        There is a rather large class of Devices that USB calls "Human
        Interface Devices" or HID's, which end up getting used a lot in the
        USB world.  Pretty much anything that you manipulate with your hands
        (mice, keyboards, joysticks, most anything with buttons or wheels,
        etc.) are classified as HID's.  All HID's have a class-specific
        Descriptor called an HID Report Descriptor, which is how the Device
        describes to the computer how many buttons, wheels, axes, etc., it
        has.  Because HID's are so common, and because they can be very
        difficult to write software for, USBUHCI{L} will download and let you
        view the HID Report Descriptor for any HID that is attached to the
        Bus.  To do this, you must provide USBUHCI{L} with both an assigned
        Address number and an Interface number (I#):

           USBUHCI  Report {2-127} I#
           USBUHCIL Report {2- 17} I#

        You can determine the interface number (I#) by using the Address
        option switch (see "Attached Devices" above, page 73).  In many
        cases, the Interface number will be 0 (zero), though that is
        certainly not always true.


        Note that in both cases (general Descriptors and HID Report
        Descriptors), even though the Descriptors are "translated" from raw
        numbers into a meaningful format, it does not necessarily mean you
        will understand what you are seeing.  This is especially true of HID
        Report Descriptors, which are difficult to understand even when you
        are familiar with them.  USB is extremely complicated, and you may
        not understand what all of the different terms mean or why they are
        important.  You will need to read the appropriate USB specifications
        for deeper analysis and understanding.

        In order to display the Descriptors, USBUHCI{L} will use various
        support programs, including USBSUPT1 (page 178), HIDSUPT1 (page 180),
        and VENDORID (page 184).


        Miscellaneous Notes
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        USBUHCI{L} only works with UHCI (Universal Host Controller Interface)
        Host Controllers, which are manufactured by Intel and Via
        Technologies.  The other alternative (for USB version 1.x) is called
        OHCI (Open Host Controller Interface).  OHCI controllers are made by
        all of the other manufacturers except Intel & Via Technologies.  If
        you don't know what kind of USB Host Controller(s) you have (which
        you probably don't), use the USBHOSTS program (page 82 below) to tell
        you.  There are plans to eventually make an OHCI Driver, but it will
        not happen any time soon.




               DOS USB DRIVER INTRODUCTION            Page 80 of 186

        The USB specifications state that there can be no more than 5 levels
        of Hubs between a Physical Device and the Host Controller.  However,
        USBUHCI{L} does not actually track or enforce the number of Hub
        levels.  If there are more than 5 levels of Hubs, but the Physical
        Device still works correctly, USBUHCI{L} will let it continue to
        work.  In practice, there are rarely more than a couple levels of
        Hubs, so this scenario will probably not occur except in some sort of
        special test environment.

        It is commonly recommended by manufacturers that you place their
        Physical Devices as close to the Root Hub as possible (with as few
        "levels" of Hubs between it and the Host as you can).  If you're
        having problems with a particular Physical Device, that is one aspect
        of "troubleshooting".  As a side note, that indicates to me that not
        all Physical Devices are truly USB compatible, nor are they tested
        thoroughly.

        As USBUHCI{L} is assigning Addresses to Logical Devices, it does it
        in a "first available" fashion.  For example, let's say you have a
        Logical Device that is currently assigned Address 5.  If you unplug
        the Physical Device and replug it back in again, or if you issue a
        Reset to the Physical Device, it will go through the complete
        initialization and enumeration process again.  As a result, it will
        be assigned a new Address.  USBUHCI{L} will only assign the same
        address (5) again if addresses 2, 3, and 4 are unavailable (already
        assigned to some other Logical Device).  Many times a Logical Device
        will end up with the same address again after it is re-plugged or
        Reset, but sometimes it won't.  It is never safe to assume that the
        address will remain the same across a re-plug or a Reset.
























               DOS USB DRIVER INTRODUCTION            Page 81 of 186

     USBHOSTS
     ฤฤฤฤฤฤฤฤ

     Version:     0.06
     Prog Type:   Support
     Source Code: ASM (A386 by Eric Isaacson)
     Status:      Complete
     Environment: None
     Redirection: No
     Purpose:     Shows Details of One or All USB Host Controllers
     TSR Memory:  0 kB (not a TSR)


        Showing Host Controller Status
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        The main purpose of USBHOSTS is show details about the different Host
        Controllers that are installed on your computer (UHCI, OHCI, and
        EHCI).  If you run USBHOSTS with no option switches at all, it will
        show you a summary of ALL the Host Controllers that are installed.
        This summary only includes "high-level" (PCI bus related) details of
        the Host Controllers, such as the PCI Search Index (discussed above
        on page 54), manufacturer, IRQ number, PCI base memory or I/O
        address, etc.  Again, to see the summary, you run USBHOSTS with no
        options switches, as follows:

           USBHOSTS

        You can also have USBHOSTS show you virtually ALL of the details for
        an individual Host Controller.  This is includes all of the "high-
        level" information indicated above, as well as Framing details, Root
        Hub Physical Device connection details, Legacy Support configuration,
        etc.  The exact details of what it shows you are VERY different for
        each type of Host Controller (UHCI, OHCI, or EHCI), and we will not
        try to explain any of it here.  You can download and peruse all three
        specifications (they are freely available) if you're interested in
        all of the details.

        To show all of the details for a specific Host Controller, you must
        specify to USBHOSTS exactly which Host Controller you want to see.
        You do this by specifying two pieces of information: a single letter
        indicating the type of Host Controller (U = UHCI, O = OHCI, E =
        EHCI), followed by a number indicating the 0-based PCI Search Index.
        For example:

           USBHOSTS U0

        will show you the details of the first UHCI Host Controller (the one
        with PCI Search Index 0).




               DOS USB DRIVER INTRODUCTION            Page 82 of 186

        You can also have USBHOSTS show you the details of more than one Host
        Controller at a time.  For example:

           USBHOSTS U2 E0

        will show you details of the third UHCI Host Controller, followed by
        details of the first EHCI Host Controller.

        You can also view all of the details for all of the Host Controllers
        as follows:

           USBHOSTS D

        Depending on the exact type of data element that is being shown,
        USBHOSTS will either show you a short word or phrase, a number, a
        "Y", a ".", or a "ฑ".  A word, phrase, or number generally pretty
        self-explanatory.  Here is what the "Y", ".", and "ฑ" indicate:

           Y = Yes, On, True, Enabled
           . = No, Off, False, Disabled
           ฑ = Not Applicable, Unknown

        In order to write the company name of the Host Controller
        manufacturer, USBHOSTS calls the support program VENDORID (page 184
        below).


        Disabling EHCI Host Controllers
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        As discussed in "Disabling the Companion EHCI Host Controller" (page
        59), there are times when it is necessary or desirable to unconfigure
        (disable) a particular high-speed (EHCI) Host Controller.  This in
        turn forces all of the Devices attached to the EHCI Controller to be
        routed to the companion low -speed (UHCI or OHCI) Controller.  This
        is required in certain situations to force the USB hardware to do
        what you want it to do, instead of having it act the way the BIOS or
        hardware manufacturer wants it to.  To unconfigure (Stop) a
        particular EHCI Host Controller, you must provide USBHOSTS with the
        PCI Search Index of the EHCI Host Controller you want to Stop.  E.g.:

           USBHOSTS Stop 0

        will Stop (unconfigure) the first high-speed (EHCI) Host Controller
        (the one with PCI Search Index 0), forcing all of the Devices to
        route to the companion low-speed (UHCI or OHCI) Controller(s).







               DOS USB DRIVER INTRODUCTION            Page 83 of 186

        A single high-speed (EHCI) controller is usually associated with more
        than one low-speed (UHCI or OHCI) companion Controller.  On the Sony
        laptop I currently use, for example, there is one EHCI Controller and
        two companion UHCI Controllers.  On the Dell Desktop I currently use,
        there are two EHCI Controllers each with three companion UHCI
        Controllers (a total of six UHCI Controllers).  What you do to a
        single EHCI Controller usually affects several UHCI (or OHCI)
        Controllers.

        It is not possible to reliably force a single EHCI port to the
        companion low-speed controller using USBHOSTS.  Attempting to do so
        could potentially "break" the EHCI software (in the BIOS) and wreak
        havoc on the entire USB bus.  Rather, what USBHOSTS does is
        unconfigure the entire EHCI host, forcing ALL ports to the companion
        Controller(s).  In addition, once an EHCI Controller is unconfigured
        (Stopped), it is potentially unsafe to simply try and "turn it on"
        (configure it) again.  Therefore, USBHOSTS does NOT provide a way to
        re-configure an EHCI Host Controller that has be unconfigured
        (Stopped).  Once it has been Stopped with USBHOSTS, the only way to
        safely re-start an EHCI Host Controller is to reboot the computer.

        The Stop (unconfigure) option for USBHOSTS should no longer be needed
        once an EHCI Host Controller Driver is completed, though that is not
        expected to happen in the near future.


     USBDEVIC
     ฤฤฤฤฤฤฤฤ

     Version:     0.05
     Prog Type:   Support
     Source Code: C++ (Borland Turbo C++ for DOS 3.0)
     Status:      Complete, a few minor tweaks required
     Environment: None
     Redirection: No
     Purpose:     Show details of attached Physical Devices
     TSR Memory:  0 kB (not a TSR)


     USBDEVIC shows details about all of the different Device/Interfaces that
     are attached to the USB busses.  The details include the assigned
     Address, the Device/Interface "type" or "class", power requirements,
     manufacturer, which port of which Hub the Physical Device is plugged
     into, etc.

     If you run USBDEVIC with no option switches, it will show you the
     details of ALL Device/Interfaces that are attached to ALL busses:

        USBDEVIC




               DOS USB DRIVER INTRODUCTION            Page 84 of 186

     You can also have USBDEVIC show you all Device/Interfaces that are
     attached to a single bus.  To do this, you must provide USBDEVIC the
     Host Index number (0-15) of the Host Controller you are wanting to view.
     For example, to view the details of all Device/'Interfaces attached to
     Host Index 2:

        USBDEVIC 2

     Note that what must be provided is the Host Index number, and NOT the
     PCI Search Index number.  The Host Index number is associated with the
     Host Controller Driver (USBUHCI{L}) and the Application Programming
     Interface (API), not with the PCI bus hardware.

     You can also have USBDEVIC show you the Device/Interface details for
     more than one bus at a time, but not necessarily all of them.  To do
     this, you just provide more than one Host Index number.  The show the
     Device/Interface details for Host Index 2 followed by Host Index 1, for
     example, you would do:

        USBDEVIC 2 1

     Most of the Device/Interface details shown by USBDEVIC are fairly self-
     explanatory, at least if you're familiar with the USB architecture.
     Some of them need further explanation, however.  The explanations are
     provided above under "Attached Devices" (page 73), and will not be
     repeated here.

     In addition to showing you details about the Device/Interfaces attached
     to the bus, USBDEVICE will also show you the contents of the New Device
     Notification table.  The concept of New Device Notifications is a
     complicated aspect of the Application Programming Interface (API), which
     is described in detail in a separate document called USBAPI.DOC.  There
     is also a brief description given above in the "New Device
     Notifications" section (page 74).  Those details will not be repeated
     here.

     To display the contents of the New Device Notification table (stored in
     memory as along with the first instance of USBUHCI{L}), you would do the
     following:

        USBDEVIC NewDeviceTable

     In order to write the company name of the Device/Interface manufacturer,
     USBDEVIC calls the support program VENDORID (page 184 below).  In order
     to write a description of the "type" of Device/Interface, USBDEVIC calls
     the support program USBSUPT1 (page 178 below).







               DOS USB DRIVER INTRODUCTION            Page 85 of 186

     IRQ
     ฤฤฤ

     Version:     1.00
     Prog Type:   Support
     Source Code: ASM (A86 by Eric Isaacson)
     Status:      Complete
     Environment: None
     Redirection: No
     Purpose:     IRQ (Hardware Interrupt) troubleshooter
     TSR Memory:  0 kB (not a TSR)

     There are a total of 16 IRQ's (Interrupt ReQuests) on your computer.  An
     IRQ is also called a Hardware Interrupt, because it is "caused" by a
     hardware device of some sort.  In some contexts, the word interrupt has
     a negative connotation, and is something you usually want to avoid.  In
     a computer, though, an Interrupt is usually a good thing.

     Computers have 16 IRQ's, numbered 0-15.  Some IRQ's are "hard-wired" to
     certain hardware Devices, such as the clocks inside the computer, the
     keyboard, and the math coprocessor.  Others are there for "general use"
     (not hard-wired for a specific purpose), and can be used by most any
     hardware device, including USB Host Controllers.  For an IRQ to be
     useful, it must be "wired" to a hardware device of some sort, and it
     must also be enabled.

     The view the status of the 16 IRQ's on your computer, you run IRQ with
     no option switches:

        IRQ

     This will show you which of the 16 IRQ's are enabled, which are hard-
     wired (and consequently not available for general-use), and what each of
     the general-use ones is commonly (but not always) used for.  For
     instance, IRQ 3 is usually used for serial ports COM2 & COM4.  However,
     IRQ 3 is not REQUIRED to be used for COM2 & COM4 -- it is actually a
     general-use IRQ and can be associated with any type of hardware device.
     Many newer computers only have one serial port (COM1) if they have any
     at all, and modern laptops usually don't have any built-in serial ports
     at all.  An IRQ that is enabled was put that way by the BIOS as the
     computer was booting up, and does have some kind of hardware device
     "wired" to it.  An IRQ that is disabled by the BIOS is probably not
     wired to any kind of hardware device (at least not one that is "turned
     on"), and is available to be used by a hardware device like a USB Host
     Controller.








               DOS USB DRIVER INTRODUCTION            Page 86 of 186

     In addition to just showing you which IRQ's are currently enabled, the
     IRQ program also lets you turn the IRQ's on and off (enable and disable
     them).  This is actually a useful troubleshooting tool in certain
     situations, such as the one I describe above in the "IRQ & I/O
     Resources" section above (page 56).

     To enable a particular IRQ, simply give the IRQ program an IRQ number
     (0-15) as an option switch.  For example, to enable IRQ 4, you would do
     the following:

        IRQ 4

     To disable a particular IRQ, you must give the IRQ program an IRQ number
     followed by any character (any character at all).  For example, to
     disable IRQ 4, you could do either of the following:

        IRQ 4 Disable
        IRQ 4 *

     While the IRQ program will let you enable and disable any of the 16
     available IRQ's (numbered 0-15), you should generally avoid disabling
     IRQ 0 (system timer), 1 (keyboard), and 2 (PIC controller #2).
     Disabling any of these will usually screw up your computer beyond repair
     (you'll need to reboot using the power switch to recover).  Disabling
     (or enabling) any of the other IRQ's will USUALLY not screw anything up
     too badly, but exactly what happens will depend on what hardware (if
     any) is wired to the IRQ.

     As described above in the "IRQ & I/O Resources" section (page 56), I was
     having a problem with the USB Host Controller on my laptop.  Basically,
     the software (as configured by the BIOS) was lying to me about which IRQ
     the USB Host Controller was using.  The software said it was using IRQ 5
     when it was actually using IRQ 7.  The way I found the real IRQ was to
     attach a Legacy Support Device (in my case, a USB Mouse) to the Root
     Hub, which would work as soon as the computer turned on.  I then
     disabled the IRQ's one at a time (using the IRQ program), until I found
     out when the USB Mouse (the USB Host Controller) stopped working.  After
     I figured out what the problem was, I "fixed" it in my AUTOEXEC.BAT file
     so I don't need to remember how to fix it each time.














               DOS USB DRIVER INTRODUCTION            Page 87 of 186

     USBHUB
     ฤฤฤฤฤฤ

     Version:     0.06
     Prog Type:   Device/Interface Driver
     Source Code: ASM (A86 by Eric Isaacson)
     Status:      Complete, a few minor tweaks required
     Environment: USBHUB
     Redirection: Yes
     Purpose:     Driver for up to 16 USB generic version 1.x Hubs
     TSR Memory:  5.7 kB


     USB Hubs are the most basic of Device/Interfaces that you can attach to
     your computer.  In fact, Hubs are so basic to USB busses that they are
     completely defined in the base USB specification -- there isn't a
     separate document needed to specify them the way there is for all other
     Device/Interfaces.

     A USB Hub is a special Device/Interface that effectively "expands" a USB
     bus by creating additional ports.  If the Root Hubs (integrated with the
     Host Controllers) do not have enough ports to support all of the
     Physical Devices you want to plug in, you will need a USB Hub to create
     new ports.  USBHUB is the software driver it takes to enable and manage
     any USB Hubs you have.  If you do not have any USB Hubs installed on
     your computer, or if you do not want to use the Physical Devices you
     have attached to those Hubs (the only Physical Devices you want to use
     are attached to Root Hubs), you do not need to install USBHUB.

     To install USBHUB into memory, you can simply run it with no option
     switches.  Note, however, that at least one instance of USBUHCI{L} must
     be installed in memory before USBHUB can be installed.  For example:

        USBHUB

     USBHUB will enable and manage up to 16 USB Hubs, with up to 7 ports on
     each Hub.  USBHUB will not manage a Hub with more than 7 ports (USBHUB
     will classify a Hub with more than 7 ports as a "bad" Device).

     To have USBHUB display the General Descriptors (Device, Configuration,
     Interface, End Point) of the last Hub that was attached, you would do
     the following:

        USBHUB Descriptors

     In addition to displaying the contents of the General Descriptors, this
     option switch will also display the contents of the class-specific Hub
     Descriptor.  The Hub Descriptor includes specific details about the Hub,
     such as the number of ports and power control characteristics.




               DOS USB DRIVER INTRODUCTION            Page 88 of 186

     To have USBHUB show you the current status of the Hubs that it is
     managing, you would to the following:

        USBHUB Status

     This will display all of the Hubs that are being controlled, as well as
     details about each of the ports on each Hub (power usage, which ports
     have Physical Devices connected, etc.).  The details can be a little bit
     cryptic, so you may want to read the appropriate parts of the USB
     specifications if you need further explanation of what the different
     data items are actually telling you.

     While a New Device is being detected, initialized, and enumerated, there
     is a large amount of interaction that takes place back and forth between
     the Host Controller Driver (USBUHCI{L}) and USBHUB.  If a Logical Device
     fails to enumerate properly for some reason, and it is attached to a Hub
     being managed by USBHUB, you can have USBHUB tell you where and why the
     failure occurred.  You do this as follows:

        USBHUB ExternalStage

     As with most troubleshooting details in these programs, the results are
     rather cryptic.  You will need to correlate the error information
     provided with the Assembly Language source code for USBHUB to figure out
     exactly what happened.  The source code for USBHUB is available if you
     want it, but if you are not familiar with Assembly Language programming,
     it may confuse you more than it helps you.

     Just as a point of clarification, it is not possible to electrically
     "split" or "tap" the USB bus wires to go to two (or more) different
     Physical Devices.  Everything on a USB bus is carefully managed through
     the Host Controller Driver (software), and any "splits" in the bus to go
     to multiple Devices MUST go through a Hub.  Each Physical Device must
     plug into a port that is on either a Root Hub or a managed USB Hub.

     In order to write the contents of the Descriptors, USBHUB calls the
     support program USBSUPT1 (page 178 Below).
















               DOS USB DRIVER INTRODUCTION            Page 89 of 186

     USBKEYB
     ฤฤฤฤฤฤฤ

     Version:     0.09
     Prog Type:   Device/Interface Driver
     Source Code: ASM (A86 by Eric Isaacson)
     Status:      Complete, a few minor tweaks required
     Environment: USBKEYB
     Redirection: Yes
     Purpose:     Driver for up to 4 USB Keyboards
     TSR Memory:  9.2 kB


     USBKEYB is a Device/Interface Driver program for up to four USB
     Keyboards or Keypads ("miniature" Keyboards).  USBKEYB is very unique --
     you cannot find a Keyboard Driver for any other type of DOS USB
     architecture at all.  In the other DOS USB architectures, if you want to
     use a USB Keyboard, you must use the Legacy Support in the BIOS, which
     has certain limitations that USBKEYB does not.

     USBKEYB allows you to have up to four USB Keyboards or Keypads installed
     on the computer at the same time, and any or all of them can be used at
     any time.  You can also have a Legacy (PS2) keyboard installed and use
     it was well.  It might be useful, for example, to have two separate
     keyboards in a game where two players are "shooting" at each other, and
     normally requires both of you to share the same keyboard.  Or, there are
     many accountants and bookkeepers that like a separate Keypad (with just
     numbers and basic math functions) to do their data entry.  Or, it may be
     easier to train someone on the computer if you each have your own
     keyboard, so you're not constantly needing to slide people or chairs or
     keyboards back and forth as you interact.  In short, there are certain
     times when having more than one Keyboard can actually be quite useful.

     Before USBKEYB can be installed into memory, you must first have at
     least one USB Host Driver (USBUHCI{L}) installed in memory.  To install
     USBKEYB into memory, you can simply run it with no option switches:

        USBKEYB


        Typing Methods
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        As you type things on a USB Keyboard, it sends special codes, called
        USB Key Codes, to the computer.  When you type things on a regular or
        Legacy (PS2) keyboard, it sends special codes called Scan Codes to
        the computer.  USB Key Codes and Scan Codes are completely different
        from each other.  Of course, what DOS programs are expecting to see
        are Scan Codes, not USB key codes.




               DOS USB DRIVER INTRODUCTION            Page 90 of 186

        Also, it is important for you to know that Scan Codes are not the
        same thing as ASCII characters, which are what you normally see on
        the screen as you are typing things.  There is another "translation"
        that goes on in the computer to convert Scan Codes (and Scan Code
        combinations) into ASCII characters.  Details of this level of
        translation will not be discussed in this document, but will
        definitely add another level of confusion and complexity into the mix
        as you are trying to figure things out.  You can read the
        documentation for my SCANCODE program if you want more information
        about this.

        What USBKEYB does is take the USB Key Codes as they are coming in
        from the USB keyboard, "translate" them into Scan Codes, and then
        simulates "typing" them into the computer so that they look like they
        came from a Legacy (PS2) keyboard.  If you are familiar with some of
        my other programs (SCANCODE, JOYKEYS, MOUSKEYS), you will probably
        already know what this involves.

        Unfortunately, simulating the typing of keystrokes into the computer
        is a very difficult task, and does not work correctly in all
        circumstances.  Therefore, there are certain times and certain
        programs where you will not be able to use USBKEYB, and will need to
        resort to using a real Legacy (PS2) keyboard OR USB Legacy Support in
        the BIOS.  Hopefully, these situations will be rare (or even non-
        existent) for you.  You should always try to have a Legacy (PS2)
        keyboard laying around, though, just in case.

        USBKEYB has three different Methods of simulating keystrokes into the
        computer, simply called Methods 1, 2, & 3.  Method 1 uses a special
        function built in the keyboard BIOS (hardware) of many modern
        computers.  In other words, for it to work properly, the hardware on
        your computer (motherboard) must be compatible with Method 1.  Of the
        three Methods, Method 1 is usually BY FAR the best and most reliable
        Method to use, and can simulate keystrokes in situations that the
        other two Methods can't.

        Method 2 uses a combination of hardware and software to simulate
        keystrokes.  Similar to Method 1, it requires that the keyboard BIOS
        hardware on the motherboard be compatible with Method 2.  Of the
        three Methods, it is the least likely to work on your computer (it
        has never worked reliably on any of my computers).  Method 2 also has
        the disadvantage that if your hardware is not compatible, attempting
        to simulate keystrokes with Method 2 will sometimes, but not always,
        lock up (crash) the computer.

        Method 3 strictly uses software to simulate keystrokes.  It will work
        on all computers, and does not require any special or compatible
        hardware on the motherboard.  The main disadvantage to Method 3 is
        that it may not work in certain environments, such as if your
        computer switches into DPMI (DOS Protected Mode Interface).



               DOS USB DRIVER INTRODUCTION            Page 91 of 186

        As USBKEYB is installing itself into memory, it performs a relatively
        simple test to determine which of the three Methods it should use to
        simulate keystrokes.  The first test it performs is to see if you
        have provided it an option switch to tell it which Method you want it
        to use.  To have USBKEYB simulate keystrokes using Method 1, for
        example, you would do:

           USBKEYB Method 1

        If you do not provide an option switch when USBKEYB is first
        installing itself into memory, it (internally) attempts to simulate a
        single keystroke using Method 1.  If it works, USBKEYB uses Method 1.
        If Method 1 doesn't work, USBKEYB attempts to simulate a keystroke
        using Method 2.  If it works, USBKEYB uses Method 2.  If Method 2
        doesn't work, USBKEYB simply assumes Method 3 will work (it does not
        actually test it).

        There are four problems that I have seen occur during the testing.
        The first is that your computer crashes while Method 2 is being
        tested (the computer locks up as soon as you try to install USBKEYB
        into memory).  This means that your computer appears to be
        incompatible with Method 1 (if it appeared to be compatible with
        Method 1, USBKEYB would not have tried to test Method 2).  The
        solution is to force USBKEYB to use Method 3, as follows:

           USBKEYB Method 3

        Note that you must do this as USBKEYB is first being installed into
        memory, so it will not try to test Method 2.

        The second problem is that after USBKEYB is installed into memory,
        the USB Keyboard still won't type anything.  This means that the BIOS
        keyboard software on your computer is incompatible with Method 3.
        The solution for that is to replace the BIOS software with some new
        software that is compatible with Method 3.  The easiest way to do
        that is to installed the KEYB program that comes with later versions
        of Microsoft DOS.  Assuming you are using a United States QWERTY
        keyboard, you would do the following for "regular" DOS:

           KEYB US,,C:\DOS\KEYBOARD.SYS

        or the following for DOS 7.x (DOS95 / DOS98):

           KEYB US,,C:\WINDOWS\COMMAND\KEYBOARD.SYS

        You should make the appropriate adjustments to the installation based
        on your keyboard layout, DOS version, and directory structure.  There
        may be other programs besides Microsoft's KEYB program that will do
        the same thing, but the point is that you must COMPLETELY replace the
        BIOS keyboard software on the computer.



               DOS USB DRIVER INTRODUCTION            Page 92 of 186

        The third problem that can occur is for your computer hardware to be
        compatible with Method 1, but your BIOS keyboard software to not be.
        The "patch" to fix this problem is the same as discussed directly
        above -- to replace the BIOS keyboard software.  If Method 1 doesn't
        appear to work on your computer, try installing the Microsoft KEYB
        program.  If this fixes your problem, you're all set.

        The fourth problem is that Method 1 or Method 2 can appear to work OK
        during simple testing, but actually turn out to be unreliable.
        Usually, what will happen with an unreliable Method is that sometimes
        the wrong keystroke will be simulated, or some keystrokes seem to
        simply be "ignored".  Installing the KEYB program will sometimes fix
        these reliability issues as well, but many times you will end up
        needing to force USBKEYB to use Method 3.

        As you are first figuring out how USBKEYB works, you will probably
        need to experiment with different permutations of Methods and
        installation of the KEYB program to find out what works best on your
        computer.  Once you figure it out, edit your AUTOEXEC.BAT and
        environment variables and batch files to automate things
        appropriately so that you don't need to worry about the details every
        time you use your computer.


        Keyboard Mapping
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        As discussed in the previous section, one of the functions that
        USBKEYB must provide is to "translate" USB Key Codes into Scan Codes
        before it can simulate a keystroke.  USB Key Codes and Scan Codes are
        COMPLETELY different from each other, and consequently USBKEYB
        maintains an internal table that contains translation information for
        every single key on the keyboard (more than 100 of them).

        To add further complication, USB actually has two different
        "categories" of Key Codes.  There are "regular" Key Codes (letters &
        numbers, function keys, arrow keys, etc.) and there are "system" Key
        Codes (Sleep, Power, Wakeup, etc.).  In the USB architecture, regular
        keys and system keys are handled completely differently from each
        other, even when they come from the same keyboard.

        The default translation table that is already built into USBKEYB will
        perform translations as appropriate for a standard United States
        QWERTY keyboard.  This includes many of the "multimedia" keys that
        are common on newer keyboards (speaker volume controls, CD player
        start/stop/pause, etc.), as well as the sleep/power/wakeup system
        keys that many newer keyboards also have.






               DOS USB DRIVER INTRODUCTION            Page 93 of 186

        However, if you are not using a US QWERTY keyboard, or if you have
        "unusual" multimedia keys, or just for whatever reason want to change
        the way USBKEYB translates things, there are several option switches
        related to doing that.  Unfortunately, using the option switches
        involves using lots and lots of numbers (as opposed to using
        descriptive words), so it can be very confusing.  Once you figure out
        the option switches to use to do what you want, you should set up
        some batch files or configuration files to automate things and keep
        yourself "un-confused".


           Translating USB Key Codes into Scan Codes
           ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

           To tell USBKEYB to translate a particular USB Key Code into a
           particular Scan Code, you do the following:

             USBKEYB Translate U#, S#

           where U# is the USB Key Code and S# is the Scan Code.  The USB Key
           Code is a single number between 4 and 255, and corresponds to
           Usage Page 7 (Keyboard/Keypad Codes) in the USB Human Interface
           Device (HID) Specification.  You can download the USB Human
           Interface Specification if you want, but you don't actually need
           it to use USBKEYB.  To display a complete list of the defined USB
           Key Codes on the screen to use as a reference, just do the
           following:

             USBKEYB USBKeyCodes

           The S# (Scan Code) can be a single number, two numbers, or three
           numbers, separated by dashes.  The reason it can be multiple
           numbers is very complicated and has lots history behind it, which
           we won't discuss here.  Following are the different ranges of
           numbers you can use for S#:

                  1 thru      95
                 98 thru     127
             224- 1 thru 224- 95
             224-98 thru 224-127
             225-29-69

           To display a complete list of the defined Scan Codes on the screen
           to use as a reference, just do the following:

             USBKEYB ScanCodes







               DOS USB DRIVER INTRODUCTION            Page 94 of 186

           Now, let's do some examples.  When you press the <A> key on a USB
           Keyboard, it generates USB Key Code 4.  By default, USBKEYB
           translates this to Scan Code 30, which is the Scan Code that is
           generated when you press the <A> key on a regular (PS2) keyboard.
           Let's say that, for some reason, when you press the <A> key on the
           keyboard, you actually want the keyboard to type a <Q> (Scan Code
           16).  To have USBKEYB "translate" an <A> into a <Q>, you would do
           the following:

             USBKEYB Translate 4, 16      (4 = USB <A>, 16 = PS2 <Q>)

           To have USBKEYB translate the <A> key on the USB Keyboard into the
           <Enter> key located on the number pad on the right side of the
           keyboard (as opposed to the "regular" <Enter> key in the
           alphanumeric portion of the keyboard), you would do the following:

             USBKEYB Translate 4, 224-28

           If you are only temporarily wanting to perform a translation for
           some special purpose, but then later want to restore the
           translation back to the default US QWERTY translation, you simply
           provide a Scan Code of 0.  For example, assuming you did one of
           the above translations to the <A> key on the USB keyboard, and
           wanted to restore it back to the default translation, you would do
           the following:

             USBKEYB Translate 4, 0

           In the first example above, translating <A> into <Q> probably
           wouldn't be all that useful (you would have two keys that typed
           <Q> and none that typed <A>).  However, actually swapping the <A>
           and <Q> keys might (the <A> becomes <Q> and the <Q> becomes <A>):

             USBKEYB Translate 4, 16 Translate 20, 30   (A->Q, Q->A)



















               DOS USB DRIVER INTRODUCTION            Page 95 of 186

           Translating USB System Codes into Scan Codes
           ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

           To tell USBKEYB how to translate a USB System Key Code (Sleep,
           Power, Wakeup, etc.), as opposed to a "regular" USB Key Code, you
           do the following:

             USBKEYB TranslateSystemCode Y#, S#

           where Y# is the USB System Key Code and S# is the Scan Code.  The
           USB System Key Code is a single number between 129 and 255, and
           corresponds to values in the Generic Desktop Usage page of the USB
           Human Interface Device (HID) Specification.  To display a complete
           list of the defined USB System Key Codes on the screen to use as a
           reference, just do the following:

           USBKEYB USBSystemKeyCodes

           The S# (Scan Code) can be a single number, two numbers, or three
           numbers, separated by dashes.  Following are the different ranges
           of numbers you can use for S#:

                  1 thru      95
                 98 thru     127
             224- 1 thru 224- 95
             224-98 thru 224-127
             225-29-69

           To display a complete list of the defined Scan Codes on the screen
           to use as a reference, just do the following:

             USBKEYB ScanCodes

           For example, if wanted to the <Sleep> key on the USB keyboard (USB
           System Key Code 130) to do the same thing as the <Pause> key, you
           would do the following:

             USBKEYB TranslateSystemCode 130, 225-29-69   (Sleep->Pause)















               DOS USB DRIVER INTRODUCTION            Page 96 of 186

           Setting Up a Keyboard Map
           ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

           If you want to or need to change the keyboard mappings for a USB
           keyboard, you will probably become confused very quickly.  You
           must provide USBKEYB a bunch of numbers that have no real
           significance as you are looking at them, and even a few minutes
           after you do it you probably won't understand what it means any
           more.  I recommend that any time you do keyboard mappings with
           USBKEYB, you do it using a "configuration file" that you load as a
           redirected input file (as discussed above in the "ENVIRONMENT
           VARIABLES & REDIRECTED INPUT" section on page 51).  This will
           allow you to add comments and notes to yourself about what you did
           so that make sense of it all again at some point in the future.

           Figuring out all of the codes it takes to set up the keyboard
           mapping in the first place can be quite challenging and confusing.
           USBKEYB provides some tools to help you figure it all out, and
           once you do figure it out, you should automate the process as much
           as possible with batch and configuration files.

           We have already discussed three of the tools that USBKEYB provides
           to help you figure out how to set up the keyboard mappings.  Here
           they are again:

             USBKEYB KeyCodes

           displays all of the defined USB Key Codes, along with their
           description (the descriptions are only valid for US QWERTY
           keyboards, however).

             USBKEYB SystemKeyCodes

           displays all of the defined USB System Key Codes, along with their
           descriptions.  The descriptions should be valid for all USB
           keyboards.

             USBKEYB ScanCodes

           displays all of the standard Scan Codes associated with a
           "regular" (PS2) keyboard along with their descriptions.  The
           descriptions are only valid for US QWERTY keyboards, however.

           In addition to simply displaying lists of the Codes along with
           their standard (US QWERTY) definitions, USBKEYB also has an option
           switch that lets you view the actual "raw" USB Key Codes that are
           being sent by the USB Keyboard.  To view the raw keyboard data,
           you would do the following:

             USBKEYB RawData



               DOS USB DRIVER INTRODUCTION            Page 97 of 186

           The display will show a total of 16 columns of keyboard data,
           labeled "Shift Codes", "N/A", and "Key 1" through "Key 14".  The
           keyboard has several "Shift" keys (sometimes called "modifier
           keys"), which are bit-mapped into the "Shift Codes" column as
           follows:

             1 = <Left Control>    16 = <Right Control>
             2 = <Left Shift>      32 = <Right Shift>
             4 = <Left Alt>        64 = <Right Alt>
             8 = <Left Windows>   128 = <Right Windows>

           If the "Shift Codes" column reads  1", for example, it means that
           <Left Control> is pressed.  If the  Shift Codes  column reads  5",
           it means that <Left Control> and <Left Alt> are both pressed at
           the same time.

           The "N/A" column is not used, and should always read "0".  "Key 1"
           through "Key 14" are the  regular  (non-shift) USB Key Codes.  As
           a key is pressed, its USB Key Code will appear in one of the
           fourteen columns, and remain there until you release the key.
           According to the USB keyboard specification, USB keyboards are
           supposed to allow up to 6 non-shift keys to be pressed
           simultaneously (the  Key 1" through  Key 6" columns can all have
           legitimate keypress entries in them at the same time).
           Unfortunately, not all keyboards are created equal, and the actual
           number of keys that can be pressed at the same time will vary.
           I ve personally tested keyboards that only support four
           simultaneous key presses (instead of 6 like they re supposed to),
           and have seen documentation for keyboards that claim to support up
           to 14 (though I ve never personally tested any of those).

           In addition to the option switches in USBKEYB, there is also
           included a separate test program called SCANTEST (discussed below
           on page 105).  This is actually an updated version of the SCANTEST
           program I have distributed before with some of my other keyboard-
           related programs.  SCANTEST will display the Scan Codes, along
           with their US QWERTY descriptions, as you press the keys on the
           keyboard.  If you are using a "real" (PS2) keyboard, SCANTEST
           displays the Scan Codes that are coming directly from the
           keyboard.  If you are using a USB Keyboard, SCANTEST displays the
           Scan Codes after they have been "translated" by USBKEYB (or by the
           BIOS, if you are using the keyboard in Legacy Support mode).

           Hopefully, the various tools provided here will allow you to set
           up your USB Keyboard to work exactly as you want it to.








               DOS USB DRIVER INTRODUCTION            Page 98 of 186

           Miscellaneous Notes about Keyboard Mapping
           ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

           The RawData option switch discussed in the previous section allows
           you to view the "raw" USB Key Codes as they are coming from your
           USB Keyboards.  However, there is no option switch that allows you
           to view the raw USB System Key Codes as they are coming from the
           USB Keyboard.  There are very few USB System Key Codes, and they
           are sent using a completely different mechanism and protocol than
           the regular USB Key Codes are.  USB System Keys should be much
           easier to figure out and process, and therefore no special option
           switch was provided.

           To view the current "custom" keyboard mapping status (which USB
           Key Codes and USB System Key Codes are mapped to which Scan
           Codes), you would do the following:

             USBKEYB Status

           This shows you several details about how USBKEYB is currently
           configured, including any special keyboard mapping sequences you
           have told USBKEYB to use.  Note that this does not display the
           "default" keyboard mappings -- it only displays the ones you have
           told USBKEYB to use with the Translate or TranslateSystemCode
           option switches.

           USBKEYB allows you to enter special keyboard mappings for up to
           100 USB Key Codes, and up to 16 USB System Key Codes.  This is
           enough to remap virtually the entire keyboard.

           If you have multiple USB Keyboards attached to the computer, all
           of them must use the exact same keyboard mapping.  There is a
           single mapping table that is used for all Keyboards.  If you are
           in the unusual situation of having more than USB Keyboard and they
           have different layouts, you will need to load a new configuration
           file if you switch keyboards.

           The USB documentation is very unclear (at least to me) on how
           keyboard layouts other than US QWERTY are supposed to work.  I've
           never used (or even seen) a USB keyboard other than US QWERTY, so
           I'm not sure how to even begin to set up a translation table for
           one of them.  If you have a USB Keyboard layout for some kind of
           foreign keyboard, and get the translation table figured out, you
           can send a copy of the configuration file to me and I will make it
           available for distribution from my web site.  If you do this,
           please include LOTS of comments (including your name and contact
           information) in the configuration file to make it as useful to
           other people as possible.





               DOS USB DRIVER INTRODUCTION            Page 99 of 186

        Processing Special Keys
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        There are certain keys and keystroke combinations on a keyboard that
        are processed differently in the BIOS than most of the other keys
        are.  Most of the time, the way that they are processed is perfectly
        acceptable, and there is no need to change it.  However, USBKEYB can
        replace the default (BIOS) processing for some particular keystrokes
        to allow them to work "better" in certain situations.

        The first keys that USBKEYB can process are the "Lock Keys" (<Caps
        Lock>, <Num Lock>, and <Scroll Lock>).  Through experimentation, I
        have discovered that sometimes when USBKEYB is installed in memory,
        and you press one of the "Lock Keys", the "real" (PS2) Keyboard
        becomes disabled and stops working while the USB Keyboards continue
        to work just as they should.  I have no idea why this happens, or why
        it is only a problem on certain computers.  By default, USBKEYB will
        replace the default (BIOS) processing for the "Lock Keys" so that
        this problem does not occur.  However, USBKEYB lets you turn this
        feature off if you want to for some reason, to allow the BIOS to
        process the "Lock Keys" itself.  To disable the "Lock Key" processing
        in USBKEYB, you would do the following:

           USBKEYB ProcessLockKeys: No

        To turn the USBKEYB processing back on again, you would do the
        following:

           USBKEYB ProcessLockKeys: Yes

        There is normally not a good reason to turn this feature off, unless
        you have a program that performs some special processing of the "Lock
        Keys", or if you just want to experiment to see if your particular
        computer has the problem or not.

        The second keystroke combination that USBKEYB will process for you is
        <Control>-<Alt>-<Delete>, which normally reboots the computer.
        <Control>-<Alt>-<Delete> does not work correctly on some computers,
        and will sometimes lock up the computer instead of rebooting it.
        USBKEYB's handling of the reboot combination is usually "better" than
        the default (BIOS) handling, but is still not perfect (it can
        sometimes not work properly, either).  By default, USBKEYB will
        replace the default (BIOS) processing for the <Control>-<Alt>-
        <Delete> combination.  To disable the <Control>-<Alt>-<Delete>
        processing in USBKEYB, you would do the following:

           USBKEYB ProcessReboot: No






              DOS USB DRIVER INTRODUCTION            Page 100 of 186

        To turn the USBKEYB processing back on again, you would do the
        following:

           USBKEYB ProcessReboot: Yes

        There is normally not a good reason to turn this feature off, unless
        you have a program that performs some special processing of the
        <Control>-<Alt>-<Delete> keystroke combination (such as certain
        network control programs).

        The third keystroke that USBKEYB will process for you is the <Pause>
        key.  Normally, when you press the <Pause> key, the computer will
        temporarily stop (pause) whatever it's doing until you press another
        key on the keyboard.  When you press the second key, the computer
        will un-pause and start running again.  With the default (BIOS)
        processing in place, the second (un-pause) key can be any key except
        another <Pause> key.  This is actually very inconvenient, since the
        way you usually use the <Pause> key is to temporarily stop and start
        a continuous dump of data that keeps scrolling off the top of the
        screen before you can read any of it.  With the default processing,
        you have to keep moving your hand back and forth between the <Pause>
        key and a key located somewhere else on the keyboard.

        When USBKEYB is processing the <Pause> key, the <Pause> key can be
        used as the second (un-pause) key.  That way, you can keep your hand
        in the same place and just keep pressing the same key to stop and
        start the screen scrolling.  To disable the <Pause> key processing in
        USBKEYB, you would do the following:

           USBKEYB ProcessPause: No

        To turn the USBKEYB processing back on again, you would do the
        following:

           USBKEYB ProcessPause: Yes


        Changing the Typeamatic Rate
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        USBKEYB does not provide any option switches to control the
        typeamatic delay and repeat rates of the USB Keyboard (how fast the
        keyboard types a repeating keystroke if you continue to hold the same
        key down for a long time).  Rather, USBKEYB responds to the standard
        BIOS requests that are designed to control the keyboard.  The most
        common way of controlling the typeamatic rate of the keyboard is by
        using the MODE utility that comes with DOS.  For example, to set the
        typeamatic rate to the fastest it can be (repeat rate = 30 cps, delay
        = ฌ second), you would do the following:

           MODE CON: RATE=32 DELAY=1


              DOS USB DRIVER INTRODUCTION            Page 101 of 186

        There is one issue you need to be aware of concerning the typeamatic
        rate, however.  The keyboard BIOS on all computers supports the "Set
        Typeamatic Rate" function, which is what the MODE utility uses.  All
        computers are also SUPPOSED to support the "Get Typeamatic Rate"
        function, but unfortunately not all of them do.  As USBKEYB is
        installing itself into memory, it asks the keyboard BIOS what the
        typeamatic rate setting of the PS2 keyboard is by issuing a "Get
        Typeamatic Rate" request.  If the keyboard BIOS supports the request,
        USBKEYB will set its typeamatic rate to be the same as the PS2
        keyboard.

        However, if the keyboard BIOS does not support the "Get Typeamatic
        Rate" function, USBKEYB has no idea how the PS2 keyboard typeamatic
        rate is configured.  In that case, USBKEYB simply uses the same
        default settings as a PS2 keyboard normally uses (repeat rate = 10
        cps, delay = ซ second).  Of course, most people change the keyboard
        typeamatic settings in the CMOS/BIOS startup settings of the
        computer, so computers rarely boot up with the default typeamatic
        settings still intact.  So, if your computer does not support the
        "Get Typeamatic Rate" function (which it probably doesn't), your USB
        keyboards and PS2 keyboard will not be typing at the same speed.

        The remedy for this situation is relatively simple, though is a bit
        of a hassle to set up.  What you need to do is run the MODE utility
        to change the typeamatic rate AFTER you install USBKEYB into memory.
        If you do this, the PS2 keyboard and all of the USB Keyboards will be
        configured the same way.  For instance, you could do the following
        (presumably, you would do this in a single batch file which would
        automate the entire process):

           USBKEYB
           MODE CON RATE=32 DELAY=1

        Incidentally, while USBKEYB is installed in memory, it fixes the "Get
        Typeamatic Rate" function so that it works properly in case other
        programs need to use it.


        Enabling & Disabling Keyboards
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        By default, all USB keyboards are enabled (turned on) by USBKEYB.
        However, USBKEYB will let you enable (turn on) and disable (turn off)
        each of the individual USB keyboards.  You may want to disable a
        particular keyboard, for example, while you are not using it but it
        is in a location where it accidentally gets bumped all of the time.
        To Disable a particular keyboard, you must provide a USB Keyboard
        Index number (between 0 and 3).  For example, to Disable the first
        USB Keyboard (Index 0), you would do the following:

           USBKEYB Disable 0


              DOS USB DRIVER INTRODUCTION            Page 102 of 186

        To re-enable the second USB Keyboard (Index 1), you would to the
        following:

           USBKEYB Enable 1

        You can also Disable or Enable all four USB Keyboards at the same
        time, by specifying Keyboard Index 255 (instead of 0-3).  For
        example, to Disable all four USB Keyboards, you would do the
        following:

           USBKEYB Disable 255

        It is extremely important that you have some sort of keyboard working
        on your computer, or else you won't be able to do much of anything
        useful.  Therefore, you should not even attempt to Disable your USB
        Keyboard unless you have "real" Keyboard (PS2 or USB in Legacy Mode)
        in place that you can use instead.  Therefore, if USBKEYB doesn't
        think that you have a "backup" keyboard installed, it will not allow
        you to Disable any of the USB Keyboards.

        By default, USBKEYB assumes that you DO have a "real" keyboard and
        that it is OK to Disable the USB Keyboards.  However, there is no way
        that USBKEYB can tell for sure if you have a "real" keyboard or not.
        Therefore, if you do not have a "real" keyboard, and you want to make
        sure that you cannot accidentally turn off your only (USB) Keyboard,
        you would do the following:

           USBKEYB RealKeyboard:No

        To reverse this setting and tell USBKEYB to start assuming that you
        have a "real" Keyboard again, you would do the following:

           USBKEYB RealKeyboard: Yes


        Descriptors
        ฤฤฤฤฤฤฤฤฤฤฤ

        To display the General Descriptors (Device, Configuration, Interface,
        etc.) of the last keyboard that was configured by USBKEYB, you would
        do the following:

           USBKEYB Descriptors










              DOS USB DRIVER INTRODUCTION            Page 103 of 186

        A USB Keyboard is also part of a larger USB classification called
        Human Interface Devices (HID's), and therefore has a special
        Descriptor called an HID Report Descriptor.  The HID Report
        Descriptor "describes", among other things, how many buttons and
        LED's the keyboard actually has.  To display the HID Report
        Descriptor of the last keyboard that was configured by USBKEYB, you
        would to the following:

           USBKEYB ReportDescriptor


        Miscellaneous Notes
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        To have USBKEYB show you the current status of the USB keyboards that
        it is managing, you would to the following:

           USBKEYB Status

        This will display "general" information about the USB keyboards (such
        as typing method and typeamatic settings).  It will also display any
        custom key mapping you have in place for either the "standard" USB
        Keys or the USB System Keys.  In addition, it will also display
        details for each of the individual USB keyboards you may have
        installed (such as Host Index & Device Address).  If something is not
        working quite right with one of the keyboards, running USBKEYB with
        the Status option switch will usually be where you start your
        troubleshooting path.

        While USBKEYB is installed in memory, it provides a BIOS-level
        Application Programming Interface (API) that allows other programs to
        simulate keystrokes (Scan Codes) the same way that USBKEYB does.
        Details of the API are rather lengthy and complicated, and will not
        be discussed here.  They will be discussed in the official
        documentation for USBKEYB, to be released some time in the future.
        If you want to review how the API works before the official
        documentation is released, you can freely download and peruse the
        source code for USBKEYB.

        USBKEYB is not a "perfect" keyboard driver -- there are certain
        situations and environments and programs where it does not work
        correctly.  Hopefully, it will work in every situation where you need
        it to work.  However, if it does not, you will probably need to leave
        the USB keyboard in Legacy Support mode, and let the BIOS manage the
        keyboard instead of USBKEYB.  Legacy Support has many limitations
        that USBKEYB does not (and vice versa), and which one is the most
        appropriate for you to use will depend on your particular hardware
        and software needs and capabilities.





              DOS USB DRIVER INTRODUCTION            Page 104 of 186

        Keyboards sometimes send certain keys (multimedia keys and "system"
        keys) in unusual ways that USBKEYB does not understand.  In the
        future, the DOS drivers will be improved to add support for these
        "unusual" keyboards.  In the meantime, you should be able to use all
        of the "regular" keys (compatible with standard 101/102 PS2
        keyboards) with no problem.


     SCANTEST
     ฤฤฤฤฤฤฤฤ

     Version:     1.10
     Prog Type:   Test
     Source Code: ASM (A86 by Eric Isaacson)
     Status:      Complete
     Environment: None
     Redirection: No
     Purpose:     Keyboard tester
     TSR Memory:  0 kB (not a TSR)


     SCANTEST is a low-level keyboard testing program.  It's included here as
     a "companion" program to help you test and configure USBKEYB (discussed
     above on page 90), but you can use it test any kind of keyboard.  This
     version of SCANTEST is actually a slightly updated version of the
     SCANTEST that was included with one of my other programs (SCANCODE) that
     was last released several years ago.  The updates added to this version
     include descriptions for several of the "multimedia" keys on the
     keyboard (volume controls, CD player play/pause, etc.), an indicator for
     "repeating" keystrokes (typeamatic repeats), and support for Long File
     Names in the output.  If you've used earlier versions of SCANTEST, the
     differences are relatively minor and will probably not be all that
     obvious to you.

     When you run SCANTEST, it "intercepts" every keystroke you type from the
     keyboard, and displays the Scan Code of the keystroke (a number or a
     series of numbers), along with a description of the keystroke.  Note
     that the description is only valid for United States QWERTY keyboards,
     so if that's not the kind of keyboard you're using, the descriptions
     will probably be different than what you're expecting.  The Scan Code
     numbers displayed will always be correct, no matter what kind of
     keyboard you have.  To exit the SCANTEST program, simply press <Escape>
     on the keyboard.










              DOS USB DRIVER INTRODUCTION            Page 105 of 186

     It is important that you realize that SCANTEST is a low-level program,
     and what is displays are the Scan Codes that are coming from the
     keyboard, and are NOT the ASCII characters that usually appear on the
     screen as you are typing.  Scan Codes and ASCII characters are
     COMPLETELY different animals, and there is no direct relationship
     between the two.  You can read the documentation for my SCANCODE program
     if you want to investigate this further -- we will not discuss it in
     detail here.

     The only option switch SCANTEST provides is the ability to "tee" the
     displayed output to both the screen and to another location (DOS file or
     device) at the same time.  For instance, let's say you intend to have a
     long SCANTEST "session", and you would like to remember the entire
     session by sending everything that gets displayed on the screen to the
     printer (LPT1:).  To accomplish this, you would start SCANTEST the
     following way:

        SCANTEST LPT1:

     If you do this, everything that SCANTEST displays on the screen will
     also be sent to LPT1:.

     You can "tee" the output to almost any DOS device or file you want to,
     not just the printer.  Here are a some examples:

        SCANTEST C:\SCANTEST.TXT
        SCANTEST "C:\My Documents\ScanTest.Out"

     Obviously, the second example above will only work if you're currently
     working in an environment that supports Long File Names (LFN's).

     The one Device that you cannot "tee" the output to is the CON: Device,
     because it is the same thing as the screen.  That is, you cannot send
     the output to the screen (CON:), and then try to "tee" the output to the
     same place (the screen or CON:).  I can't imagine anybody trying to do
     this (at least not on purpose), but if you do SCANTEST will generate an
     error.
















              DOS USB DRIVER INTRODUCTION            Page 106 of 186

     USBMOUSE
     ฤฤฤฤฤฤฤฤ

     Version:     0.10
     Prog Type:   Device/Interface Driver
     Source Code: ASM (A86 by Eric Isaacson)
     Status:      In progress, several major items to address
     Environment: USBMOUSE
     Redirection: Yes
     Purpose:     Driver for up to 8 USB Mice
     TSR Memory:  7.9 kB


     USBMOUSE is a Device/Interface Driver program for up to eight USB Mice.
     Most other DOS USB architectures do not provide any mouse support at
     all, or if they do, it is very limited and virtually useless.  If you
     want to use a USB mouse with the other DOS USB architectures, you must
     usually use the Legacy Support in the BIOS, which has certain
     limitations that USBMOUSE does not.

     USBMOUSE allows you to have up to eight USB Mice installed on the
     computer at the same time, and any or all of them can be used at any
     time.  You can also have a Legacy (PS2) mouse installed and use it was
     well.  On a "shared" computer that many different people use, for
     example, it might be useful to have left-handed and right-handed mice,
     trackballs, touchpads, etc., instead of forcing every user to use the
     exact same mouse.  Or, if there is a training session going on, it might
     be useful to have both the trainee and the trainer each have their own
     mouse so that they're not constantly shifting things back and forth to
     be able to both use the same mouse.  Having more than one mouse on a
     computer is actually quite useful in certain situations.

     Before USBMOUSE can be installed into memory, you must first have at
     least one USB Host Driver (USBUHCI{L}) installed in memory.  To install
     USBMOUSE into memory, you can simply run it with no option switches:

        USBMOUSE


        DOS Mouse Drivers
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        In order to use a mouse with most DOS programs, you must install a
        program called a DOS Mouse Driver.  The most common one is probably
        Microsoft's MOUSE.EXE, which comes with many later versions of DOS.
        MOUSE.EXE is certainly not the only DOS Mouse Driver available, and,
        at least in my opinion, is certainly not the best one, either.






              DOS USB DRIVER INTRODUCTION            Page 107 of 186

        I think the best DOS Mouse Driver available is CTMOUSE, which you can
        download for free (http://cutemouse.sourceforge.net).  As far as I
        know, it is the only DOS Mouse Driver that is still being updated,
        and uses much less memory (RAM) than any other mouse driver I have
        seen.  All of the "big names" in the mouse business (Microsoft,
        Logitech, Mouse Systems, etc.) stopped updating their memory-
        intensive DOS Mouse Drivers a long time ago.

        The main purpose of a DOS Mouse Driver (like CTMOUSE) is to provide a
        common interface to DOS programs that want to use a mouse.  Even in
        the early days of computing, there were are least two different ways
        to attach a mouse to the computer: with a special card that plugged
        into one of the expansion slots (called a Bus Mouse), or with a
        serial port like an external modem uses (called a Serial Mouse).  A
        little later on, PS2-attached mice were developed, and eventually
        that became the most popular way, by far, to attach mice.  The DOS
        Mouse Driver understands how each of the three different hardware
        protocols works (Bus, Serial, and PS2), and provides a simple
        interface that DOS programs can use to control the mouse.  The DOS
        program doesn't know (or care) how the mouse is attached to the
        computer or which hardware protocol is being used -- it just needs to
        understand how the DOS Mouse Driver works.

        In the time since the mouse manufacturers stopped updating their DOS
        Mouse Drivers, new ways of attaching mice have emerged.  The most
        popular ways now are USB and Bluetooth, which use completely
        different protocols than each other and than any of the previous
        attachment methods (Bus, Serial, and PS2).  In the future, there may
        be even more new ways of attaching mice that will eventually replace
        USB and Bluetooth.  The DOS Mouse Drivers that stopped development
        before USB and Bluetooth became popular (all of them except CTMOUSE)
        will never be able to work natively with the newer mouse hardware.

        USBMOUSE is NOT a DOS Mouse Driver, and is NOT a replacement for a
        program like CTMOUSE.  Even if you have USBMOUSE installed, you still
        need a DOS Mouse Driver like CTMOUSE in order to actually make the
        mouse do something useful.  However, even CTMOUSE (the most modern
        DOS Mouse Driver available) does not understand how USB mice work --
        it only understand Bus, Serial, and PS2 mice.  That's where USBMOUSE
        comes in.

        What USBMOUSE does is "talk" to the USB Mice using the native USB
        protocol, and then emulates a PS2 mouse in the computer's BIOS.
        USBMOUSE makes CTMOUSE think it is talking to a PS2 mouse, when it's
        actually talking to a USB mouse.  Because CTMOUSE is still being
        developed and updated, it may eventually include native support for
        USB mice.  However, even if it doesn't, it will still be possible to
        use USB mice in DOS thanks to USBMOUSE.





              DOS USB DRIVER INTRODUCTION            Page 108 of 186

        PS2 Mouse BIOS
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        In the early days of computers, there were two kinds of mice: serial
        (which plugged into the same kind of serial port that a modem uses)
        and bus (which required a special card that plugged into the
        expansion bus).  Later on, when IBM developed the PS2 interface for
        mice (and keyboards), it also developed a standard BIOS-level
        (software) interface for the mouse.

        Development of a standard software interface for the mouse should
        have been a huge step forward for mouse developers, since they could
        now use almost any proprietary hardware mechanism they wanted and
        still have programs be able to work with the mouse.  The DOS Mouse
        Drivers simply need to "talk" to the mice using the PS2 BIOS software
        interface, and it doesn't matter how the mouse actually works at the
        hardware level.

        Unfortunately, every mouse manufacturer I know of developed their DOS
        Mouse Driver to interact directly with the PS2 mouse hardware, rather
        than interacting with the PS2 BIOS software.  As a result, those DOS
        Mouse Drivers are now virtually useless, since they cannot work with
        the new mice (like USB and Bluetooth and whatever else develops in
        the future) that don't use the PS2 hardware interface.

        CTMOUSE is the only DOS Mouse Driver I know of that interacts with a
        PS2 mouse at the BIOS level rather than the hardware level.
        Therefore, CTMOUSE is also the only DOS Mouse Driver I know of that
        is even capable of working with newer mice, like USB and Bluetooth.
        One thing to keep in mind, however, is that you must use CTMOUSE
        version 1.9 or earlier, or version 2.1 or later.  For a while,
        CTMOUSE got "off track", and version 2.0 only interacts directly with
        the PS2 mouse hardware.  With version 2.1 they are back to using the
        BIOS which is the "right" way to do things (as far as I'm concerned,
        anyway).

        USBMOUSE emulates a PS2 mouse in the BIOS of the computer.  Any DOS
        Mouse Driver that interfaces with the PS2 mouse at the BIOS
        (software) level instead of at the hardware level should work with
        USBMOUSE.  Unfortunately, the only DOS Mouse Driver I know of that
        actually does that is CTMOUSE.  If there is another one out there, I
        would certainly like to know about it.











              DOS USB DRIVER INTRODUCTION            Page 109 of 186

        IntelliMouse Protocols
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        Back in the early days, mice were different than they are today.
        Most mice only had two buttons, though some had three buttons.  None
        of the mice had the scrolling wheels that nearly all modern mice
        have.  Back then, the protocol that was used to transfer data between
        the mouse and the computer only allowed for at most three buttons,
        and did not have enough room to transfer the extra data required by a
        wheel even if the mouse had one.

        Somewhere along the line, somebody thought it would be a good idea to
        add a vertical scrolling wheel to a mouse.  Of course, the original
        protocol didn't have enough room for the data associated with the
        wheel, so Microsoft created the IntelliMouse protocol.  Later yet
        again, somebody decided that even more would be better, and thought
        that mice should have two scrolling wheels (a horizontal as well as a
        vertical) and five buttons (instead of just two or three).  As a
        result, Microsoft created the IntelliMouse2 protocol (actually, I
        don't know what the official name is, but I call it IntelliMouse2).

        The three protocols (PS2, IntelliMouse, and IntelliMouse2) are
        completely incompatible with each other.  That is, the software (DOS
        Mouse driver, like CTMOUSE) must know which kind of mouse (which
        protocol) is being used by the mouse.  All PS2 mice, whether they
        support the IntelliMouse(2) protocols or not, initialize themselves
        in PS2 mode (the protocol that cannot support any wheels).  If the
        software (DOS Mouse Driver) understands how the IntelliMouse protocol
        works, it will then "ask" the mouse hardware if it supports the
        IntelliMouse protocol.  If the mouse hardware does, the software and
        hardware will then use the IntelliMouse protocol to communicate with
        each other.  If the software understands how the IntelliMouse2
        protocol works, it will then "ask" the mouse hardware if it supports
        the IntelliMouse2 protocol.  If the mouse hardware does, the software
        and hardware will use the IntelliMouse2 protocol to communicate with
        each other.

        By progressing this way (from PS2 to IntelliMouse to IntelliMouse2),
        the software (DOS Mouse Driver) controls how many wheels and buttons
        are actually available to be used.  So, even if the mouse has a
        wheel, if the DOS Mouse Driver doesn't understand the IntelliMouse
        protocol, you'll never be able to use the wheel to do anything
        useful.  The popularity of scroll wheels on mice happened well after
        all of the mouse hardware manufacturers stopped updating their DOS
        Mouse Drivers, so none of the OEM DOS Mouse Drivers have support for
        scrolling wheels.  The only DOS Mouse Driver I know of that includes
        support for any wheels at all is CTMOUSE, and it only understands the
        IntelliMouse protocol.  It does not understand the IntelliMouse2
        protocol (at least not yet), so does not support a second wheel or
        more than 3 buttons.  But this is still far better than any other DOS
        Mouse Driver available, which don't support any wheels at all.


              DOS USB DRIVER INTRODUCTION            Page 110 of 186

        Even if you use CTMOUSE, which understands and supports a scrolling
        wheel, it still doesn't mean you'll be able to do anything with the
        wheel.  In addition to the mouse hardware and the DOS Mouse Driver,
        the particular DOS program you're using must also understand and
        support scrolling wheels.  There aren't very many new DOS programs
        being written or updated these days, and there are only a few that
        are able to do anything with a scrolling wheel.  The CTMOUSE web site
        (http://cutemouse.sourceforge.net) lists some programs that are able
        to use the scrolling wheels.

        Also note that even if a mouse supports the IntelliMouse protocol, it
        doesn't necessarily mean it actually has a scrolling wheel, or even
        that it actually has three buttons.  It just means that it MAY have a
        scrolling wheel.  Likewise, support of the IntelliMouse2 protocol
        doesn't necessarily mean the mouse actually has two wheels and five
        buttons, it just means that the mouse MAY have that many.  The
        IntelliMouse and IntelliMouse2 protocols don't provide a way for the
        mouse to tell the computer how many buttons or wheels the mouse
        actually DOES have, only how many it MAY have.


        PS2 Mouse Hardware Emulation
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        In spite of the previous statements about only emulating the mouse at
        the BIOS (software) level, USBMOUSE is also able to emulate the PS2
        mouse hardware under certain circumstances.  Unfortunately, even
        though the hardware emulation does in fact work, there are still many
        problems with it and I do not recommend using mouse hardware
        emulation.

        PS2 keyboards and PS2 mice actually use the exact same control
        hardware inside the computer.  The PS2 mouse is treated as sort of an
        "extension" of the keyboard, and is not really a truly separate
        device.  When USBMOUSE is attempting to emulate the PS2 mouse
        hardware, for some reason, it also affects the PS2 keyboard.  That
        is, when USBMOUSE is in hardware emulation mode, the mouse usually
        works just fine, but your keyboard doesn't work correctly any more.
        On my computers, sometimes two keystrokes are generated when you only
        pressed the key one time, some keystrokes are simply ignored when you
        type them, sometimes the keyboard beeps annoyingly at you when you
        press keys, and the keyboard seems especially sluggish and
        unresponsive.  I have no idea why any of this happens, and have not
        been able to resolve it.









              DOS USB DRIVER INTRODUCTION            Page 111 of 186

        Even though the mouse hardware emulation has "bugs" in it, I am
        leaving it installed in USBMOUSE.  You may find it useful in certain
        situations, such as in a program that uses the mouse but doesn't use
        the keyboard.  Hardware emulation could also, at least theoretically,
        let you use your USB Mouse in a program that "bypasses" the DOS Mouse
        Driver and interacts directly with the PS2 mouse hardware (there are
        a few of those kinds of programs around).

        In addition, when USBMOUSE is using hardware emulation instead of
        BIOS (software) emulation, you cannot control the PS2 mouse.  For
        instance, the options discussed below allow you to disable and enable
        (turn off and on) individual mice, exchange the left & right mouse
        buttons, view the "raw" data that is coming from the mouse, etc.  In
        BIOS (software) emulation mode, USBMOUSE also controls the "real" PS2
        mouse data, and can do all of these things with the PS2 mouse
        (disable, exchange buttons, etc.).  However, in hardware emulation
        mode, USBMOUSE does not control the PS2 mouse, and the PS2 mouse will
        always do what it wants to do instead of what USBMOUSE wants it to
        do.

        I encourage you to experiment with the hardware emulation just to see
        what happens, though I suspect in the end you will end up deciding to
        use the faster, more reliable, and more manageable BIOS emulation
        instead.

        By default, USBMOUSE uses BIOS (software) emulation.  To have
        USBMOUSE use hardware emulation instead of software emulation, you
        would do the following:

           USBMOUSE BIOSEmulation: No

        To have USBMOUSE switch back again to using software emulation, you
        would do the following:

           USBMOUSE BIOSEmulation: Yes

        Again, keep in mind that CTMOUSE (http://cutemouse.sourceforge.net)
        is the only DOS Mouse Drive I know of that will work with USBMOUSE in
        BIOS emulation mode.  If you know of any others, I would be very
        interested in finding out what they are.













              DOS USB DRIVER INTRODUCTION            Page 112 of 186

           Hardware Emulation Methods
           ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

           USBMOUSE has three different Methods of emulating mouse movements
           and button presses at the hardware level, simply called Methods 1,
           2, & 3.  These are essentially the same thing as the three
           "typing" Methods discussed above for USBKEYB (page 90).

           Method 1 uses a special function built in the BIOS (hardware) of
           many modern computers.  In other words, for it to work properly,
           the hardware on your computer (motherboard) must be compatible
           with Method 1.  If you hardware is compatible with Method 1, it is
           the best and most reliable of the three Methods.

           Method 2 uses a combination of hardware and software to emulate
           the mouse hardware.  Much like to Method 1, it requires that the
           BIOS hardware on the motherboard be compatible with Method 2.
           Unlike Method 2 with USBKEYB (which I've never gotten to work on
           any of my computers), however, I have gotten Method 2 with
           USBMOUSE to work on some of my computers.

           Method 3 strictly uses software to emulate the mouse hardware.

           Similar to USBKEYB, as USBMOUSE is installing itself into memory,
           it performs a relatively simple test to determine which of the
           three Methods it should use to simulate keystrokes if it is using
           hardware emulation rather than BIOS (software) emulation.  The
           first test it performs is to see if you have provided it an option
           switch to tell it which Method you want it to use.  To have
           USBMOUSE simulate keystrokes using Method 1, for example, you
           would do:

             USBKEYB Method 1

           If you do not specifically provide USBMOUSE with a Method to use,
           it will try Method 1, and if unsuccessful, will then try Method 2.
           If neither Method 1 nor Method 2 works, USBMOUSE will simply
           default to using Method 3.  Note that USBMOUSE does not actually
           test Method 3, but simply assumes that it should work if neither
           Method 1 nor Method 2 does.













              DOS USB DRIVER INTRODUCTION            Page 113 of 186

        Enabling & Disabling Mice
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        USBMOUSE will let you use up to 8 USB Mice, along with a "real" PS2
        mouse, all at the same time.  Even if you have more than one mouse
        attached to the computer, you will usually only want to use one of
        them at a time.  If you have extra mice, and want to disable some of
        them so that nothing happens when you accidentally bump them, you can
        do that.  For instance, my laptop has a touch-pad "mouse" on it
        located directly underneath the keyboard.  I am constantly "bumping"
        the touch-pad by accident with my palms or my thumbs as I am typing,
        and really get annoyed as the cursor moves all over the screen and I
        end up typing things in the wrong places.  So, by default, I disable
        (turn off) the touch-pad on my laptop and plug in an external USB
        mouse (when I even want to use a mouse).

        By default, all mice (USB and PS2) are enabled (turned on) in
        USBMOUSE.  However, USBMOUSE will let you enable (turn on) and
        disable (turn off) each of the individual USB mice, as well as the
        PS2 mouse.  To Disable a particular mouse, you must provide a Mouse
        Index number (between 0 and 8).  Index 0 is the first USB mouse, and
        Index 7 is the last (eighth) USB mouse.  Index 8 is the PS2 mouse.
        For example, to Disable the first USB mouse (Index 0), you would do
        the following:

           USBMOUSE Disable 0

        To re-enable the PS2 mouse (Index 8), you would to the following:

           USBMOUSE Enable 8

        Note that if USBMOUSE is in hardware emulation mode, disabling and
        enabling the PS2 mouse does not actually do anything.  You must be in
        BIOS (software) emulation mode before USBMOUSE can control the PS2
        mouse hardware.


        Exchanging Left & Right Buttons
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        A mouse can be configured either as a right-handed mouse or a left-
        handed mouse.  Right-handed is the most common, and the only
        difference between the two is which mouse button is considered the
        "main" selector button.  In both cases, it is the one you normally
        press with your index finger (the left button in a right-handed
        mouse, and the right button in a left-handed mouse).  To the mouse
        hardware itself, it doesn't make any difference -- a button is simply
        a button, and none of them are "more important" than any of the
        others.  It's only in the software that it matters.




              DOS USB DRIVER INTRODUCTION            Page 114 of 186

        USBMOUSE lets you exchange the left and right buttons on the mice,
        changing them from right-handed to left-handed mice (and vice versa).
        You can exchange the buttons of an individual mouse, or exchange the
        buttons on all of the mice at the same time (including the PS2
        mouse).  To indicate which mouse you want to exchange buttons on, you
        must provide a Mouse Index number (between 0 and 8).  Index 0 is the
        first USB mouse, and Index 7 is the last (eighth) USB mouse.  Index 8
        is the PS2 mouse.  For example, to exchange buttons on the first USB
        mouse (Index 0), you would do the following:

           USBMOUSE Exhange 0

        If you later wanted to return the buttons back to their normal (un-
        exchanged) state, you would just exchange them again:

           USBMOUSE Exhange 0

        You can also exchange the left and right buttons for all mice at the
        same time by specifying Mouse Index 255:

           USBMOUSE Exchange 255

        Note that when you tell USBMOUSE to exchange the buttons for all mice
        at the same time, it is a truly "global" button exchange, as opposed
        to 9 individual exchanges.  That is, if you do a global exchange
        (Index 255), and then also do an individual exchange (say, Index 0),
        the end result will be that the individual device will not be
        exchanged at all (exchanging something twice is the same as doing
        nothing).

        Also note that some DOS Mouse Drivers (like CTMOUSE) allow the left
        and right buttons to be exchanged, as do some individual DOS
        programs.  If you mess around and try to exchange buttons in too many
        different places, you will find yourself totally confused and may
        still have things backwards from what you want them to be.

        Note that if USBMOUSE is in hardware emulation mode, attempting to
        exchange the left and right buttons (either globally or individually)
        does not exchange the buttons on the PS2 mouse.  You must be in BIOS
        (software) emulation mode before USBMOUSE can control the PS2 mouse
        hardware.












              DOS USB DRIVER INTRODUCTION            Page 115 of 186

        Descriptors
        ฤฤฤฤฤฤฤฤฤฤฤ

        To display the General Descriptors (Device, Configuration, Interface,
        etc.) of the last mouse that was configured by USBMOUSE, you would do
        the following:

           USBMOUSE Descriptors

        A USB Mouse is also part of a larger USB classification called Human
        Interface Devices (HID's), and therefore has a special Descriptor
        called an HID Report Descriptor.  The HID Report Descriptor
        "describes", among other things, how many buttons and wheels the
        mouse actually has.  To display the HID Report Descriptor of the last
        mouse that was configured by USBMOUSE, you would to the following:

           USBMOUSE ReportDescriptor


        Displaying Raw Mouse Data
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        USBMOUSE will also let you look at the Raw (USB) data as it is coming
        from the mice.  This can be used as a troubleshooting aid, or just
        lets you "investigate" what's going on in the background if you're
        interested.  To view the raw mouse data, you would do the following:

           USBMOUSE RawData

        The display will show a total of 8 columns.  The first column is
        labeled "Buttons, and the remaining columns are labeled "Byte 2" thru
        "Byte 8".  USB Mice can send up to 8 bytes of data to the computer,
        though they usually only send 4 or 5 bytes.

        The first byte (8 bits) of data sent by a standard USB Mouse is a
        bit-map of the buttons that are currently pressed on the mouse.
        Using this format, a mouse can have up to 8 buttons, though they
        typically only have 3 to 5.  The RawData screen labels the first
        three buttons L (Left), R (Right), and C (Center).  The remaining
        buttons are labeled with the numbers 4 thru 8.

        The remaining bytes (2 thru 8) are used to indicate mouse or wheel
        movements, with each byte dedicated to a specific direction or wheel.
        The byte is simply a number between -127 and +127, with a positive
        number indicating movement in one direction (usually right or down),
        and a negative number indicating movement in the other direction
        (usually left or up).  The absolute value of the number (1 thru 127)
        indicates "how much" or "how fast" the movement was, with 1 being
        slow and 127 being very fast.




              DOS USB DRIVER INTRODUCTION            Page 116 of 186

        The first movement byte (labeled "Byte 2") is usually the horizontal
        (X) movement of the mouse, and "Byte 3" is usually the vertical (Y)
        movement of the mouse.  The remaining bytes (4 thru 8) are usually
        for any scrolling wheels that the mouse may have, with one byte
        dedicated to each wheel.

        Note that the format of the raw data shows you what is coming from
        the USB mice.  This is COMPLETELY different than the format of the
        data that comes from a PS2 mouse.  USBMOUSE takes the data coming
        from the USB mice, translates it into the PS2 format, and then
        "sends" (emulates) it into the DOS Mouse Driver so that the Driver
        thinks it is "seeing" a PS2 mouse instead of a USB mouse.  The
        PS2MTEST program below (page 121) allows you to look at the data
        coming from the mice in PS2 format.

        When you are through viewing the raw data, you simply press any key
        on the keyboard and USBMOUSE will stop.


        Controlling Mouse Sensitivity
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        PS2 mice let you have a certain amount of control over how
        "sensitive" they are to movement.  That is, you can adjust the mouse
        to react to the slightest touch of your hand, or you can adjust it so
        that you have to drag it halfway across the table before you see much
        of anything happen on the screen.  Unfortunately, DOS does not
        provide an easy way to control these settings, so most people just
        leave them at the default values.

        USBMOUSE provides a way for you to control the sensitivity settings
        of the PS2 mouse, even when USBMOUSE is not installed in memory.
        That is, if you want to, you can simply use USBMOUSE to control the
        sensitivity of your PS2 mouse even if you never use a USB mouse.
        USBMOUSE does not require any memory if the only thing you're using
        it for is to control the mouse sensitivity.

        However, remember that the main purpose of USBMOUSE is to control USB
        mice.  By default, USBMOUSE assumes that you are wanting to use it to
        control USB mice, and therefore, by default, will try to install
        itself into memory as a TSR (Terminate-but-Stay-Resident) program.
        If you do not want USBMOUSE to try and install itself into memory,
        you can do the following:

           USBMOUSE Install:No   {other options}








              DOS USB DRIVER INTRODUCTION            Page 117 of 186

        The most basic sensitivity setting for a PS2 mouse is called the
        Resolution.  The Resolution is measured in Counts Per Millimeter
        (CPM), and can be set to either 1, 2, 4, or 8.  If the Resolution is
        set at 1 CPM (the least sensitive setting), and you move the mouse 1
        millimeter, the mouse will send a signal to the computer saying "the
        mouse moved 1 Count."  If the Resolution is set at 8 CPM (the most
        sensitive setting), and you move the mouse only 1/8 of a millimeter,
        the mouse will send a signal to the computer saying "the mouse moved
        1 Count."  When a PS2 mouse "boots up", it has a default Resolution
        of 4 CPM.  To set the Resolution of the PS2 mouse (and all of the USB
        mice, if USBMOUSE is installed in memory) to 8 CPM, you would do the
        following:

           USBMOUSE Resolution:8

        If you are only using a PS2 mouse, and do not want USBMOUSE to try
        and install itself into memory as you changed the resolution, you
        would do the following:

           USBMOUSE Install:No Resolution:8

        The next setting that changes the sensitivity of PS2 mice is called
        the Scaling Factor.  The Scaling Factor can either be 1 (the default)
        or 2.  When the Scaling Factor is set at 2, and you move the mouse
        quickly, it accelerates the mouse movement even more (the cursor on
        the screen moves twice as fast as it normally does).  If you move the
        mouse slowly, however, the cursor moves across the screen at the
        normal (un-doubled) speed.  To set the Scaling Factor to 2, you would
        do the following:

           USBMOUSE ScalingFactor:2

        The last setting related to mouse sensitivity is called the Sampling
        Rate.  Technically, the Sampling Rate does not really affect the
        "sensitivity" of the mouse as such, but if set incorrectly can make
        the mouse appear sluggish and unresponsive (it will appear "jerky").
        The PS2 mouse is actually being polled by the computer several times
        a second (rather than sending data in an "ad hoc" fashion), and the
        Sample Rate controls how may times every second the mouse is polled.
        It is measured Samples Per Second (SPS), and can be set to 10, 20,
        40, 60, 80, 100, or 200, with the default setting at 100 SPS.  The
        default setting of 100 SPS is usually very adequate, and there is
        rarely a reason to change it (unless you just want to experiment to
        see what happens).  I have personally experimented with the settings
        to some degree, and don't see much practical difference between any
        of the settings that are at least 60 SPS.  To set the Sampling Rate
        to 60 SPS, you would do the following:

           USBMOUSE SamplingRate:60




              DOS USB DRIVER INTRODUCTION            Page 118 of 186

        I should also point out that most USB mice cannot be sampled at more
        than 100 SPS, and USBMOUSE does not try to poll any USB mouse at more
        than 100 SPS.  Therefore, even if you set the Sampling Rate to 200,
        the USB mice will not actually be polled that often (the PS2 mouse
        will be, but not the USB mice).


        Resetting the PS2 Mouse
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        There are times when the PS2 mouse gets "gummed up" and stops working
        correctly for some reason.  The most likely scenario for this to
        happen is when a program tries to access the PS2 mouse hardware
        directly, instead of using the DOS Mouse Driver or the PS2 Mouse
        BIOS.  If the PS2 mouse has stopped working correctly, and you need
        to "reset" it, you should do the following:

           USBMOUSE Reset

        Under normal circumstances, you should not need to use the Reset
        option switch.


        Miscellaneous Notes
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        To have USBMOUSE show you the current status of the USB and PS2 mice
        that it is managing, you would to the following:

           USBMOUSE Status

        This will display "general" information about the USB mice (such as
        emulation method and global button exchange status).  In addition, it
        will also display details for each of the individual USB and PS2 mice
        you may have installed (such as Host Index, Device Address, and
        button exchange status).  If something is not working quite right
        with one of the mice, running USBMOUSE with the Status option switch
        will usually be where you start your troubleshooting path.  Keep in
        mind, however, that the data shown for the PS2 mouse will not be
        valid unless USBMOUSE is in BIOS (software) emulation mode.  When
        USBMOUSE is in hardware emulation mode, it is not actually managing
        the PS2 mouse hardware.











              DOS USB DRIVER INTRODUCTION            Page 119 of 186

        As USBMOUSE is installing itself into memory, it must perform a
        hardware reset of the PS2 mouse, which may take several seconds to
        perform.  Once this has happened, USBMOUSE has inserted itself "on
        top of" the PS2 mouse hardware and BIOS software, and the lengthy
        delay that occurs during mouse resets will no longer be required.
        However, if you set USBMOUSE to hardware emulation mode, that will no
        longer be the case.  If USBMOUSE is in hardware emulation mode, it is
        not controlling the PS2 mouse hardware, and lengthy mouse resets will
        be required again.  Mouse resets are required at the beginning and
        end of every program that uses a mouse, so using hardware emulation
        mode will probably slow your programs down considerably.

        USBMOUSE performs the necessary steps to make sure all of your mice
        appear to be the same (to have the same number of wheels and buttons)
        to the DOS Mouse Driver.  For example, let's say you are using
        CTMOUSE, which includes support for one scrolling wheel and three
        buttons.  Let's also say you have an "old" PS2 mouse with just two
        buttons, and a "new" USB mouse with two scrolling wheels and 5
        buttons.  USBMOUSE will perform the necessary adjustments and
        translations to make sure everything works together as it should (at
        least if you are using USBMOUSE in BIOS emulation mode).  That is,
        USBMOUSE will make the DOS Mouse Driver (CTMOUSE) believe that the
        PS2 mouse has a scrolling wheel and three buttons (even though it
        actually doesn't), and will make the DOS Mouse Driver believe that
        the USB mouse only has one wheel and three buttons (even though it
        actually has more than that).  If CTMOUSE is updated in the future to
        support more than one wheel and more than three buttons, USBMOUSE is
        already set up to automatically handle that transition as well.

        As discussed above in  IRQ & I/O Resources  (page 56), on all modern
        computers IRQ #12 is dedicated to the PS2 mouse, or to any software
        (like USBMOUSE) that emulates the PS2 Mouse.  IRQ #12 must not be
        used for any other purpose, including a USB host controller.  If you
        have some other device that is using IRQ #12, you should probably
        change it to to use a different IRQ or risk serious problems &
        crashes when you use a mouse.  USBUHCI{L} has options to let you
        change the IRQ (see page 56) if the BIOS happens to set your USB Host
        Controller to use IRQ 12 and you want to use USBMOUSE.















              DOS USB DRIVER INTRODUCTION            Page 120 of 186

     PS2MTEST
     ฤฤฤฤฤฤฤฤ

     Version:     1.00
     Prog Type:   Test
     Source Code: ASM (A86 by Eric Isaacson)
     Status:      Complete
     Environment: None
     Redirection: No
     Purpose:     PS2 mouse BIOS tester
     TSR Memory:  0 kB (not a TSR)


     PS2MTEST is a program designed to test your PS2 mouse.  It does this by
     displaying the "raw" data that is coming from the mouse through the PS2
     mouse BIOS (software).  It's included here as a "companion" program to
     help you test USBMOUSE (discussed directly above on page 107), but you
     can also use it to simply test your PS2 mouse.

     What you will see on the screen when you run PS2MTEST will be four words
     (eight bytes) of data on the left, labeled "Raw PS2 Mouse Data".  The
     PS2 Mouse BIOS always transfers eight bytes of data, even though only
     three or four of the bytes actually contain any useful data.  This is
     where the raw data (numbers) will be displayed as you move the mouse and
     press the buttons.

     To the right of the raw data on the screen are three columns, labeled
     "Buttons", "Motion", and "Wheels".  This is where the raw data is
     translated into meaningful descriptions (button presses, mouse
     movements, and scrolling wheel clicks).  Exactly how the data gets
     translated depends on which protocol is currently being used by the
     mouse (PS2, IntelliMouse, or IntelliMouse2, described above on page
     110).  Only three bytes of actual data are transferred when the mouse is
     in PS2 mode, and four bytes are transferred when the mouse is in
     IntelliMouse or IntelliMouse2 mode.  Exactly which bits of data
     correspond to which buttons and movements changes based on the protocol
     currently in use, and those details will not be discussed here.
     Information about that is available at various places on the internet if
     you want to search for it.

     By default, PS2MTEST will use the most sophisticated protocol supported
     by the mouse hardware and BIOS (IntelliMouse2 is the first choice,
     followed by IntelliMouse, with PS2 as the last choice).  If you are
     using USBMOUSE in BIOS (software) emulation mode, it will always support
     the IntelliMouse2 protocol.  If you are not using USBMOUSE at all, or
     are using USBMOUSE in hardware emulation mode, the most sophisticated
     protocol supported will depend on the PS2 mouse hardware (how many
     wheels and buttons it has).





              DOS USB DRIVER INTRODUCTION            Page 121 of 186

     Although the default is for PS2MTEST to use the most sophisticated
     protocol, you can force it to use a less sophisticated protocol if you
     want to for testing or educational purposes.  To do this, you must
     provide to PS2MTEST a number which corresponds to the maximum number of
     wheels supported by the protocol (0 = PS2, 1 = IntelliMouse, and 2 =
     IntelliMouse2).  For example, to provide the same functionality as the
     default, you would do the following:

        PS2MTEST 2

     This will test the mouse using the IntelliMouse2 protocol (maximum of 2
     wheels and 5 buttons) if the mouse supports it.  If the mouse does not
     support the IntelliMouse2 protocol, but does support the IntelliMouse
     protocol, this will test the mouse using the IntelliMouse protocol.  If
     the mouse only supports the PS2 protocol, this will test in using the
     PS2 protocol.

     To test the mouse using the IntelliMouse protocol, even if it supports
     the IntelliMouse2 protocol, you would do the following:

        PS2MTEST 1

     If the mouse does not support the IntelliMouse protocol, PS2MTEST will
     test the mouse with the PS2 protocol.

     To force PS2MTEST to test the mouse with the PS2 protocol, no matter how
     many wheels it actually has, you would do the following:

        PS2MTEST 0

     After you are through viewing the raw PS2 mouse data, simply press a key
     on the keyboard and PS2MTEST will stop.  After PS2MTEST stops, it will
     attempt to restore the PS2 mouse BIOS and DOS Mouse Driver to the same
     exact state it was in before you ran PS2MTEST.  While the restoration
     process usually works just fine, there are times when it does not.  If
     the restoration process does not seem to work correctly, you will need
     to reset or reinstall the DOS Mouse Driver again.
















              DOS USB DRIVER INTRODUCTION            Page 122 of 186

     USBJSTIK
     ฤฤฤฤฤฤฤฤ

     Version:     0.11
     Prog Type:   Device/Interface Driver
     Source Code: ASM (A386 by Eric Isaacson)
     Status:      Complete, a few minor tweaks required
     Environment: USBJSTIK
     Redirection: Yes
     Purpose:     Driver for up to 8 USB Joysticks
     TSR Memory:  7.4 kB


     USBJSTIK is a Device/Interface Driver program for up to eight USB
     joysticks or gamepads.  USBJSTIK emulates a "regular" joystick (attached
     to a game port) at the BIOS (software) level.  Unfortunately, most DOS
     programs that use a joystick do not interact with the joysticks at the
     BIOS level (even though they should at least have that as an option).
     Rather, most DOS programs interact with the joysticks directly at the
     hardware level.

     USBJSTIK can also emulate joysticks at the hardware level, rather than
     the BIOS (software) level, using a process called I/O Virtualization.
     Emulating a joystick at the hardware level allows you to use a USB
     joystick with almost any DOS program you can imagine.  However, USBJSTIK
     cannot perform I/O Virtualization on its own.  In order Virtualize I/O,
     you must have an appropriate memory manager installed via your
     CONFIG.SYS file.  Appropriate memory managers include Microsoft's EMM386
     version 4.46 or later, and 386MAX.  As far as I know, other memory
     managers (such as QEMM or the EMM386 program that comes with FreeDOS) do
     not support I/O Virtualization, and cannot be used with USBJSTIK if you
     want to emulate joysticks at the hardware level.

     In general, you cannot have both a regular (game port) joystick and a
     USB joystick (emulated by USBJSTIK) at the same time.  There are certain
     unique situations (discussed below) where it is possible, but these
     situations are rare.  If you have a joystick attached to a regular game
     port, you are generally better off using it rather than attempting to
     use a USB joystick.

     Before USBJSTIK can be installed into memory, you must first have at
     least one USB Host Driver (USBUHCI{L}) installed in memory.  To install
     USBJSTIK into memory, you can simply run it with no option switches:

        USBJSTIK








              DOS USB DRIVER INTRODUCTION            Page 123 of 186

        Joystick Protocols
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        Game ports are very simple devices.  There are only 8 bits of data
        that can be transferred from the joystick to the computer.  There are
        four digital bits, which are associated with buttons (they are either
        on or off at any particular instant), and four analog bits, which are
        normally associated with joystick axes (their value is variable at
        any particular instant).

        In the original game port specifications provided by IBM in the early
        1980's, there were four buttons.  These were either separated as two
        buttons on each of two separate joysticks, or one button on each of
        four separate paddles.  The four analog values could either be
        separated as two axes (horizontal & vertical) each on two separate
        joysticks, or one axis on each of four separate paddles.  As far as I
        know, nobody makes paddles any more (at least I've never seen one).

        As time passed, joystick manufacturers figured out ways of
        manipulating the digital and analog inputs in ways that IBM hadn't
        imagined.  The first thing that joystick manufacturers did was to put
        all eight of the inputs on a single joystick, instead of dividing
        them among two different joysticks.  This allowed a single joystick
        to have as many as four buttons and as many as four axes.  Usually,
        the two extra axes are in the form of sliders or gas pedals or
        wheels, and do not usually resemble what you normally think of as an
        "axis".

        A further advancement came when one of the joystick manufacturers
        decided to have more than four buttons on a joystick.  There are two
        possible ways of using the four bits of digital data associated with
        the buttons.  The first way is to have four independent buttons,
        where any or all of them can be pressed at the same time (this is the
        original use of the bits).  We will call this the 4-button protocol.
        The second way allows you to have as many as 15 buttons, but only one
        of them can be pressed at a time.  If you do press more than one at
        the same time, the joystick will consider one of the buttons to be
        "more important" than the other one, and only the most important one
        will be sent to the computer.  We will call this the 15-button
        protocol.  If you want USBJSTIK to emulate the 15-button protocol,
        you would do the following:

           USBJSTIK FifteenButtons: Yes

        To have USBJSTIK emulate the 4-button protocol (the default), you
        would do the following:

           USBJSTIK FifteenButtons: No





              DOS USB DRIVER INTRODUCTION            Page 124 of 186

        The joystick manufacturers also came up with a new way to manipulate
        the analog values.  I believe that ThrustMaster was the company that
        invented this, so I will call it the ThrustMaster protocol.  What
        this protocol involves is taking one of the analog axis values and
        "digitizing" it.  Rather than simply having two digital values,
        however, it is digitized into five different values.  Each of the
        five values is associated with the position of a four-way hat-switch
        (centered, up, right, down, and left).  If you want USBJSTIK to
        emulate the ThrustMaster protocol, you would do the following:

           USBJSTIK ThrustMaster: Yes

        To have USBJSTIK emulate the Standard (default) protocol, you would
        do the following:

           USBJSTIK ThrustMaster: No

        USBJSTIK can be set up to emulate two separate joysticks (each with
        two buttons), or can be set up to emulate a single joystick.  When
        emulating a single joystick, USBJSTIK can emulate the buttons with
        either the 4-button or 15-button protocol, and can emulate the axes
        with either the Standard protocol or the ThrustMaster protocol.
        However, I will admit that configuring USBJSTIK to do exactly what
        you want it to do can be confusing, unless you need understand some
        basic concepts about how analog and USB joysticks actually work.


        Analog Joystick Entity Names
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        In order to talk about joysticks in more detail, we need to come up
        with a way of naming the entities (axes and buttons) that the
        joystick has.  Our naming convention will be primarily based on the
        idea of having two separate joysticks, each having a single two-
        dimensional handle and two buttons.  The first joystick will be
        called "A" and the second will be called "B".  The left-right
        (horizontal) axis of the handle will be called "X", and the up-down
        (vertical) axis of the handle will be called "Y".  The first button
        (usually located on the front of the handle that you press with your
        index finger) will be called "1", and the second button (usually
        located on top of the handle that you press with your thumb) will be
        called "2".  Therefore, with two standard joysticks, you will have
        the following entities:










              DOS USB DRIVER INTRODUCTION            Page 125 of 186

           AX = First Joystick, Left-Right Axis
           AY = First Joystick, Up-Down Axis
           A1 = First Joystick, First Button
           A2 = First Joystick, Second Button

           BX = Second Joystick, Left-Right Axis
           BY = Second Joystick, Up-Down Axis
           B1 = Second Joystick, First Button
           B2 = Second Joystick, Second Button

        If you have only one joystick and it uses the 4-button protocol, it
        is essentially "stealing" the B1 and B2 buttons from what would be
        the B joystick.  We will call these buttons A3 & A4, but they are
        actually synonymous with B1 and B2, respectively.  That is, A3 is
        actually the same button as B1, and A4 is the same as B2.

           A3 = Single Joystick, Third Button (same button as B3)
           A4 = Single Joystick, Fourth Button (same button as B4)

        If you have only one joystick and it uses the 15-button protocol, the
        additional buttons will simply be called A5-A15.  While we will call
        the first four buttons A1-A4 just like we do when we use the 4-button
        protocol, they do not act the same way (you can only press one of
        them at a time when using the 15-button protocol).

           A5  = Single Joystick, Fifth Button
           A6  = Single Joystick, Sixth Button
           ...
           A15 = Single Joystick, Fifteenth Button

        If you are using a single joystick with the standard axis protocol,
        the third and fourth axes are still called BX and BY, even though
        they are not on the second (B) joystick.  Usually, the third and
        fourth "axes" on a single joystick do not resemble axes in the
        traditional sense, but are usually implemented instead as sliders,
        gas pedals, or wheels.

           BX = Single Joystick, Third Axis
           BY = Single Joystick, Fourth Axis

        If you are using a single joystick with the ThrustMaster protocol,
        the four-way hat-switch is treated as if it is the second (B)
        joystick handle (the hat-switch axes are called BX & BY).  The
        remaining axis (usually implemented as a slider or gas pedal) is
        called AZ.

           BX = Single Joystick, Hat-switch Left-Right Axis
           BY = Single Joystick, Hat-switch Up-Down Axis
           AZ = Single Joystick, Fifth Axis




              DOS USB DRIVER INTRODUCTION            Page 126 of 186

        USB Joystick Control Names
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        The section directly above declares a naming convention for the
        analog joystick entities.  The purpose of USBJSTIK is to use a USB
        joystick (or joysticks) to emulate an analog joystick (or joysticks).
        USB joysticks don't work the same way that analog joysticks do, so we
        need to come up with a different naming convention.  Calling them
        different things will also make it easier to understand when we later
        start talking about how to map the USB joystick buttons and axes to
        the analog joystick buttons and axes.

        The first thing we will do is to call each button or axis on the
        joystick a Control, rather than calling it an Entity as we did with
        the analog joysticks.  A USB joystick control is mapped to and
        controls an analog joystick entity.

        USBJSTIK allows you to have as many as 8 USB joysticks attached to
        the computer, which we will refer to with 0-based index numbers (0-
        7).  The "first" USB joystick (or gamepad) is called joystick 0, and
        the "last" is called joystick 7.

           Joystick 0 = First USB joystick or gamepad
           Joystick 1 = Second USB joystick or gamepad
           ...
           Joystick 7 = Last USB joystick or gamepad

        On each USB joystick there will be multiple controls (buttons and
        axes).  Almost every USB joystick is made differently than all of the
        others, so the numbers and types of controls will vary considerably
        by manufacturer and model.  The first type of control are the
        Buttons, which will simply be numbered starting from 0.

           Button  0 = First Button on USB joystick or gamepad
           Button  1 = Second Button on USB joystick or gamepad
           ...
           Button 99 = Hundredth Button on USB joystick or gamepad

        In the USB architecture, buttons are simply numbered, and most USB
        joysticks have a lot of buttons (although it is very unlikely that
        they will have 100).  The numbering of the buttons (which one is
        "first" and which one is "last") is determined by the joystick
        manufacturer, and the numbering does not always seem to "flow" in a
        logical fashion (left to right, for example).  You will usually need
        to experiment with each of your joysticks to figure out what the
        numbering scheme is.







              DOS USB DRIVER INTRODUCTION            Page 127 of 186

        The next category of controls are the Direction Pads (DPads) and Hat-
        switches (Hats).  These can either be 4-way (up, right, left, down)
        or 8-way (up, up and right, right, right and down, etc.).  DPads and
        Hats are always spring-loaded, and when you are not pressing them in
        a particular direction they will automatically become centered.  In
        USBJSTIK, we do not differentiate between DPads and Hats, nor do we
        differentiate between 4-ways and 8-ways.  We classify them all as the
        same "type" of control.  Like the buttons, they are number starting
        from 0.

           DPad  0 = First 4-way or 8-way Direction-Pad or Hat-switch
           DPad  1 = Second 4-way or 8-way Direction-Pad or Hat-switch
           ..
           DPad 99 = Hundredth 4-way or 8-way Direction-Pad or Hat-switch

        Like the buttons, which one is "first" and which one is "last" is
        determined by the manufacturer, and you will need to experiment with
        each of your joysticks to figure out which is which.

        The last three types of control fall under the general classification
        of "axes" (which we will also classify as "analog controls", even
        though they are not truly analog).  This means that at any particular
        instant the value (number) they have can fall anywhere within a large
        range (as opposed to buttons and DPads, which are simply on or off).
        In the USB architecture, and in USBJSTIK, there are three different
        types of analog controls: Axis, Throttle, and Slider.

        The difference between the three types of analog controls is what
        happens when you let go of them: an Axis is spring-loaded and
        automatically centers itself, a Throttle is spring-loaded and
        automatically moves itself to one of the extremes (left, right, up,
        or down), and a Slider is friction-loaded and stays where it was when
        you last let go of it.  Each of these is also numbered starting with
        0.

           Axis  0 = First Axis
           Axis  1 = Second Axis
           ...
           Axis 99 = Hundredth Axis

           Throttle  0 = First Throttle
           Throttle  1 = Second Throttle
           ...
           Throttle 99 = Hundredth Throttle

           Slider  0 = First Slider
           Slider  1 = Second Slider
           ...
           Slider 99 = Hundredth Slider




              DOS USB DRIVER INTRODUCTION            Page 128 of 186

        Joystick Controls Mapping
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        Now that we know what we will call the different buttons and axes in
        the analog and USB world, we can talk about how to "map" the USB
        Controls to the Analog Entities to have USBJSTIK do exactly what we
        want it to do.  Rather than trying to explain how you do it, lets
        just start by using a specific example.  If you want to map the first
        button of the first USB joystick (Joystick 0, Button 0) to the first
        button of the first analog joystick entity (A1), you would do the
        following:

           USBJSTIK Map A1 From Joystick 0, Button 0

        To map the second slider of the fourth USB joystick (Joystick 3,
        Slider 1) to the Y axis of the second analog joystick entity (BY),
        you would do the following:

           USBJSTIK Map BY From Joystick 3, Slider 1

        In general, you will want to map USB analog controls (Axes,
        Throttles, and Sliders) to analog axis entities, and USB button
        controls to analog button entities.  However, USBJSTIK will also let
        you do some "unusual" mappings as well.  For instance, while it would
        not make any sense to map a single button to an axis, USBJSTIK will
        let map a PAIR of buttons to an Axis.  For example:

           USBJSTIK Map AX From Joystick 0, Button 3,4

        will map USB joystick 0, buttons 3 & 4 to the AX analog entity.  That
        is, if neither button 3 or 4 is pressed, or both buttons are pressed
        at the same time, AX will be centered.  If Button 3 is pressed, AX
        will be to the left.  If button 4 is pressed, AX will be to the
        right.  For a horizontal (X) axis, the first button listed (3 in our
        example) corresponds to moving the axis left, and the second button
        (4 in our example) corresponds to moving the axis right.  For a
        vertical axis (AY or BY), the first button corresponds to moving the
        axis up, and the second to moving the axis down.

        Mapping USB DPads and Hats is more complicated and difficult to
        understand than are buttons and axes.  In USBJSTIK, a USB DPad is
        treated as two separate Axes (an X and a Y), even though the two axes
        are inextricably tied together.  So, when you are trying to map a
        DPad to an analog entity, in addition to the control type (DPad) and
        index (say, 3), you must also provide a direction (X or Y).  For
        example:

           USBJSTIK Map BX From Joystick 3, DPad 0 X





              DOS USB DRIVER INTRODUCTION            Page 129 of 186

        If you wanted the entire DPad to be used to emulate the entire
        joystick B "handle", you would to do both the above line and:

           USBJSTIK Map BY From Joystick 3, DPad 0 Y

        As should be fairly obvious by now, it can take a lot of confusing
        calculating and writing to get everything mapped the way you want it
        to be.  If you want to combine several key mappings onto the same
        command-line, you can certainly use aliases and shorthand codes to do
        what you want (a list of Aliases can be viewed by issuing a "USBJSTIK
        Alias").  For instance, the following lines are equivalent to each
        other:

         USBJSTIK Map AX From Joystick 0 Axis 0 Map AY From Joystick 0 Axis 1
         USBJSTIK MAX0A0MAY0A1

        While the two lines are equivalent (they accomplish the exact same
        thing), when you look at the second line and try to figure out what
        it is actually doing you will probably have absolutely NO IDEA.  When
        you come back later to try to test or troubleshoot or change
        something, you won't even know where to start.  If you're doing any
        mapping that is very complicated at all, you will probably want to
        put the mappings into a configuration file and use the USBJSTIK
        redirection option to load it.  For example, to accomplish the above
        example, you would write a configuration file (we'll call it
        USBJSTIK.CFG) that looks something like this:

           ;This is an example configuration file for USBJSTIK
           ;To load these options, you must do a "USBJSTIK < FileName",
           ; where FileName is the name of this particular file.

           Map AX From Joystick 0, Axis 0   ;AX = First Joystick, First Axis
           Map AY From Joystick 0, Axis 1   ;AY = First Joystick, Second Axis

           ;This is the end of the example configuration file

        and then load it as follows (you could do this in your AUTOEXEC.BAT
        file if you wanted):

           USBJSTIK < USBJSTIK.CFG













              DOS USB DRIVER INTRODUCTION            Page 130 of 186

        If you do not "override" USBJSTIK with any special mappings, it will
        use the following defaults.  This is set up as a single joystick in
        which all buttons and all axes come from the same joystick.  This is
        the type of setup that would normally be used for a single-player
        game.

           AX = Joystick 0, Axis 0
           AY = Joystick 0, Axis 1
           BX = Joystick 0, Axis 2
           BY = Joystick 0, Axis 3
           AZ = Joystick 0, Axis 4

           A1  = Joystick 0, Button 0
           A2  = Joystick 0, Button 1
           A3  = Joystick 0, Button 2
           ...
           A15 = Joystick 0, Button 14


           Special Notes About Controls Mapping
           ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

           If an analog entity is mapped from a USB joystick that does not
           actually exist (such as Joystick 7 when you only have one USB
           joystick), obviously it will be impossible for USBJSTIK to emulate
           that particular analog entity.  Note that USBJSTIK does not
           actually treat this as an error, however, because of the "plug-
           and-play" nature of the architecture.  Just because a particular
           joystick does not exist (is not attached) right now does not mean
           things will be that way when you actually want USBJSTIK to start
           emulating an analog joystick.  In the same vein, mapping an analog
           entity from a specific USB joystick control that does not actually
           exist (such as Axis 4 on a USB joystick that only has 2 axes) is
           not an error, it just means that the analog entity will never be
           emulated.

           USBJSTIK does not change the default mapping even if the default
           controls do not exist.  Therefore, you will usually need to change
           the default mapping.  For instance, very few USB joysticks
           actually have four axes -- most only have one handle (two axes)
           and some combination of Hat-switches or Sliders that you will want
           to use as your BX, BY, and AZ entities.  Likewise, USB gamepads
           usually do not have any axes at all, but instead have Direction
           Pads that are intended to be used as axes.









              DOS USB DRIVER INTRODUCTION            Page 131 of 186

           Even if every analog entity is mapped from a legitimate USB
           joystick control, however, it does not necessarily mean that all
           of the analog entities can be emulated.  In addition to the
           correct mappings, what happens during the emulation also depends
           on which emulation modes USBJSTIK is currently set to (15-button
           vs. 4-button, and Standard vs. ThrustMaster).  This is discussed
           above in "Joystick Protocols" (page 124).  For instance, the AZ
           entity is never emulated unless USBJSTIK is using the ThrustMaster
           protocol.

           It is possible for you to map the same USB joystick control to two
           different analog entities.  For example:

             USBJSTIK Map A1 From J1 Btn 0    Map A2 From J1 Btn 0

           USBJSTIK does not consider this an error, since there may be a
           perfectly legitimate reason for you to do this.  In general,
           however, this should be avoided since USBJSTIK will probably not
           behave the way you're expecting it to.

           USBJSTIK does not provide a direct way to map an analog entity
           from "nothing".  If you purposely do not want a specific analog
           entity to ever be emulated, you must map it from a USB joystick
           control that you know will never actually exist (such as Joystick
           7, Button 99).

           You can map analog axis entities from any type of USB joystick
           control (Axis, Throttle, Slider, DPad half, or Button pair).
           However, you can only map analog button entities from USB button
           controls.

           Remember that analog button entity A3 is the same as B1 (the first
           button on joystick B, when you have two joysticks), and A4 is the
           same as B2.  The following two lines, for example, are equivalent:

             USBJSTIK Map A3 From Joystick 0, Button 6
             USBJSTIK Map B1 From Joystick 0, Button 6

           To view the current mappings that USBJSTIK is using, you need to
           use the Status option switch (discussed in "Miscellaneous Notes"
           below, page 138).  In addition to showing you the current
           mappings, the Status option switch will also tell you how many of
           each kind of control (Buttons, Axes, Throttles, etc.) each USB
           joystick has.

           While the Status option switch will tell you how many of each kind
           of control each USB joystick has, it will not tell you which
           control is "first" (index 0), which is "second" (index 1), etc.
           To figure out precisely which index is associated with which
           control, you will need to use the JoystickStatus option switch,
           discussed below in "Displaying Raw joystick Data" (page 137).


              DOS USB DRIVER INTRODUCTION            Page 132 of 186


        Analog <-> Digital Conversions
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        A USB analog control (Axis, Throttle, or Slider) produces a
        continuously variable range of numbers (small numbers when it is left
        or up, large numbers when it is right or down, and mid-range numbers
        when it is centered).  However, USBJSTIK allows you to map an analog
        control to a Hat-switch axis, which is a digital entity.  The
        horizontal axis of a Hat-switch, for example, is either left, center,
        or right -- it is not continuously variable nor is it ever "almost
        centered".  USBJSTIK needs a special parameter that essentially
        answers the question, "Exactly how far away from the center does the
        USB analog control need to be before I should consider it un-
        centered?".  The parameter that USBJSTIK uses to determine this is
        called the PercentFromCenter.

        For example, lets say the range of values that a horizontal (X) USB
        analog control produces range from 0 (when it is all the way to the
        left) to 200 (when it is all the way to the right).  When it is
        centered, it will produce a value of 100 (or very close to 100).  If
        the USBJSTIK PercentFromCenter is set at 50 (which is the default),
        the range where the analog control will be "centered" will go from 50
        (100 - 50%) to 150 (100 + 50%).  When the analog entity is far enough
        to the left for the value to read less than 50, USBJSTIK will
        "trigger" the appropriate entity in the analog joystick emulation
        (the analog Hat-switch will be to the left).  When it reads more than
        150, the Hat-switch will be right.

        You can set USBJSTIK's PercentFromCenter parameter to be anything
        from 20 to 80, with the default being 50.  Lower numbers make the
        joystick more "touchy", while larger numbers may make the joystick
        seem less responsive.  You should adjust this number based on how you
        want the joystick to "feel".  To change the PercentFromCenter to 20%,
        for example, you would do the following:

           USBJSTIK PercentFromCenter: 20

        Also note that the ThrustMaster protocol only emulates a 4-way Hat-
        switch, not an 8-way Hat-switch.  A 4-way Hat-switch cannot, for
        example, be both up and to the left at the same time.  However, when
        you are mapping USB controls to the Hat-switch entity, it is quite
        possible for you to have the USB controls be two directions (like up
        and to the left) at the same time.  When something like this happens,
        of course, USBJSTIK does not know which direction you really want it
        to emulate, and therefore keeps the Hat-switch entity centered.







              DOS USB DRIVER INTRODUCTION            Page 133 of 186

        Normalizing Axis Entities
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        The standard way that USBJSTIK emulates analog joystick entities is
        through a set of BIOS functions specifically designed around
        joysticks.  The BIOS functions return simple on and off values for
        the four button entities, and analog (continuously variable) values
        for the four axis entities.  Unfortunately, there is no standardized
        or normalized range of numbers that are considered "appropriate" for
        the analog values to be.  The numbers are allowed to be anything from
        1 to 65535, and the only thing that matters is that the values get
        smaller as you move left or up, and get bigger as you move right or
        down.  The main reason that you need to "calibrate" your joysticks
        every time you start a program that uses them is because there is no
        standard range of values.

        The default range of values that USBJSTIK returns is 1-100 (1 when
        left or up, 100 when right or down, and 50 when centered).  That is,
        the output of all analog axis entities are normalized (adjusted) so
        that they fall within the 1 to 100 range.  To change USBJSTIK to use
        a different range, you simply specify the Center value you want
        USBJSTIK to use, which can be any number between 10 and 200.
        USBJSTIK always uses 1 as the lower value, and double the center
        value as the upper value.  For example, to change the Center value
        reported by the BIOS to 100 (setting the range to be 1-200), you
        would do the following:

           USBJSTIK Center: 100

        Nearly all programs that use a joystick have some sort of joystick
        calibration routine you run each time you start the program.  With
        such programs, there is normally no need to change the Center value
        in USBJSTIK, since the program will simply "adjust" itself to
        whatever values USBJSTIK is sending.  The only time you should need
        to change the Center value is when you are using a program that does
        not have a joystick calibration routine, or does not somehow adjust
        itself automatically to the joystick values.

        Adjusting the Center value affects ALL of the analog axis entities
        (AX, AY, BX, BY, and AZ) at the same time.  It is not possible to
        have one entity report different values than the other entities.












              DOS USB DRIVER INTRODUCTION            Page 134 of 186

        I/O Virtualization
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        The primary way that USBJSTIK emulates joysticks is through a special
        set of functions in the BIOS that are specifically dedicated to
        joysticks.  Unfortunately, in the past, computer manufacturers's
        support of the BIOS joystick functions has been very bad ("pathetic"
        is actually much more descriptive than "very bad").  As a result,
        many DOS programs that use joysticks do not use the joystick BIOS
        functions at all, but instead interact directly with the joystick
        hardware.  This is very unfortunate and short-sighted of the program
        authors, since this precludes them from using any of the newer
        "digital" joysticks or joysticks that are attached to things like USB
        ports.  They have essentially programmed themselves into
        obsolescence.

        All is not lost, however.  It is possible for USBJSTIK to emulate an
        analog joystick at the hardware level, rather than the BIOS level,
        using a process called I/O Virtualization.  This allows USBJSTIK to
        work with almost any DOS program that knows how to use a joystick,
        even if it interacts with the joystick at the hardware level instead
        of the BIOS level.  However, USBJSTIK cannot perform I/O
        Virtualization by itself.  It needs the help of another program: a
        memory manager like later versions of Microsoft's EMM386 or Qualitas'
        386MAX.

        I can only talk knowledgeably about Microsoft's EMM386, since I have
        never owned or used 386MAX.  Also, from my understanding, none of the
        other DOS memory managers (QEMM, NetRoom, FreeDOS' EMM386, etc.)
        support I/O Virtualization.  You will need EMM386 version 4.46 or
        later.  DOS 6.20 came with version 4.48, as did Windows for
        Workgroups 3.11.  Versions of EMM386 that came with any versions of
        DOS or Windows previous to those (including "basic" Windows 3.11) do
        not support I/O Virtualization, and USBJSTIK will only be able to
        emulate analog joysticks using the BIOS in such cases.  I also
        suggest that you use either the NOEMS or FRAME=NONE option with
        EMM386 to disable the Expanded Memory page frame, unless for some
        reason you actually need Expanded Memory.  If you don't actually need
        EMS, it just unnecessarily wastes memory (a LOT of memory).

        You do not need to do anything to USBJSTIK to "turn on" I/O
        Virtualization.  USBJSTIK will automatically enable I/O
        Virtualization if it detects a compatible memory manager.  If you are
        unsure whether or not USBJSTIK is able to Virtualize I/O or not, you
        can use the Status option switch (discussed below in "Miscellaneous
        Notes" on page 138).







              DOS USB DRIVER INTRODUCTION            Page 135 of 186

        Although you can't turn it on or off, there is one option switch that
        does directly affect how I/O Virtualization works.  In the PC, there
        is a range of 16 total I/O ports that are "reserved" for use with
        game ports (joysticks): 200h - 20Fh.  A game port only requires one
        port (not 16), and the default one that all computers use is 201h.
        USBJSTIK will let you select any valid I/O port (between 201h and
        20Fh) for the I/O Virtualization.  For example, to change the I/O
        Port to 209h, you would do the following:

           USBJSTIK IOPort: 209h

        There are VERY few DOS programs that will let you use any port other
        than 201h, so it is rarely a good idea to change it from the default
        of 201h.  However, by changing it, it is possible for you to have a
        regular (analog) joystick attached to your game port (using I/O Port
        201h), and a USB joystick emulating a joystick on some other I/O Port
        at the same time.

        There is also an option switch that indirectly affects how I/O
        Virtualization works.  When emulating an analog joystick using the
        BIOS, the Center option (discussed above in "Normalizing Axis
        Entities, on page 134) controls the axis values that are returned by
        the BIOS.  When emulating an analog joystick using I/O
        Virtualization, the axis values as returned by the BIOS are
        "converted" into a duration of time.  The larger the Center value,
        the longer it take for USBJSTIK to process the I/O Virtualization.
        The details are too complicated too discuss here, and are unimportant
        in most situations.  Just note that the Center value does affect how
        I/O Virtualization works, and changing it (either up or down) may
        help USBJSTIK work better (or worse).


        Descriptors
        ฤฤฤฤฤฤฤฤฤฤฤ

        To display the General Descriptors (Device, Configuration, Interface,
        etc.) of the last joystick or gamepad that was configured by
        USBJSTIK, you would do the following:

           USBJSTIK Descriptors

        A USB joystick is also part of a larger USB classification called
        Human Interface Devices (HID's), and therefore has a special
        Descriptor called an HID Report Descriptor.  The HID Report
        Descriptor "describes", among other things, how many buttons and axes
        and DPads the joystick actually has.  To display the HID Report
        Descriptor of the last joystick that was configured by USBJSTIK, you
        would to the following:

           USBJSTIK ReportDescriptor



              DOS USB DRIVER INTRODUCTION            Page 136 of 186

        Displaying Raw Joystick Data
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        USBJSTIK will also let you look at the Raw (USB) data as it is coming
        from a joystick.  This is virtually a necessity when you are first
        setting up the mapping options for a joystick, since it is usually
        the only way you can figure out which controls (buttons, axes,
        sliders, etc.) are which.  This will also help you to troubleshoot
        joysticks that you are having problems with, or it can just be fun to
        experiment to see how different manufacturers do things with their
        joysticks.

        Because there is so much variation in how different joysticks and
        gamepads are made, USBJSTIK will not let you view the Raw Data for
        all of the USB joysticks at the same time (assuming you have more
        than one).  Rather, you must provide USBJSTIK with a joystick index
        number (between 0 and 7).  For example, to view the raw data for the
        first joystick (index 0), you would do the following:

           USBJSTIK RawData: 0

        Exactly what the display looks like will depend on the exact
        characteristics of the joystick (how many Buttons, Direction-Pads or
        Hat-switches, Axes, Throttles, or Sliders it has).  The "raw" data
        displayed for each control will be the data as it is coming directly
        from the joystick.  Buttons are either on (pressed) or off
        (released), while Axes, Throttles, and Sliders will vary as you move
        them (usually, small numbers if you move left or up or counter-
        clockwise, and large numbers if you move right or down or clock-
        wise).  Direction-Pads and Hat-switches will usually display 0 if
        they are centered, 1 if up, 2 if up and right, 3 if right, ..., 7 if
        left, and 8 if up and left.

        Keep in mind that the display and the numbers that appear in this raw
        data format will probably not look anything at all like the data you
        see from an regular analog joystick.  USBJSTIK takes the raw USB
        data, and then filters, maps, and normalizes it to be able to emulate
        an analog joystick.  This process will completely transform the raw
        data so that it is no longer recognizable.

        When you are through viewing the raw data, you simply press any key
        on the keyboard and USBJSTIK will stop.











              DOS USB DRIVER INTRODUCTION            Page 137 of 186

        Miscellaneous Notes
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        To have USBJSTIK show you the current status of the USB joysticks and
        gamepads that are currently attached to the computer, you would to
        the following:

           USBJSTIK Status

        The upper left portion of the display shows "general" information
        about the USBJSTIK program, such as which protocols are currently
        being used (4-button vs. 15-button, Standard vs. ThrustMaster) and
        which (if any) I/O Port is currently being Virtualized.  The upper
        right portion of the display shows details about the individual
        joysticks that are attached, including the quantity of each type of
        control (Axes, Throttles, etc.).  The bottom of the display shows a
        complete listing of which analog joystick entities are being mapped
        from which USB joystick controls.  The Status option switch tells you
        pretty much everything you need to know about how USBJSTIK is
        currently configured, and should generally be the first place you
        look when you are troubleshooting something.

        I'll admit that setting up the mapping from USB controls to analog
        entities can be very confusing, at least at first.  Once you get it
        figured out the first time, you should "automate" it by setting up
        appropriate configuration files, batch files, environment variables,
        modifying AUTOEXEC.BAT, etc., as needed.  Quite frankly, you're crazy
        if you don't.  This stuff is just way too confusing, and you won't
        remember what you did ten minutes after you did it, much less weeks
        or months later.  You need to automate it as much as you can, with
        lots of comments in the batch and configuration files.

        I've tried to come up with a way to make the mapping more "automatic"
        within USBJSTIK, but was unable to come up with an acceptable method.
        You (the user) still needed some control over exactly how the
        "automation" worked, and this ultimately (at least in my mind) became
        more confusing, and was definitely less flexible, than the way the
        mapping options work now.

        I've seen several joysticks that declare themselves (in their
        descriptors) to have more controls (Axes, Buttons, etc.) than they
        really have.  Obviously, it does no good to map a control that does
        not actually exist to an analog entity, so you should adjust your
        mapping options accordingly if you have a joystick that does this.









              DOS USB DRIVER INTRODUCTION            Page 138 of 186

        Some buttons are actually "mode" buttons; that is, when you press the
        button, the joystick or gamepad will change modes and start behaving
        differently (usually, different axes, buttons, DPads, etc. become
        enabled or disabled).  Mode buttons are more likely to appear on
        gamepads than joysticks, though they can be on either.  Also, some
        mode buttons appear as "regular" buttons and their status is reported
        just like any other button.  Other times, the mode button is "hidden"
        and is not reported through the USB architecture.  If your particular
        USB joystick has a mode button, you will usually NOT want to use it
        as a control that is mapped to an analog entity.  Just make sure you
        set up the mapping in USBJSTIK so the joystick responds exactly like
        you want it to.

        There is no universal, extended joystick BIOS interface.  It would be
        really nice if there was one, which would include all kinds of input
        devices (everything from simple paddles and joysticks to full body
        suits for virtual reality simulations), as well as all kinds of
        output devices (various types of "force feedback").  I've actually
        considered starting to create such an extended BIOS joystick
        interface, but decided against it.  There have been a few half-
        hearted attempts in the past (such as Gravis' GRIP), but none of them
        were ever comprehensive enough or non-proprietary enough to be very
        useful.  Even if an extended BIOS interface were developed, though,
        there would probably never be a DOS program written that would take
        advantage of it.  We will probably be forever stuck using the limited
        analog joystick interface (four buttons, four axes, along with
        various the various twists and permutations) that exists today.


     THRUST
     ฤฤฤฤฤฤ

     Version:     1.16
     Prog Type:   Test
     Source Code: ASM (A86 by Eric Isaacson)
     Status:      Complete
     Environment: None
     Redirection: No
     Purpose:     Joystick tester
     TSR Memory:  0 kB (not a TSR)


     THRUST is a program designed to test your joysticks.  It does this by
     displaying the low-level, "raw" data that is coming from the joysticks,
     either through the joystick BIOS (software) or directly from the
     joystick (game port) hardware.  It's included here as a "companion"
     program to help you test USBJSTIK (discussed directly above on page
     123), but you can also use it to simply test your analog joysticks.





              DOS USB DRIVER INTRODUCTION            Page 139 of 186

     What you will see on the screen when you run THRUST is divided into
     three sections.  At the left will be a description of how THRUST is
     currently interacting with the joysticks: using the joystick BIOS
     (software), or by directly using the hardware (in which case USBJSTIK
     will show you an I/O port number).

     The second section will show you the raw data (numbers) being returned
     by each of the four axes (AX, AY, BX, and BY).  For each particular
     axis, if you move the appropriate control (handle or direction-pad or
     slider or whatever), the displayed number will change.  Usually, moving
     the control left or up or counter-clockwise will make the number get
     smaller, and moving it right or up or clockwise will make the number get
     bigger.  However, if the joystick is using the ThrustMaster protocol
     (described above in "Joystick Protocols" on page 124), the last (BY)
     axis is displaying the status of the (digital) 4-way Hat-switch.  In
     this case, the number in BY will be maximum when the Hat-switch is
     centered, a little lower when up, a little lower yet when right, still
     lower when down, and minimum when left.

     The third and last section of THRUST will display the status of the
     joystick buttons, whether the joystick is using the 4-button or 15-
     button protocol (see "Joystick Protocols" above on page 124 if you don't
     know what this means).  If the joystick is using the 4-button protocol,
     the A1, A2, B1, and B2 columns will display the status of the four
     buttons (whether they are each pressed or not).  If the joystick is
     using the 15-button protocol, the column labeled "15" will display the
     number of the button that is currently pressed (0 = no Button currently
     pressed, 1 = Button #1 pressed, etc.).

     THRUST can interact with the joysticks in two different ways, either
     through the BIOS (software) or directly through the hardware.  The
     default method that THRUST uses depends on whether or not you have a
     digital joystick driver (like my SDWRGMPD or USBJSTIK programs)
     installed in memory or not.  If you do have such a program, THRUST will
     use the BIOS (software) method by default.  If you do not have such a
     program installed, THRUST will use the direct hardware method by
     default.

     No matter which access method THRUST would use by default, you can force
     it to use whichever method you want.  To force THRUST to use the BIOS
     method, you would do the following:

        THRUST B










              DOS USB DRIVER INTRODUCTION            Page 140 of 186

     To force THRUST to use the direct hardware method, you would do the
     following:

        THRUST D #

     where the # (the I/O port number) is optional.  The I/O port number can
     be any number between 200h and 20Fh, which is the range of I/O port
     numbers reserved for game ports.  The default I/O port number that game
     ports use is 201h, which is what THRUST will use if you don't specify a
     number (if you simply do "THRUST D").  Virtually all computers use port
     201h, so there is rarely a reason to specify any other port.  In
     addition to the "D" (Direct), you can also use the alias "P" (Port) or
     "I" (I/O port) to tell THRUST to use the direct hardware method.

     After you are through viewing the raw joystick data, simply press a key
     on the keyboard and THRUST will stop.


     USBDRIVE
     ฤฤฤฤฤฤฤฤ

     Version:     0.18
     Prog Type:   Device/Interface Driver
     Source Code: ASM (A386 by Eric Isaacson)
     Status:      In progress, several major items to address
     Environment: USBDRIVE
     Redirection: Yes
     Purpose:     Driver for up to 8 USB Disk Drives
     TSR Memory:  15.5 - 29.6 kB, depending on configuration


     USBDRIVE is a Device/Interface Driver program for up to eight USB disk
     drives.  Unlike other DOS USB disk driver programs, USBDRIVE is
     installed as a TSR rather than a device driver in CONFIG.SYS.  That
     means that you can load it and unload from memory at any time without
     needing to reboot the computer.  This allows you to set up USBDRIVE so
     that it does not use any memory except when you actually need access to
     the USB disks.  Other DOS USB disk drive programs are installed as DOS
     device drivers via your CONFIG.SYS file.  That means that in order to
     "remove" the USB drives or add new ones, you need to edit your
     CONFIG.SYS file and reboot the computer.  Admittedly, some of the other
     disk drive programs work in certain situations when USBDRIVE does not
     (at least in its current state), but not needing to reboot can save you
     a lot of time and inconvenience.

     USBDRIVE currently supports USB flash drives, media card readers,
     external hard drives, and floppy drives.  It does not currently support
     USB CD-ROM's, DVD's, etc.  Future upgrades to USBDRIVE, or additional
     programs separate from USBDRIVE, will add those capabilities.




              DOS USB DRIVER INTRODUCTION            Page 141 of 186

     You can adjust the amount of memory that USBDRIVE uses by setting the
     number of drives that you want USBDRIVE to be able to access at the same
     time.  There are three separate "layers" of complexity that it takes in
     DOS before you actually get to the point where you have a drive letter
     (like C:) that you can actually use.  You need to tell USBDRIVE how many
     "slots" in each level of complexity you want it to "reserve" for you to
     insert USB disks.  This is complicated, and is explained in the next
     section, "Devices, LUNs, and Drive Letters" (page 142).

     Before USBDRIVE can be installed into memory, you must first have at
     least one USB Host Driver (USBUHCI{L}) installed in memory.  To install
     USBDRIVE into memory using the default settings, you can simply run it
     with no option switches:

        USBDRIVE

     However, you will usually want to be able to control the amount of
     memory that USBDRIVE uses, and therefore will usually want to install
     USBDRIVE into memory with some option switches (at least /Devices:#,
     /Disks:#, and /Drives:#).  This is discussed in the next section.


        Devices, LUNs, and Drive Letters
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        Installing new drives after DOS has already booted is a pretty
        complicated process (much more complicated, than say, installing a
        mouse or a joystick).  It's so complicated, in fact, that most other
        DOS USB drivers don't even attempt to do it -- they make you load the
        drivers in your CONFIG.SYS file instead of as a TSR.  There are
        several "layers" to DOS drives that you should understand as you're
        working with USBDRIVE.  If you don't understand these layers, when
        things don't work like they're supposed to (and they rarely do when
        you're dealing with USB), you won't be able to troubleshoot anything.
        The DOS drive letter (e.g., C:) is simply the top-most layer for
        accessing the disk, though admittedly it is the only one most people
        are used to seeing at all.
















              DOS USB DRIVER INTRODUCTION            Page 142 of 186

           Device/Interfaces (Devices)
           ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

           The lowest layer for disks is the physical hardware interface
           (bus) that the device uses to "talk" to the computer.  Types of
           hardware interfaces include MFM & RLL (on really old computers),
           SCSI, ATA/IDE, SATA, and, of course, USB.  You can usually have
           more than one device attached to a single bus, and they don't
           necessarily need to all be disk drives (also known as "mass
           storage devices").  In the USB world, this is the
           Device/Interface, and each USB Device/Interface will have a USB
           Host Index, Device Address, and Interface number associated with
           it.  In USB, a single Device/Interface is usually the physical
           "thing" that plugs into a single port on a USB Hub.

           You control the maximum number of USB Device/Interfaces that
           USBDRIVE can manage at one time by using the /Devices:# option.
           This option must be entered when USBDRIVE is first installed into
           memory.  After USBDRIVE has been installed, the only way to change
           the maximum number of Device/Interfaces is to uninstall USBDRIVE
           from memory and then re-install it with a different /Drives:#
           option.

           The # in the /Drives:# option switch is the maximum number of
           Device/Interfaces that you want USBDRIVE to be able to control at
           one time.  This must be a number between 1 and 8, with the default
           being 4.  For example, to set the maximum number of
           Device/Interfaces to 2, you would install USBDRIVE as follows:

             USBDRIVE Devices:2

           Each additional Device/Interface adds 76 bytes to the total memory
           requirements of USB (the amount of RAM used by the TSR), so this
           should be set to the minimum number you think you might need.  For
           instance, if you want to be able to copy or move data between two
           different USB disks, you probably will want this set at 2 (or
           perhaps even more).  If you only plug in one USB disk at a time
           (for example, if you only have one available hub port, or you only
           have one available flash drive, or you never transfer data
           directly between USB drives), you will probably want to set the
           maximum number of Device/Interfaces to 1.












              DOS USB DRIVER INTRODUCTION            Page 143 of 186

           LUNs (Disks)
           ฤฤฤฤฤฤฤฤฤฤฤฤ

           In USB, each Device/Interface can have multiple devices "inside"
           it.  These are called Logical Unit Numbers (LUNs).  Flash drives,
           external hard drives, and floppy drives usually only have one LUN
           (Disk) per Device/Interface, but there are some kinds of
           Device/Interfaces that have more than one LUN (like the media card
           readers designed to read all of the different memory cards
           commonly used in cameras).  In USBDRIVE, each LUN is assigned a
           physical disk number (also called an "INT 13h Disk Number").  This
           corresponds to a physical disk number that is assigned to the
           "normal" internal disks your computer has (IDE/ATA, floppy, etc.).
           Floppy disks are normally assigned physical disk numbers 00h and
           01h, while hard drives are assigned numbers starting at 80h (80h
           is the first hard drive, 81h the second, etc.).  Note that this is
           NOT the same as a drive letter.  Physical disk 00h usually
           corresponds to A:, 01h usually corresponds to B:, and 80h usually
           contains C:, though that is not always true.  Assuming this is
           true is where most people get confused and run into problems.

           You control the maximum number of Disks (LUNs) that USBDRIVE can
           manage at one time by using the /Disks:# option.  This option must
           be entered when USBDRIVE is first installed into memory.  After
           USBDRIVE has been installed, the only way to change the maximum
           number of Disks is to uninstall USBDRIVE from memory and then re-
           install it with a different /Disks:# option.

           The # in the /Disks:# option switch is the maximum number of Disks
           (LUNs) that you want USBDRIVE to be able to control at one time.
           This must be a number between 1 and 16, with the default being 8.
           For example, to set the maximum number of Disks (LUNs) to 5, you
           would install USBDRIVE as follows:

             USBDRIVE Disks:5

           Note that a maximum number of Disks set to 5 would allow you to
           control a regular flash drive (which usually has only one LUN) and
           a media card reader (which usually has 4 physical slots and,
           consequently, 4 LUNs) at the same time.

           Each additional Disk adds 202 bytes to the total memory
           requirements of USBDRIVE (the amount of RAM used by the TSR), so
           this should be set to the minimum number you think you might need.
           If you don't have a media card reader (which will usually have 4
           LUNs/Disks per Device/Interface), you will probably want to set
           the maximum number of Disks and the maximum number of Devices
           (discussed in the section directly above this one) to the same
           value.




              DOS USB DRIVER INTRODUCTION            Page 144 of 186

           Drive Letters (Drives)
           ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

           Each physical disk can be further divided into multiple
           partitions.  Floppy disks are not divided into partitions, while
           hard disks many times are.  Microsoft Windows usually tries to set
           up the entire hard drive as one gigantic partition, even if you
           don't want it to.  If you have multiple operating systems on the
           same computer, you will almost always have multiple partitions.
           If there are multiple partitions on a disk, DOS assigns drive
           letters to the ones that are the correct type (FAT12, FAT16, and
           FAT32 if the DOS is new enough), assuming the LASTDRIVE setting in
           CONFIG.SYS is large enough to handle all of the Drives.

           There is a maximum number of Drive Letters that can be assigned by
           DOS, which is determined when DOS is booted.  Once DOS has booted,
           it is impossible to change the number of available Drive Letters.
           You control the number of available Drive letters with the
           LASTDRIVE setting in CONFIG.SYS.  DOS itself requires 88 bytes for
           each Drive Letter, so the amount of memory DOS uses is directly
           affected by the LASTDRIVE setting.

           USBDRIVE also has a /Drives:# option that lets you control how
           many drive letters you want USBDRIVE to assign and manage.  Note,
           however, that no matter what you set the /Drives:# value to, if
           the LASTDRIVE setting in CONFIG.SYS is too small, it doesn't
           matter.  In addition to the disks that DOS automatically assigns
           Drive Letters to while it is booting, you can also consume drive
           letters after DOS has booted with DOS-provided utilities like
           ASSIGN and SUBST, CD-ROM & DVD utilities like MSCDEX, RAMDisk
           utilities, and networking software like Novell Netware, LANtastic,
           etc.  In short, it is a combination of LASTDRIVE, other software,
           AND the /Drives:# option that determines how many drive letters
           USBDRIVE can actually assign and manage.

           Also note that you don't necessarily need USBDRIVE to assign a
           drive letter at all to a disk partition in order for USBDRIVE to
           be useful to you.  USBDRIVE also allows you to use physical-level
           utilities like FDISK and various formatting programs to view and
           modify USB disks, which don't work at the DOS level and therefore
           do not need any DOS drive letters to be assigned.  USBDRIVE will
           not let you select 0 as the number of drive letters it will assign
           and manage, however, even if you don t actually need it to assign
           any (because you will only be accessing a disk at the physical
           level).








              DOS USB DRIVER INTRODUCTION            Page 145 of 186

           You control the maximum number of Drive Letters that USBDRIVE can
           manage at one time by using the /Drives:# option.  This option
           must be entered when USBDRIVE is first installed into memory.
           After USBDRIVE has been installed, the only way to change the
           maximum number of Drives is to uninstall USBDRIVE from memory and
           then re-install it with a different /Drives:# option.

           The # in the /Drives:# option switch is the maximum number of
           Drive Letters that you want USBDRIVE to be able to control at one
           time.  This must be a number between 1 and 16, with the default
           being 8.  For example, to set the maximum number of Drives to 2,
           you would install USBDRIVE as follows:

             USBDRIVE Drives:2

           Each additional Drive adds 192 bytes to the total memory
           requirements of USBDRIVE (the amount of RAM used by the TSR), so
           this should be set to the minimum number you think you might need.
           For example, if you want to be able to copy or move data between
           two different USB devices, or between two partitions on the same
           disk, you probably will want this set at 2 (or perhaps even more).
           If you only plug in one USB disk at a time, and it only has one
           partition on it, you will probably want to set the maximum number
           of Device/Interfaces to 1.


        Viewing USBDRIVE Status
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        USBDRIVE allows you to view the details of the USB devices it is
        controlling (capacity, FAT type, etc.) in two different ways.  The
        first way is with the Status option, as follows:

           USBDRIVE Status

        This will show you the status of the USB devices from the perspective
        of USBDRIVE.  That is, it will be sorted first by Device/Interface,
        then by Disk/LUN (possibly with multiple Disks per Device), and
        finally by Partition/Drive Letter (possibly with multiple Drive
        Letters per Disk).  Device/Interface details include Host Index,
        Device Address, and Interface Number.  Disk/LUN details include
        Cylinder/Head/Sector totals for the disk.  Partition/Drive Letter
        details include Drive Letters and Partition Capacities.

        The second way for USBDRIVE to show you the details is with the
        DriveStatus option, as follows:

           USBDRIVE DriveStatus





              DOS USB DRIVER INTRODUCTION            Page 146 of 186

        This will show you the status of the USB drives from the perspective
        of DOS Drive Letters.  This will show you the DOS Drive Letter,
        followed by the physical disk number that the drive is on, followed
        by the partition information associated with the drive letter
        (including FAT type), followed by the capacity information.  Some of
        the information contained in the /DriveStatus option is the same as
        that contained in the /Status option, but they look very different
        because of their perspective (low-level to high-level vs. high-level
        to low-level).

        The DRIVES program discussed below (page 164) shows you information
        about ALL of the drive letters in DOS, not just the ones that
        USBDRIVE is managing.  It is interesting (at least to me) to see how
        DOS views disk drives, since it is not at all what I originally
        expected it to be.  For instance, until DOS actually accesses (reads
        from) a drive, DOS doesn't know the capacity of the drive, and DOS
        doesn't access a drive until it actually needs to for some reason.
        Therefore, what DOS "thinks" about a particular drive is usually
        wrong until you force it to think correctly.


        Assigning Drive Letters
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

           Current Directory Structure (CDS)
           ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

           There is a table in DOS, called the Current Directory Structure
           (CDS), which keeps track of the DOS drive letters.  The number of
           entries in the table is determined by the LASTDRIVE setting in
           your CONFIG.SYS file, and cannot be changed once the computer has
           booted up.  During the boot process, DOS fills in the CDS with
           information about your physical disks (floppies and hard drives)
           and any special device drivers (like RAM disks) you have in your
           CONFIG.SYS file.  If there are more drive letters available than
           there are physical disks, some of the CDS entries are simply left
           blank.  After DOS has booted, the available drive letters can be
           used for other things (network drives, CD-ROMs, SUBST'd or
           ASSIGN'd drives, etc.).














              DOS USB DRIVER INTRODUCTION            Page 147 of 186

           As USBDRIVE is installing itself into memory, it "reserves" some
           of the drive letters in the CDS.  The number of drive letters it
           reserves is determined by a combination of the /Drives:# option
           and the number of available (empty) CDS entries.  That is, the
           number of CDS entries it reserves may be less than what is in the
           /Drives:# option if there aren't enough empty entries available.
           Remember that when USBDRIVE is first installed into memory, it is
           not actually controlling any USB drives at all -- that happens
           later (USBDRIVE searches for and manages USB drives as a
           background process).  As USB devices are plugged and unplugged
           from the bus, USBDRIVE assigns and un-assigns the drive letters
           that it reserved upon installation.

           By default, the process that USBDRIVE uses to determine which
           drive letter(s) to reserve is as follows.  USBDRIVE starts with
           the third entry in the CDS table (the one associated with the C:
           drive letter).  If it is unavailable (already used), it goes to
           the next one (the D: drive letter).  When it finds an available
           (unused) CDS entry, it "reserves" it.  USBDRIVE keeps searching
           until it reaches the end of the table (corresponding to the
           LASTDRIVE setting in CONFIG.SYS), or until the number of requested
           drives (in the /Drives:# option) has been assigned.

           USBDRIVE does not give you complete control over which drive
           letters get assigned to the USB drives.  However, USBDRIVE does
           have an option that gives you some control.  The /DriveLetter:#
           option allows you to control where in the CDS table that USBDRIVE
           will start searching.  That is, it allows you to tell USBDRIVE to
           start searching somewhere other than the C: drive letter entry.
           For example:

             USBDRIVE DriveLetter:G

           will cause USBDRIVE to start searching at the seventh CDS entry
           (associated with the G: drive) instead of the third (the C: drive
           letter).  When USBDRIVE reaches the end of the CDS table, it will
           "wrap around" back to the C: drive again and continue searching.

           You must provide a letter between C and Z to the /DriveLetter:#
           option.  USBDRIVE will never assign USB devices to the A: or B:
           (floppy) drive letters.  Assigning an A: or B: (floppy) drive
           letter to a disk that is not actually a floppy can cause all sorts
           of undesirable behavior in DOS, but assigning a hard disk drive
           letter (C:-Z:) to a floppy drive is usually not a problem.









              DOS USB DRIVER INTRODUCTION            Page 148 of 186

           In addition to the /DriveLetter:# option, there is another way you
           can gain additional control over which drive letters are reserved
           by USBDRIVE.  You can use the DOS ASSIGN or SUBST utilities to
           temporarily make certain drive letters unavailable while USBDRIVE
           is being installed, and then make the drive letters available
           again after USBDRIVE is done.  For example, if you do not want
           USBDRIVE to "reserve" drives D: and E: for some reason, you could
           do the following (you would probably want to automate this process
           with a batch file):

             SUBST D: C:\    Reserve D: with SUBST
             SUBST E: C:\    Reserve E: with SUBST
             USBDRIVE        Let USBDRIVE start at F:
             SUBST E: /D     Restore E: to normal/unused
             SUBST D: /D     Restore D: to normal/unused

           In addition, after USBDRIVE has reserved its drive letters, you
           can use ASSIGN or SUBST on the USB drives to create "alias" drive
           letters for the various USB drives and directories.  Incidentally,
           this points out another advantage of using TSR's (after DOS has
           booted) rather than using DOS device drivers (CONFIG.SYS).  You
           have no control whatsoever over the drive letters that get
           assigned for drivers that are loaded via CONFIG.SYS (DOS assigns
           them automatically).


           FAT32 Partitions
           ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

           USBDRIVE assigns drive letters to every partition it finds on a
           disk that is designated as FAT12 or FAT16.  In addition, USBDRIVE
           will assign drive letters to partitions designated as FAT32 if it
           believes the version of DOS you are using can support FAT32
           drives.  The first version of Microsoft DOS that supported FAT32
           was 7.10 (DOS 95 OSR 2), so USBDRIVE assumes that your computer
           will support FAT32 if it claims to be DOS version 7.10 or later.
           Note that non-Microsoft versions of DOS do NOT report their actual
           version numbers, but rather return the "closest" Microsoft version
           in terms of compatibility.  For example, DR-DOS 7.03 claims to be
           DOS version 6.00, and FreeDOS 1.0 claims to be DOS version 7.10.

           There is a switch option to override USBDRIVE's default behavior
           regarding FAT32 drives.  If you want USBDRIVE to assign drive
           letters to USB partitions that are FAT32, no matter what version
           your DOS claims to be, you would do the following:

             USBDRIVE FAT32: Yes






              DOS USB DRIVER INTRODUCTION            Page 149 of 186

           Keep in mind that if you allow USBDRIVE to assign drive letters to
           FAT32 drives when your DOS doesn't support them, and you try to
           read something from the drive, you will probably see a bunch of
           garbage that doesn't make any sense at all.  If you try to write
           to the drive, you will probably screw it up (possibly beyond
           repair).

           If you do NOT want USBDRIVE to assign drive letters to FAT32
           drives, even if your DOS claims to be version 7.10 or later, you
           would do the following:

             USBDRIVE FAT32: No


           Legacy Support for Disks
           ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

           There are also potential issues with drive letters if the USB
           drives are already configured using Legacy Support (in the BIOS).
           This can be a particularly serious problem if the computer was
           booted from a USB drive, or if the current drive (in DOS) is a USB
           drive.

           When the Host Controller Driver (USBUHCI{L}) takes control of a
           bus, all of the Device/Interfaces currently attached to the bus
           are reset and stop working (at least temporarily).  There is no
           mechanism to ensure a "smooth" transition from the BIOS (Legacy
           Support) drivers to the Operating System drivers for disk drives.

           All of the entries in the Current Directory Structure that the
           Legacy Support drivers were managing instantly become invalid when
           the Operating System host driver (like USBUHCI{L}) starts working,
           and the computer will probably crash if you try to access those
           particular drive letters.  After USBDRIVE begins to manage the
           disk Device/Interfaces, they will be assigned new drive letters,
           which will be completely different than the original drive letters
           that were assigned during the boot process.  After all is said and
           done, you can end up with an ugly, complicated mess on your hands.
           Things may get even worse if you decide to remove USBDRIVE and
           USBUHCI{L} from memory and try to revert back to Legacy Support.

           I personally do not boot from USB drives, nor do I use Legacy
           Support for disk drives.  Therefore, at least in this version of
           USBDRIVE, I have not tried to figure out a solution to the Legacy
           Support issues.  I suspect there might be a "smooth" way to
           perform the transition from Legacy Support to Operating System
           support for disk drives, but the implementation will need to wait
           for awhile.  In the meantime, you'll just need to be very careful
           if you use Legacy Support for USB Disk Drives.




              DOS USB DRIVER INTRODUCTION            Page 150 of 186

        Assigning Physical Disk Numbers
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        In a manner similar to the DOS drive letters discussed in the section
        directly above ("Assigning Drive Letters"), DOS also has a mechanism
        to keep track of physical disk numbers.  While it is installing,
        USBDRIVE "reserves" physical disk numbers that it will assign and un-
        assign to the Logical Unit Numbers (LUN's) of the USB Devices that
        get plugged and unplugged.  The quantity of physical disk numbers
        that USBDRIVE reserves is equal to the /Drives:# option switch
        provided during installation.  Unlike the number of Drive Letters
        which are limited by the LASTDRIVE setting in CONFIG.SYS, there
        should always be enough available physical disk numbers for USBDISK
        to use.

        Note that you usually do not "see" the physical disk numbers in daily
        operations with DOS, even though they are there lurking in the
        background and are very important.  You usually only see the physical
        disk numbers when you are working with low-level formatting and
        partitioning utilities like FDISK.

        When USBDRIVE "reserves" a physical disk number, it essentially
        configures it as a "removable hard disk" (with physical disk number
        starting at 80h), not as a floppy disk.  Unfortunately, Microsoft's
        FDISK program has a serious bug in it, and doesn't work correctly
        with "reserved" physical disk numbers (removable hard disks), even
        though removable hard disks have been around since the early 1980's.
        As Microsoft's FDISK is searching for all of the hard disks, as soon
        as it comes across a "reserved" disk with no media, it immediately
        crashes and terminates.  It won't even let you look at or configure
        the disks that it considers "legitimate".

        There are two ways around this problem with MS FDISK.  The first is
        to always make certain the you have media inserted (USB Devices) for
        all possible physical disk numbers (corresponding to the /Disks:#
        option switch in USBDRIVE) before running MS FDISK.  If the removable
        hard drive has media inserted, MS FDISK works OK.  The second way
        around this problem is to not use MS FDISK, but to use another disk
        partitioning program instead.  The FDISK program that comes with
        FreeDOS, Ranish Partition Manager, and possibly other disk
        partitioning programs do not have this problem.  I personally
        recommend using Ranish Partition Manager (available at
        http://www.ranish.com) for reasons described below in "Partitioning &
        Formatting" (page 152).  I find it much easier to use than any of the
        FDISK programs.








              DOS USB DRIVER INTRODUCTION            Page 151 of 186

        SCSI Inquiry Responses
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        Nearly all USB disks use what is called the SCSI Transparent
        Protocol.  This means that even though at the hardware level the disk
        attached to a USB bus rather than a SCSI bus, at the software level
        the disk responds to the SCSI command set.  Unfortunately, even
        though all USB disks claim to be compatible with the SCSI command
        set, many of them are only partially compatible.  Some of them do not
        respond appropriately to all of the SCSI commands like they're
        supposed to.  This "partial compatibility" is the main reason that
        USBDRIVE, and other USB disk drive programs, do not work correctly
        with all of the different disks they come in contact with.  If all of
        the disk manufacturers truly followed the standards, the world would
        be a much better place.

        One of the SCSI commands that all USB disks are required to respond
        to is called an Inquiry Request.  The data returned from the Inquiry
        Request includes the manufacturer (vendor), model (product), and
        version of the drive.  This information is both interesting and
        useful.  It is interesting because many times it is not what you
        expect it to be.  It is useful in situations where you have several
        different USB disks on the computer at the same time, and need help
        figuring out which one is which when you get confused.  To display
        the Inquiry Response data for all of the attached USB disks, you
        would do the following:

           USBDRIVE InquiryData


        Partitioning & Formatting
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        USBDRIVE should be compatible with most disk management and
        manipulation programs you want to use with it.  There are only two
        programs that I know of that do not work with USBDRIVE, though there
        could possibly be others.

        The first program I know of that does not work correctly is
        Microsoft's FDISK partition management program (the one that comes
        with MS-DOS).  As discussed above in "Assigning Physical Disk
        Numbers" (page 151), MS FDISK does not work correctly (crashes) with
        removable hard disks that currently have no media (like a USB Device
        that is currently unplugged).  The other partition management
        programs that I have used, FreeDOS's FDISK and Ranish Partition
        Manager, do not have this problem.







              DOS USB DRIVER INTRODUCTION            Page 152 of 186

        The second program that does not work correctly is SFORMAT (Safe
        Format) that comes with the Norton Utilities for DOS.  SFORMAT is
        specifically designed to format floppy drives (not hard drives).
        However, if you use USBDRIVE to mount a USB floppy drive in DOS, you
        cannot use SFORMAT to format the floppy drive.  I'm not sure exactly
        what it is that SFORMAT doesn't like about the USB floppies, but
        suspect it has something to do with the fact that USBDRIVE sets up a
        USB floppy drive to look like a removable hard disk rather than a
        true floppy drive.  In any event, the MS-DOS FORMAT utility works
        just fine on USB floppy drives.

        One additional problem I have seen when trying to format USB floppy
        drives is that you may not be able to change the size of the disk.
        That is, you may not be able to re-format a floppy disk that was
        originally 720kB into one that is 1.44MB, or vice versa.  At least I
        am not able to do it on my computers using the USB floppy drive I
        have that is manufactured by TEAC.  I don't know for sure if this is
        a problem with USBDRIVE, USB floppy drives in general, with TEAC, or
        just with the particular model of TEAC drive that I have.  I can tell
        you, however, that I am not able to re-format the disk to a different
        size in MS-Windows, either, so suspect the problem is in the USB
        floppy drive itself rather than with USBDRIVE.

        After you manipulate a USB disk at a low level (messing with
        partitions or formatting), you should reset the disk to force USBDISK
        to re-read the contents.  You can either unplug and replug the disk,
        issue a USB software reset, uninstall and re-install USBDRIVE, or
        reboot the computer.  If you don't reset the disk, there's a
        potential for you to really screw up the data that is stored on the
        disk.  Sometimes USBDRIVE can recognize that the disk has changed,
        and sometimes it can't.  It's always safest to Reset.  Note that with
        USB disks that are not managed by USBDRIVE (including those managed
        by BIOS Legacy Support), you usually need to reboot the computer for
        the disk to get reset properly.  With USBDRIVE, you do not
        necessarily need to reboot when a disk changes (though you certainly
        can if you want to).  USBDRIVE has a Reset option (discussed below on
        page 155) that you can use to Reset a USB disk if you need to.


        Low-Level Formatting
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        There are two different types of formatting you can do to a disk: a
        high-level format and a low-level format.  A high-level format simply
        erases the data on the disk by re-writing the File Allocation Table.
        The MS-DOS FORMAT utility only does a high-level format to hard
        drives.  A low-level format actually re-creates the physical tracks
        on the magnetic media, making sure that the read/write heads and the
        magnetic tracks are perfectly aligned.  The MS-DOS FORMAT utility
        does both a low-level format and a high-level format to floppy
        drives.


              DOS USB DRIVER INTRODUCTION            Page 153 of 186

        It is relatively rare for a hard drive to need a low-level format,
        because of the "rigid" nature of the disk mechanics (the heads and
        tracks rarely get out of alignment).  When you do need to low-level
        format a hard drive, you can't use the MS-DOS FORMAT utility to do
        it.  The process required to low-level format a hard drive is
        hardware-dependent (different for each manufacturer and model), and
        is built into the BIOS of the hard drive.  The MS-DOS FORMAT utility
        does not know how to access the BIOS low-level format function
        because it is different for each disk.  For example, in the old MFM &
        RLL drives that were used in early computers, you could usually start
        the low-level formatting routine by loading the DOS DEBUG program and
        typing "G=C800:5".  Unfortunately, that doesn't work on modern hard
        disks.

        With SCSI disks (which includes USB disks), there is a special SCSI
        request that is issued to the disk BIOS that causes the disk to be
        low-level formatted.  You can tell USBDRIVE to low-level format a USB
        disk as follows:

           USBDRIVE LowLevelFormat #

        where the # is the physical disk number (INT 13h disk number) of the
        Disk/LUN.  For most computers (which only have one "real" hard disk
        numbered 80h), the first USB disk will probably be physical disk
        number 81h (129 decimal).  You can determine the physical disk number
        with the /Status option switch for USBDRIVE.

        USBDRIVE simply issues a SCSI format request to the disk.  I have not
        actually tried issuing a SCSI format request to an external USB hard
        disk, but it should work (assuming the disk is really SCSI-compatible
        like it's supposed to be).  The story is a little bit different for
        USB flash drives, however.  Remember that the main purpose of a low-
        level format is to re-align the heads and tracks of the magnetic
        media.  Flash drives are solid-state and don't actually have heads or
        tracks or magnetic media, so there is nothing to align.  Trying to
        low-level format a flash drive could either do nothing, or it could
        simply destroy the data on the disk (overwrite the entire disk with
        zeroes or some random data pattern).

        I have tried issuing a SCSI format request to a few different USB
        flash drives just to see what would happen.  On the flash drives I've
        tried, some have simply outright rejected the SCSI format request as
        an invalid request, while others have accepted the SCSI request but
        did not actually do anything to the disk (did not erase or change any
        data).  If you want to experiment with formatting your flash drives,
        you certainly can.  Just be aware that it could destroy any data that
        is on the disk, so make sure there's nothing on the disk that you're
        not willing to lose forever.





              DOS USB DRIVER INTRODUCTION            Page 154 of 186

        Resetting Disks
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        There are times when it is necessary to perform a reset on a USB
        device, including USB disk drives.  A reset can either be performed
        by physically unplugging and re-inserting the device into a hub port,
        or by performing a "soft reset" on the device using software.
        Normally, the way you issue a soft reset to a USB device is through
        the host controller driver (USBUHCI{L}), but this requires you to
        know the Host Index and Device Address of the device you want to
        reset.

        If you want to perform a soft reset on a particular USB disk,
        USBDRIVE provides a way for you to do it without needing to
        "translate" the disk information into a USB Host Index and Device
        Address, as follows:

           USBDRIVE Reset #

        where the # is the Index (in USBDRIVE) of the USB device you want to
        reset.  The Index is a 0-based number, and is listed in the first
        column of the output of the /Status option switch in USBDRIVE.  The
        first device has Index 0, the second has Index 1, etc.  If you only
        have one USB disk device plugged in, it will usually be Index 0.  The
        /Status option also shows the USB Host Index and Device Address if
        you want to reset the disk using USBUHCI{L} instead of using
        USBDRIVE.  They both accomplish the same result -- the switch option
        is USBDRIVE is just there to make it more "convenient".


        Troubleshooting
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        USB disks are the most unreliable, flaky USB Devices I have come
        across so far.  I have FAR more trouble with them than I do with
        printers, mice, keyboards, or joysticks.  The main problem with USB
        disks is that they are not completely compatible with the SCSI
        command set, even though they're supposed to be.  If you're having
        problems getting a particular disk to work with USBDRIVE, there are a
        few tools and tricks you can use that will sometimes fix the problem,
        or at least help you to figure out what and where the problem might
        be.











              DOS USB DRIVER INTRODUCTION            Page 155 of 186

           Bad Devices
           ฤฤฤฤฤฤฤฤฤฤฤ

           When a USB drive does not configure correctly with USBDRIVE, the
           Bad option switch is usually the first place to start
           troubleshooting.  Simply do the following:

             USBDRIVE Bad

           This will give you details about exactly where during the complex
           initialization process that the failure occurred.  Unfortunately,
           the information provided is rather cryptic, and unless you're
           familiar with the inner workings of USBDRIVE, it won't make any
           sense.  You will need to download the source code for USBDRIVE to
           do any significant troubleshooting.


           Internal Buffers
           ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

           As USBDRIVE is initializing a particular disk, it attempts to
           download several separate groups of data from the disk.  These are
           issued as SCSI requests to the disk drive (USB disks almost always
           use the SCSI software protocol).  The SCSI Requests that USBDRIVE
           issues are called Inquiry, Read Format Capacities, Read Capacity,
           and Mode Sense (if you are familiar with SCSI, you should already
           be familiar with what all of those are).  In addition, USBDRIVE
           will download at least one sector's worth of data from the disk in
           order to figure out if and how the disk is partitioned.

           USBDRIVE downloads all of this data into buffers in the TSR, and
           USBDRIVE has an option switch to let you see what's in the
           buffers.  Again, what you see there is rather cryptic, but can be
           very informative about how the disk is responding to various
           requests (at least if you have basic understanding of the SCSI
           protocols).  Note that USBDRIVE only has one set of buffers, which
           are reset and reused each time it tries to initialize a new disk.
           Therefore, the data in the buffers will only be valid for the last
           disk that USBDRIVE tried to initialize.  To view the contents of
           the buffers, you do the following:

             USBDRIVE Buffers











              DOS USB DRIVER INTRODUCTION            Page 156 of 186

           SCSI Error Codes
           ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

           The SCSI software protocols are fairly comprehensive, and when a
           particular SCSI request fails for some reason the device returns a
           detailed set of error codes that describe why the request did not
           work.  USBDRIVE keeps track of the last 10 SCSI requests that
           returned errors for each Disk/LUN, so that you can view them if
           you want to.  When a USB disk doesn't appear to be working
           correctly, viewing the last several errored SCSI requests may help
           you to recognize some sort of pattern as to why things aren't
           working correctly.  To view the SCSI error codes for a particular
           disk, you do the following:

             USBDRIVE ASCQHistory #

           where the # is the physical disk number (INT 13h disk number) of
           the Disk/LUN.  For most computers (which only have one "real" hard
           disk numbered 80h), the first USB disk will probably be physical
           disk number 81h (129 decimal).  You can determine the physical
           disk number with the /Status option switch for USBDRIVE.

           What USBDRIVE displays on the screen for each of the 10 entries
           will be the SCSI Request Type, the Sense Key, the Additional Sense
           Code, and the Additional Sense Code Qualifier.  Here is a typical
           example:

             SCSI Request 00h = Test Unit Ready
             Sense Key    06h = Unit Attention (Target Reset)
             ASC/Q Code 2800h = Not Ready to Ready Transition, Medium Change

           Again, if you're already familiar with the SCSI protocols, this
           probably makes sense to you.  If not, you'll probably need to
           study up on SCSI if you want to do any effective troubleshooting
           with USB disks.  Hopefully, everything will work just fine for you
           and you'll never need to do any troubleshooting.


           Delaying Initialization
           ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

           Sometimes, USB drives (like SCSI drives) need a little bit of time
           to "spin up" before they will initialize properly.  However, most
           USB drives (especially flash drives) do not need any "spin up"
           time.  Therefore, by default, USBDRIVE will not delay at all after
           it detects a new disk before it tries to initialize it.  USBDRIVE
           lets you adjust the Delay value to anything between 0 and 60
           seconds.  For example, to set the delay to 5 seconds, you would do
           the following:

             USBDRIVE Delay 5


              DOS USB DRIVER INTRODUCTION            Page 157 of 186

           I leave the delay set at the default of 0 on all of my computers,
           since none of the disks I use require extra initialization time.
           If a disk doesn't initialize properly, try changing the delay
           value (make it bigger) and see if it helps.  If leaving the
           setting at 0 works (as it does for me), USBDRIVE will load things
           much quicker for you.


           Sector Transfer Size
           ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

           Some disks, for whatever reason, are "slow" and do not allow
           USBDRIVE to transfer data at the maximum possible speed.  What
           usually happens on these drives is that you will be in the middle
           of transferring some files, and it will stop in the middle of the
           data transfer with a "Drive Not Ready" error message.

           When a program asks to transfer a large amount of data at one
           time, USBDRIVE may need to break up the request into smaller
           "chunks" -- small enough that each chunk can be transferred
           without errors.  Decreasing the amount of data that is transferred
           in each chunk usually increases the reliability, but also usually
           decreases the overall data transfer speed.

           You control the size of each data chunk as follows:

             USBDRIVE MaximumSectors: #

           where the # is the maximum number of sectors that USBDRIVE will
           transfer in each data chunk.  The # can be any number between 1
           and 64, with smaller numbers generally leading to increased
           reliability but decreased data transfer speed.  The default value
           that USBDRIVE uses is 1, which means that data transfers are slow,
           but usually very reliable.  On my computers, I set the value to 4
           since that is the is the largest value that works reliably on all
           of my disks.  I have one particular disk (made by Sandisk) that
           works with the maximum value of 64, but none of my other drives
           do.  You will probably want to experiment with your particular
           disks, see what happens, and configure USBDRIVE accordingly.  If
           you discover any interesting patterns or relationships, please let
           me know.












              DOS USB DRIVER INTRODUCTION            Page 158 of 186

           Following is a chart that shows how the data chunk size affects
           transfer speed.  This data for this chart was created by making a
           large file (26,762,776 Bytes) on the Sandisk drive I have that
           works OK using a maximum transfer sector size of 64, formatted
           with FAT32, and doing a "COPY FileName NUL" command at a DOS
           command prompt.  There were no other devices on the USB host
           controller except the Sandisk flash drive.  Copying to NUL instead
           of another disk eliminates possible hardware effects of the other
           disk, so gives a true indication of the speed of the USB disk
           itself.  The chart should be used as a relative rather than
           absolute speed comparison -- as the saying goes, "your mileage may
           vary".

             Maximum  Xfer Time  Xfer Speed
             Sectors  (Seconds)    (Mbps)
             -------  ---------  ----------
                   1     643.40        0.33
                   2     343.23        0.62
                   4     175.54        1.22
                   8     134.51        1.59
                  16     198.88        1.08
                  32     118.42        1.81
                  64     107.87        1.98

           Note that increasing the data chunk size doesn't necessarily
           always increase the speed.  In the chart above, increasing the
           maximum transfer sector size from 8 to 16 actually decreased the
           data transfer speed.  I'm not sure exactly why this happened, but
           think it has something to do with the relationship between data
           chunk sizes and the USB frame timing.  For each chunk of data that
           gets transferred, there are actually several USB transactions that
           take place on the bus.  If a piece of the transaction completes
           near the beginning of a frame (which happens every millisecond)
           instead of near the end, the process must wait nearly one full
           millisecond (until the start of the next frame) before it can move
           forward to the next step.  In addition, factors such as the host
           controller manufacturer and model, disk manufacturer and model and
           size and FAT type, number and type of hubs between the disk and
           the root hub, number and type of other devices on the bus, etc.,
           may all affect the data transfer speed.













              DOS USB DRIVER INTRODUCTION            Page 159 of 186

           Using USBASPI
           ฤฤฤฤฤฤฤฤฤฤฤฤฤ

           The initialization process the USBDRIVE goes through appears to be
           "incomplete" for some drives.  For drives that have this problem,
           they "stall out" very early in the initialization process,
           sometimes even while the Host Driver (USBUHCI{L}) is attempting to
           do the "high level" initialization (before USBDRIVE even gets into
           the picture).  Some of the drives that do this work with other DOS
           USB driver programs, and in particular the popular ones that are
           available from the Panasonic site in Japan (USBASPI.SYS &
           DI1000DD.SYS).  As it turns out, you can sometimes use the
           USBASPI.SYS file to "fix" USBDRIVE so that it works with these
           particular drives.

           The USBASPI.SYS file is actually a combination device driver
           (.SYS) file and executable (.EXE) file.  When used as a .SYS file
           (loaded in CONFIG.SYS), it installs itself into memory and starts
           to manage the USB disks.  However, when used as an .EXE file, all
           it does is initialize the USB drives that it finds, but does not
           install itself into memory or manage anything.  What you need to
           do is rename the USBASPI.SYS file to USBASPI.EXE, and then run it
           immediately before you load these USB drivers into memory.  For
           example:

             USBASPI
             USBUHCIL
             USBDRIVE

           I'm not sure exactly what USBASPI "resets" in the drives that lets
           USBDRIVE work afterwards, but it obviously does something.  I have
           contacted the Japanese company that wrote USBASPI (Novac)
           regarding obtaining the source code for USBASPI, but they have not
           yet responded to my request (and I suspect that they never will).
           At some point in the future, I may try to reverse-engineer USBASPI
           and try to figure out how they do it.  In the meantime, you may
           need to use USBASPI to "fix" USBDRIVE as detailed above.  I
           personally do not own any disk drives that need the USBASPI fix,
           but some others have reported it helps in certain situations.


           Sandisk U3 Software
           ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

           Most (if not all) USB flash drives made by Sandisk come with
           special U3 software for MS Windows installed.  When the U3
           software is installed, the disk is configured as a CD-ROM rather
           than as a disk drive, and is not recognized by USBDRIVE.  You must
           uninstall the U3 software (which you must do from within MS
           Windows) before the disk will be recognized by USBDRIVE.



              DOS USB DRIVER INTRODUCTION            Page 160 of 186

           Security Software
           ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

           Some USB drives come with security protection on them, and they
           cannot be accessed without first entering some sort of password.
           I have never actually used one of these drives, and have no idea
           how the security protection works.  From some of the information
           I've seen, though, the security protection (at least on some of
           the drives) only seems to work when you're using MS-Windows.  If
           you're accessing the drives under any other operating system (Mac,
           Linux, DOS, etc.), there is no security at all.  That makes the
           security rather pointless, if you ask me.  If somebody has one of
           those drives, they can let me know what they discover.


           Wear Leveling
           ฤฤฤฤฤฤฤฤฤฤฤฤฤ

           The solid-state media used to make flash drives can only be
           written to a limited number of times (it does not last forever).
           The number of times it can be written to is a lot (at least tens
           of thousands of times, depending on the "quality" of the drive),
           so under normal circumstances this is not a major concern.  Also
           note that WRITING the data is what has a limited life span -- you
           can READ the data as much as you want (at least that's what they
           claim).

           When storing data on a disk, certain areas of the disk get written
           to a lot (like the File Allocation Table, which is near the start
           of the disk), while others (like the data area near the end of the
           disk) rarely change.  All modern USB flash drives include a
           process called "wear leveling", which is designed to "spread out"
           the disk writes across the entire disk rather than keeping them in
           the same place all the time.  That is, which transistors in the
           flash drive are used to store the File Allocation Table will move
           around the disk to different places as you keep changing the data.
           This makes the disk ultimately last thousands of times longer than
           it otherwise would.

           Wear leveling happens in the background and you normally never
           need to worry about it.  There is one thing to keep in mind,
           however.  A disk that uses wear leveling (and all modern ones do)
           may not actually erase or overwrite data like it does on magnetic
           media -- it may just move the data to a different set of
           transistors.  If your data is "sensitive" and you never want
           anyone to see it after you erase it, you probably shouldn't use
           flash drives at all.  The data that you "erased", even if you did
           it with special "disk wiping" software, may still be there stored
           in the transistors.




              DOS USB DRIVER INTRODUCTION            Page 161 of 186

           DOS Sector Size
           ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

           USBDRIVE simply provides physical access to the USB drives -- it
           expects the operating system (DOS) and other software to
           "interpret" and format the data that is stored there.  I have
           heard of, but not actually seen, certain USB drives (such as
           magneto-optical drives) that use a sector size larger than the
           standard 512 bytes.  I do not know if these drives are actually
           configured to look like hard drives (if they are in a standard
           DOS-compatible FAT12/FAT16/FAT32 format).  If they are not, then
           it will take special software to read and write to them.

           In its base form, DOS will not work correctly with sector sizes
           larger than 512 bytes.  There is a patch you can make to the DOS
           kernel (MSDOS.SYS, IBMDOS.COM, or equivalent) that will allow them
           to work with such disks, but it increases the size of the DOS
           kernel (and will also increase the size of USBDRIVE) in memory.
           If you run across such a disk, and want to patch the kernel,
           contact me and I can tell you what to do.  This is definitely not
           something you would want to do on every computer, since it will
           simply waste memory unnecessarily.


        Miscellaneous Notes
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        To have USBDRIVE show you the current status of the program and the
        drives it is managing, you would do the following:

           USBDRIVE Status

        This will display "general" information about the USBDRIVE program
        (the drive initialization delay, whether it will assign drive letters
        to FAT32 volumes, etc.).  In addition, it will also display details
        for each of the individual USB disks you have installed on the
        computer, including USB Host Index & Device Address, LUN, drive
        letter, and capacity information.

        USBDRIVE allows access to the drives at three different levels: BIOS
        (INT 13h, including extended functions for large capacity disks), DOS
        (through a device driver), and DOS direct functions (INT 25h & 26h).
        This should allow virtually all programs (including "low-level"
        programs like FDISK and FORMAT) to access and manipulate the USB
        disks.








              DOS USB DRIVER INTRODUCTION            Page 162 of 186

        USBDRIVE provides a special extension to the INT 13h (Disk Drive)
        functions in the BIOS.  The extension allows you to issue virtually
        any SCSI request to a USB-attached disk.  This is conceptually
        similar to ASPI (Advanced SCSI Programming Interface), which you may
        already be familiar with.  Details of the INT 13h BIOS extension are
        not provided here, but will be included with the final release (and
        complete documentation) of USBDRIVE.  Until then, you can download
        the source code for USBDRIVE if you want to study details about the
        BIOS extension.  USBDRIVE itself uses the BIOS extension to perform
        the /Format and /InquiryData option switches.


        In the current state, the USB Host Drivers (USBUHCI{L}) only support
        USB version 1.x compatible Hosts (maximum 12 Mbps).  Some of the
        other DOS USB driver packages support USB version 2 (EHCI, maximum
        480 Mbps).  Therefore, with these DOS Drivers, the access may be slow
        compared to some other drivers.  Speed will be increased in the
        future as other Host Controller drivers are written.

        To reserve drive letters, USBDRIVE inserts some "fake" information
        into the DOS Current Directory Structure (CDS) and Drive Parameter
        Block (DPB) tables.  This is what all removable media (including
        floppies) do.  Until a disk is actually inserted, USBDRIVE has
        literally no idea what the drive will actually look like (how big,
        how many partitions, what FAT type, etc.).  The "fake" information
        inserted by USBDRIVE looks like a drive with no data on it (0 kB).
        The information you see in the DRIVES program below (page 164) for
        the USB drives will look like a bunch of 0 kB disks, until the USB
        disks are actually plugged in and accessed by DOS.  Some people
        mistakenly assume that USBDRIVE has "resized" a USB drive when they
        see the size information in DRIVES, and that is not the case.  Until
        DOS actually accesses a drive (downloads some data from it), the
        information stored by DOS (and displayed by DRIVES) is totally bogus.

        Be sure you do not confuse FAT32 (the ability to access disks up to 2
        terabytes in size) with LFN (Long File Names).  They happened around
        the same time (the Windows 95 era), so many people assume they are
        related.  In reality, they have NOTHING to do with each other.  You
        can have LFN without FAT32, and vice versa.  However, I will tell you
        that Microsoft's design of LFN is one of the biggest kludges you have
        ever seen in your life.  LFN is COMPLETELY incompatible with programs
        like Microsoft's own DEFRAG program that came with several versions
        of DOS.  If anybody other than Microsoft had designed LFN the way
        they did, they would have been laughed right out of the programming
        world.








              DOS USB DRIVER INTRODUCTION            Page 163 of 186

        In its original form, USB Legacy Support originally only addressed
        keyboards and mice, and did not even address disk drives.  Legacy
        Support in general is a kludge, and with disk drives it is even more
        so.  That is at least partially why transferring control of disk
        drives from Legacy Support to an Operating System driver does not
        work very well.


     DRIVES
     ฤฤฤฤฤฤ

     Version:     0.01
     Prog Type:   Support
     Source Code: ASM (A86 by Eric Isaacson)
     Status:      Complete, a few minor tweaks required
     Environment: None
     Redirection: No
     Purpose:     Show details for all DOS disk drives
     TSR Memory:  0 kB (not a TSR)


     DRIVES is a program designed to let you view details about your disk
     drives (drive letters) in the same way that DOS looks at them.  There is
     a table that DOS uses to manage disks, called the Current Directory
     Structure Table or CDS Table.  Each entry in the CDS Table is a single
     CDS, and corresponds to a single drive letter (starting at A:).  As the
     name implies, the CDS table keeps track of the current directory for
     each drive, as well as a small amount of other information (such as
     whether it is a physical drive or a network drive).  Other than the
     current directory information, the most important thing stored in the
     CDS is a pointer to another structure called the Drive Parameter Block
     or DPB, which is where most of the critical information about the drive
     is actually stored.  The DPB is discussed in the next paragraph.  The
     total number of entries in the CDS Table (the total number of drive
     letters available) is determined by the LASTDRIVE setting in your
     CONFIG.SYS file, and cannot be changed after DOS has booted.

     For each valid CDS, there is a corresponding Drive Parameter Block or
     DPB.  The DPB contains most of the critical details about the drive,
     including the FAT type, capacity, physical disk and partition
     information, etc.  The DPB also contains a pointer to the device driver
     for the drive, usually installed by the DOS kernel or by a special
     driver in the CONFIG.SYS file.  DOS never accesses the drive directly --
     it always does it through the device driver.









              DOS USB DRIVER INTRODUCTION            Page 164 of 186

     The Drive Parameter Block also contains a flag which becomes set when
     the drive has been Accessed in some fashion by DOS (when DOS has read
     some data from the drive).  This flag is very critical, because until a
     drive (at least a removable drive, such as a floppy or USB disk) has
     been accessed, none of the other details in the DPB can be trusted.  For
     example, the default DPB entry for a 3-1/2 inch floppy drive usually is
     set up to look like a low-capacity (720 kB) disk, but the Accessed flag
     is cleared.  This tells DOS that there is a slot to plug in a disk, but
     because it hasn't been Accessed, we don't know how big the drive
     actually is.  If you insert a 1.44 MB floppy, but don't read any data
     from it, the contents of the DPB won't change (it will still show an
     unaccessed 720 kB floppy).  When you actually read some data from the
     drive, DOS will change the DPB entry to correspond to an accessed 1.44
     MB drive.  However, with floppy drives, DOS will regularly unset (clear)
     the Accessed flag, since DOS can't actually tell if you've changed disks
     (media) or not.  If the media has changed but the Accessed flag is not
     cleared, DOS will probably corrupt the new disk (because it thinks it is
     still the old disk).

     DRIVES simply shows you some of the details that are in the DOS Current
     Directory Structure (CDS) Table, and the corresponding Drive Parameter
     Block (DPB) entries.  This is a "snapshot" view of all the disks you
     have, as viewed from the perspective of DOS.  It is critical to keep in
     mind that if the drive has not been accessed yet (if the "ACCESd" column
     is not "Y" for a particular drive letter), none of the other details in
     the output may be accurate.  That is simply how DOS handles removable
     disks which can be of different formats and capacities.


     USBPRINT
     ฤฤฤฤฤฤฤฤ

     Version:     0.08
     Prog Type:   Device/Interface Driver
     Source Code: ASM (A86 by Eric Isaacson)
     Status:      Complete, a few minor tweaks required
     Environment: USBPRINT
     Redirection: Yes
     Purpose:     Driver for up to 8 USB Printers
     TSR Memory:  9.7 kB


     USBPRINT is a Device/Interface Driver program for up to eight USB
     printers.  USBPRINT emulates a regular printer (LPT) port in the
     computer. This allows DOS programs to think that your printer is
     attached to a regular parallel port instead of to a USB port.







              DOS USB DRIVER INTRODUCTION            Page 165 of 186

     Being unable to print to a USB printer from DOS (or from a DOS box
     underneath Windows) has been a long-standing problem since USB came out
     in the mid-1990's.  There have been several Windows programs that have
     been developed to alleviate those problems.  Of course, because those
     programs require Windows, the programs are not really fixing the
     problem, they are just bypassing it.  USBPRINT is the only program I
     know of that will actually allow you to print to a USB printer from
     "real" DOS.

     There are a couple of specific limitations that USBPRINT has, however,
     that you need to know about.  The first limitation is that USBPRINT
     emulates printer ports in the BIOS, and not at the hardware level.
     Fortunately, nearly all DOS programs use the BIOS and do not interact
     with the parallel port directly at the hardware level.  A program that
     does interact at the hardware level will usually have an option to allow
     it to use the BIOS instead (WordPerfect for DOS being an excellent
     example of this).  If the program does not have an option to print using
     the BIOS, it may have an option to print to a file (rather than sending
     things directly to the printer), which is a "work-around" that will also
     allow you to use USBPRINT to print from the program to a USB printer.

     The other limitation of USBPRINT is that it simply emulates parallel
     ports -- it does not actually emulate printers.  That is, the program
     that is printing and the printer that it is printing to must use the
     same protocol.  USBPRINT does not provide any protocol conversion
     (unlike many of the Windows solutions, which can provide protocol
     conversion).  For example, if you have an old (parallel port) printer
     and a new computer with no parallel port, you can simply obtain one of
     the USB-to-parallel-port converter cables, and with USBPRINT you should
     be able to use the old printer just like you did on your old computer.
     If you buy a new USB printer, and want to use it in "real" DOS, you will
     usually want to buy a printer that uses or emulates the Hewlett Packard
     PCL (Printer Control Language) protocol, which many DOS programs
     understand.  Some of the more sophisticated DOS programs also understand
     the PostScript protocol, though "simple" DOS programs generally do not.
     Also keep in mind that even if a printer (especially a multi-function
     printer) is made by Hewlett-Packard, it does not necessarily mean it
     understands the PCL protocol.  I made this mistake once, and very much
     regretted it.  Many of the less expensive Hewlett-Packard multi-function
     devices (printer, copier, scanner, fax machine) use the LIDIL
     (Lightweight Imaging Device Interface Language) protocol instead of PCL,
     and you cannot print to them directly from DOS even with USBPRINT.











              DOS USB DRIVER INTRODUCTION            Page 166 of 186

     In addition to simply allowing you to print to USB printers in DOS,
     USBPRINT also "enhances" the printer BIOS to allow you to do things with
     printers (even those that are hooked up to "real" parallel ports) that
     you could not do before.  These enhancements include having a total of 9
     available printer ports (LPT1-LPT9) instead of just 3, two-way
     communication (receiving data from the printer instead of just sending
     data to the printer), and being able send blocks of data to the printer
     instead of just sending one character at a time.  In fact, the INKLEVEL
     program described below (page 176) takes advantage of these special
     functions to display the ink levels of certain ink-jet printers.  Exact
     details of the enhanced printer BIOS functions will not be discussed in
     this document.  You can either download the source code for USBPRINT or
     wait for the official USBPRINT program and documentation if you want
     more information about it.

     Unlike most of the other Device/Interface Drivers included in this
     package, a USB Host Driver (USBUHCI{L}) does NOT need to be installed
     into memory before installing USBPRINT.  USBPRINT provides enhanced
     functionality to the regular (parallel port) printers that are useful
     even if you don't have any USB printers installed.  To install USBPRINT
     into memory, you can simply run it with no option switches:

        USBPRINT

     I want to explain something here that could be a source of confusion.
     The standard BIOS has three parallel ports, which are associated with
     three hardware I/O addresses.  At the BIOS level, the parallel ports
     don't have a "name" -- they are simply the first, second, and third
     parallel ports.  The terms LPT1, LPT2, and LPT3 are the names of DOS
     Devices, and only have meaning when you're at the DOS level.  If you're
     not using a DOS-based operating system, the terms LPT1, LPT2, and LPT3
     don't mean anything and may not even exist on the computer at all.  The
     BIOS parallel ports are always there no matter what the operating system
     is.  In this document, we will use the terms somewhat interchangeably
     (DOS' LPT1 is the same thing as the BIOS' first parallel port), though
     technically that is not always true.


        Printer BIOS
        ฤฤฤฤฤฤฤฤฤฤฤฤ

        The BIOS on a modern computer supports three parallel (printer)
        ports, which DOS calls LPT1, LPT2, and LPT3.  Most modern computers
        usually only have one physical parallel port, if they have any at all
        (laptops usually don't).  It's getting harder and harder to find
        printers that will even work with a parallel port -- most all of them
        are going strictly to USB interfaces.






              DOS USB DRIVER INTRODUCTION            Page 167 of 186

        Most DOS programs, by default, assume that if you have a printer, it
        is attached to LPT1.  Some programs, in fact, will not even let you
        print to any printer port except LPT1 (they will not let you print to
        LPT2 or to a serial-attached printer, for example).  For this and
        other reasons, if you only have one printer, you will usually want it
        to be mapped as LPT1.

        USBPRINT supports up to 9 parallel ports (LPT1-LPT9), instead of just
        3 like the normal BIOS.  As you attach and detach USB printers,
        USBPRINT automatically assigns them to the LPT ports.  USBPRINT
        automatically detects which "real" parallel ports (LPT1-LPT3) you
        have on the computer, and by default will not assign them to the USB
        printers.  In other words, by default, USBPRINT will never assign a
        USB printer to be LPT1 if your computer has at least one parallel
        port.  It doesn't matter whether you actually have a printer attached
        to the parallel port or not -- if USBPRINT doesn't see a printer, it
        doesn't necessarily mean you don't have a printer -- it could be that
        you have one and it is simply turned off or unplugged at the moment.

        If you want USBPRINT to assign a USB printer to LPT1, even if your
        computer has a "real" parallel port, you need to tell USBPRINT to
        override its default behavior and to "replace" the parallel ports
        with the USB printer ports, as follows:

           USBPRINT ReplaceParallel:Yes

        When you do this, the first USB printer will be assigned as LPT1, the
        second as LPT2, etc.

        The BIOS uses a particular section of memory, called the BIOS Data
        Area (BDA), to store various information about the computer hardware.
        Information about the three parallel ports (LPT1-LPT3) is stored in a
        specific location in the BDA, and what is stored is the base I/O
        address of the parallel port (LPT1, for example, is usually I/O
        address 370h).  Many programs, to determine whether or not a printer
        is attached to an LPT port, look to see if there is a valid number
        (non-zero I/O port address) in the BDA.  Therefore, in order for
        USBPRINT to "fake" some programs into believing that a USB printer is
        actually a parallel printer, USBPRINT must put a "fake" I/O port
        address number in the BDA.  Note that most programs do not actually
        use the parallel port I/O address stored in the BDA to interact with
        the printer at the hardware level -- they just look to see if the
        number in the BDA is zero or not.










              DOS USB DRIVER INTRODUCTION            Page 168 of 186

        USBPRINT needs a 32-byte range of I/O addresses to be able to "fake"
        the three BIOS parallel ports (LPT1-LPT3).  The 32-byte range should
        really be "fake", and should not be associated with any type of real
        hardware at all (parallel port or otherwise).  By default, USBPRINT
        will scan for a range of fake I/O addresses when it is first
        installing itself into memory.  To perform the scan, USBPRINT must
        actually send data back and forth to the I/O addresses it is trying
        to test to see if there appears to be any real hardware attached
        there.  On rare occasions, if there is some sort of hardware actually
        attached to the address being tested, USBPRINT will inadvertently
        screw something up or reconfigure the hardware that is attached
        there.  USBPRINT is very careful about how it scans the I/O
        addresses, but can still screw something up if the hardware reacts in
        an unusual way.  If you want to specify a particular I/O address
        range for USBPRINT to use, instead of having it automatically try to
        find one by scanning, you would do the following:

           USBPRINT IOAddress: #

        where # is the starting address of a 32-byte range of I/O address to
        use. # must be a number between 400h and FFE0h, and must be evenly
        divisible by 32 (20h).  Again, if you use this option, it is critical
        that the I/O address range is not associated with any real hardware
        at all, or you can get yourself into trouble.

        Even though many programs will look in the BDA to see if there is a
        non-zero I/O address, almost no programs will actually use the I/O
        address to do anything.  Programs that actually use the I/O address
        are directly interacting at the hardware level, and are not using the
        BIOS, and therefore will not work with USBPRINT.

        To have USBPRINT show you a current status of the parallel ports, you
        would do the following:

           USBPRINT PortStatus

        This will show you the status of all of the parallel ports, including
        I/O addresses, printer status, and printer type.  The PortStatus
        option can be used whether USBPRINT is installed in memory or not
        (you can use it just to see the status of your parallel port
        printers).












              DOS USB DRIVER INTRODUCTION            Page 169 of 186

        Reassigning LPT Ports
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        One of the BIOS extensions that USBPRINT provides is the ability to
        remap (redirect) printer ports to each other.  For instance, let's
        say you have a printer attached to the third parallel port (LPT3),
        but want to be able to print to it from a program that only
        understands how to print to LPT1.  To do this, you would use USBPRINT
        to remap LPT1 to LPT3, causing anything that got sent to LPT1 to
        actually go the third parallel port, as follows:

           USBPRINT Map LPT1 LPT3

        To restore the original mapping (sending LPT1 to the first parallel
        port again), you would do the following:

           USBPRINT Map LPT1 LPT1

        USBPRINT must be installed in memory as a TSR in order to be able to
        remap parallel ports to each other.  However, there do not need to be
        any USB printers attached to the computer for this to work.  You can
        simply use USBPRINT to remap "real" parallel ports to each other.


        Printer Device ID's
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        In the mid 1990's, the Institute or Electrical and Electronics
        Engineers (IEEE) developed a standard for parallel ports, which they
        called 1284.  Since that time, nearly all printers have followed the
        standard.  Part of the standard includes something called a Device ID
        String, which is stored in the printer.  Using a special protocol,
        the computer can download the Device ID String from the printer.  The
        Device ID string MUST contain the manufacturer and model number, but
        can also contain any other items that the printer manufacturer may
        see fit to include (such as protocols and serial numbers).  The
        Device ID String is how Windows (and other operating systems)
        automatically identify what kind of printer you have.

        USBPRINT allows you to download and view the Device ID Strings of all
        the printers attached to your computer, whether they are attached
        using parallel ports or USB ports.  To view the Device ID Strings of
        all the printers attached to your computer, you would do the
        following:

           USBPRINT DeviceIDStrings

        USBPRINT does not need to be installed in memory as a TSR to be able
        to download the Device ID Strings.  Also note that if you have a
        really old printer (manufactured before the IEEE 1284 standards were
        created), your printer will not have a Device ID String.


              DOS USB DRIVER INTRODUCTION            Page 170 of 186


        Resetting a Printer
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        There are times when a printer gets "stuck" in the middle of print
        job, or for some other reason needs to be reset (reinitialize the
        protocols, margins, fonts, etc.).  There is a "soft reset" function
        that all printers are supposed to respond to that is sent through the
        control port (parallel or USB).  To issue a soft reset through the
        port, you must provide to USBPRINT an LPT port number.  For example,
        to reset LPT1, you would do the following:

           USBPRINT Reset LPT1

        In addition to the soft reset signal sent through the control port,
        nearly all printers also have some sort of reset that can be sent by
        sending a special series of characters to the printer.  However,
        exactly what the special series of characters is depends on the
        printer (it is protocol dependent).  USBPRINT cannot reset a printer
        using any type of protocol-dependent methods -- you (or the program
        you are using) will need to do that yourself.


        Epson Printer Initialization
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        At least some USB printers made by Epson require a special
        initialization process.  After they are first turned on or reset,
        they come up in something called "packet mode".  From what I've been
        able to gather, nobody outside of Epson seems to know exactly what
        packet mode is or what it is good for -- all that anybody seems to
        know about packet mode is that you can't print while you're in it.
        You must send a special series of characters to the printer to exit
        packet mode before you can actually print anything.

        USBPRINT will automatically recognize if a printer is made by Epson
        or not, and if it is, USBPRINT will (by default) send the special
        "exit packet mode" sequence at the appropriate times.  If you want to
        override this default, and either send the sequence manually or do it
        from some other program, you would do the following:

           USBPRINT AutoEpson: No

        The AutoEpson option only applies to Epson printers attached to USB
        ports, not those attached to parallel ports or USB-to-parallel-port
        converter cables.  For example, I used to have an Epson printer that
        had both a USB and a parallel port.  When it was hooked up through
        the parallel port, I did not ever need to issue the "exit packet
        mode" sequence.  I only needed to do it when it was attached through
        the USB port.



              DOS USB DRIVER INTRODUCTION            Page 171 of 186

        You can also have USBPRINT send the "exit packet mode" sequence to a
        printer at any time, by specifying a particular LPT port.  For
        example:

           USBPRINT SendEpson: LPT1

        will send the sequence to the printer attached to LPT1.


        Copying Files to a Printer
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        One way you can print something to a printer (if it is a text file,
        or a file that already has the special escape sequences needed to set
        the printer into graphics mode), is to simply use the DOS COPY
        command.  For example:

           COPY FILENAME.TXT LPT1

        However, one limitation of the DOS copy command is that you can only
        print one file at a time -- you cannot use the DOS * or ? wildcards
        to print multiple files at the same time.  USBPRINT provides a "copy"
        function similar to DOS, but which will let you use wildcards.  For
        example, to print all files in the C:\BATCH directory with the .BAT
        extension to LPT9, you would do the following:

           USBPRINT COPY C:\BATCH\*.BAT LPT9

        As long as the underlying DOS version supports Long File Names, the
        USBPRINT copy function also supports them, so you can do something
        like this:

           USBPRINT COPY "C:\Long File Names\Test.P??" LPT1

        You can also perform multiple copies with one USBPRINT command line,
        for example:

           USBPRINT COPY *.PRN LPT1 COPY \AUTOEXEC.BAT LPT2

        By default, at the end of each file, USBPRINT will send a new page
        sequence (carriage return/form feed combination) to the printer so
        that each different file will get start on a new page.

        There may be times when you do not want USBPRINT to send the new page
        sequence, either because the files being printed are not simple text
        files (they already contain the appropriate escape codes and new page
        sequence codes) or because you just do not want each file to be
        separated onto a distinct page.  If you do not want USBPRINT to send
        the new page sequence between each file, you would do the following:

           USBPRINT FormFeed: No


              DOS USB DRIVER INTRODUCTION            Page 172 of 186

        You can use USBPRINT to print multiple files like this at the same
        time even if USBPRINT is not installed in memory as a TSR.  That is,
        you can use this option to send files to "real" parallel printers
        even if you do not have any USB printers installed.


        The CPU BOUND Bug
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        There is a special instruction in the CPU called BOUND, which has a
        "bug" associated with it.  Actually, what happens is not truly a bug,
        since it works exactly like it's designed to work.  IBM screwed up
        when they originally designed the PC BIOS, and used some of the
        Interrupts for BIOS functions that were officially listed by Intel as
        "reserved for future hardware use".  The Interrupts were not used by
        Intel in the first CPU's used on IBM-compatible computers (8088's).
        As Intel upgraded the processors (80286, 80386, etc.), the "reserved"
        Interrupts started to get used, which created conflicts with what IBM
        had done in the BIOS.

        One such conflict occurred with the BIOS PrintScreen function, which
        uses Interrupt (INT) 5.  When Intel introduced the 80286 CPU, it
        added a new CPU instruction called BOUND, which also uses INT 5.  If
        the BOUND CPU instruction is ever issued by a program accidentally
        (which can happen with a program that has bugs or insufficient memory
        or some other problem), the computer will go into an infinite
        PrintScreen loop.  That is, the computer will act like you are
        hitting the PrintScreen key over and over and over again without
        stopping.  If the printer attached to LPT1 is turned on at the time,
        this will send an endless sequence of screen copies to the printer,
        possibly wasting reams of paper and a lot of ink.  If the printer is
        turned off when the accidental BOUND instruction is issued, the
        computer will simply lock up and stop responding.  The only way to
        stop this infinite PrintScreen loop is to turn off the computer --
        the CPU is "stuck" in the accidental BOUND instruction with no way to
        exit.

        Because the "bug" is associated with printer ports, USBPRINT has a
        "patch" for the BOUND bug.  Unfortunately, it is not possible for
        USBPRINT to actually "repair" the bug.  If the BOUND instruction is
        ever issued accidentally, it means that something has gone very wrong
        with the memory of the computer (it is performing instructions that
        it shouldn't be).  Therefore, the only safe thing for USBPRINT to do
        when it senses an errant BOUND instruction is to shut down (reboot)
        the computer, which is exactly what it does.








              DOS USB DRIVER INTRODUCTION            Page 173 of 186

        By default, the BOUND bug patch is enabled whenever USBPRINT is
        installed in memory as a TSR.  If you want to turn the BOUND bug
        patch off, you would do the following:

           USBPRINT BoundPatch: No

        To re-enable the BOUND patch again, you would do the following:

           USBPRINT BoundPatch: Yes

        USBPRINT must be installed in memory as a TSR in order for the BOUND
        bug patch to be installed.  However, USBPRINT does not require any
        USB printers to be installed.

        The BOUNDTST program discussed below (page 175) will let you test the
        BOUND bug patch that is installed with USBPRINT to make sure it is
        working properly.


        Miscellaneous Notes
        ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

        To have USBPRINT show you the current status of the program and the
        printers it is managing, you would do the following:

           USBPRINT Status

        This will display "general" information about the USBPRINT program
        (whether "overwrite" parallel ports with USB ports, whether the BOUND
        bug patch is enabled, etc.).  In addition, it will also display
        details for each of the individual USB printers you have installed on
        the computer, including USB Host Index & Device Address, whether the
        printer is made by Epson or not (and consequently will be issued the
        special Epson setup strings when appropriate), and a description of
        the printer as contained in the Device ID string.

        USB is a packet-based architecture which is inherently designed to
        send several bytes of data at a time.  Sending only one byte of data
        at a time in USB is EXTREMELY inefficient and slow, and defeats one
        of the main purposes of USB.  However, printers (parallel ports) are
        designed to only transfer one byte at a time.  USBPRINT internally
        buffers the data being sent by the parallel port BIOS (one character
        at a time), and only sends the data to the USB printer when the
        buffer gets full or enough time has elapsed since the last character
        was sent that USBPRINT thinks you might be done printing.  However,
        unlike true print spooling programs, USBPRINT does not buffer an
        entire print job before it starts to print.  USBPRINT is sort of
        half-way between a real-time printing program and a print spooler,
        which can create problems in certain situations.




              DOS USB DRIVER INTRODUCTION            Page 174 of 186

        USBPRINT seems to work well with programs that print in the
        foreground (programs that wait for the print job to finish before
        they continue doing the next thing).  However, programs that attempt
        to print in the background (such as WordPerfect for DOS) can have
        problems.  The problems will generally arise if you are printing
        large documents, if the printer has a limited amount of memory, or if
        the printer prints very slowly.  You will need to experiment to see
        what happens with your particular programs and printers.  If it turns
        out that USBPRINT will not work correctly with your programs, you may
        need to set them up to print to files instead of printing directly to
        the printer, and then use DOS or USBPRINT to COPY the files to the
        printer after you exit or shell out of the program.  It is usually
        possible to automate this process using appropriate configuration
        options in the program and well-written batch files (I will leave it
        up to you to figure out how to do that).  Hopefully, a future
        revision of USBPRINT will have this problem resolved and you won't
        need to resort to "work-arounds".


     BOUNDTST
     ฤฤฤฤฤฤฤฤ

     Version:     1.00
     Prog Type:   Test
     Source Code: ASM (A86 by Eric Isaacson)
     Status:      Complete
     Environment: None
     Redirection: No
     Purpose:     Tests CPU BOUND instruction bug fix
     TSR Memory:  0 kB (not a TSR)


     There is a special CPU instruction called BOUND that works in a very
     unusual way, and consequently has a "bug" associated with it.
     Technically, it is not a true "bug", because it works exactly like it's
     designed to work, but can cause you problems at certain times anyway.
     More details on exactly what problems you may have with the BOUND
     instruction are given above in "The CPU BOUND Bug" (page 173), and will
     not be repeated again here.

     What BOUNDTST does is issue a BOUND instruction, on purpose, to the CPU.
     If you do NOT have an appropriate patch installed in memory (such as the
     one included in USBPRINT), your computer will either lock up or print an
     endless series of PrintScreen's to your printer.  If you DO have an
     appropriate patch installed, your computer should simply reboot.  Again,
     the details are discussed above, so read "The CPU BOUND Bug" (page 173)
     if you want to know more.






              DOS USB DRIVER INTRODUCTION            Page 175 of 186

     INKLEVEL
     ฤฤฤฤฤฤฤฤ

     Version:     0.01
     Prog Type:   Test
     Source Code: C++ (Borland Turbo C++ for DOS 3.0)
     Status:      In progress, several major items to address
     Environment: None
     Redirection: No
     Purpose:     Show amount of Ink remaining in HP & Epson Printers
     TSR Memory:  0 kB (not a TSR)


     INKLEVEL is a program designed to show you the amount of ink remaining
     in your printer cartridges.  Many modern ink jet and laser printers have
     a method of "downloading" this data from the printer, though the printer
     manufacturers almost never provide a way for you to see the data without
     using a special Windows program.  As far as I know, INKLEVEL is the only
     program available anywhere that will let you view your printer ink
     levels in DOS.

     In order for INKLEVEL to work properly, however, you must have USBPRINT
     installed in memory first.  USBPRINT provides certain extended printer
     BIOS functions that INKLEVEL needs to communicate with the printer
     properly.  Without USBPRINT (or some equivalent program developed in the
     future) installed in memory, INKLEVEL will not function.

     Currently, INKLEVEL only works with some Hewlett Packard and Epson
     printers, because those are the only ones I have ever had access to for
     testing.  I strongly encourage someone to take INKLEVEL and "run with
     it", adding support for various other models and manufacturers of
     printers.  I will not be doing this myself unless I personally come
     across a printer that I want to support for some reason, and that is not
     likely to happen any time soon.  Unlike most of my other programs
     (written in ASM), INKLEVEL is written in C++ so it should be relatively
     easy for someone to update and improve it.  My purpose for writing
     INKLEVEL was to relieve some of the frustration I had with not being
     able to view this information from DOS, and to "show off" some of the
     capabilities of USBPRINT.

     By default, INKLEVEL will show you the ink level status of all printers
     (USB and parallel) that it can find.  For example:

        INKLEVEL

     If you have more than one printer, but only want to see the status of a
     particular one, you must provide an LPT number, between LPT1 and LPT9.
     For example:

        INKLEVEL LPT1



              DOS USB DRIVER INTRODUCTION            Page 176 of 186

     If you have several printers but only want to see the status of one or
     two of them, you can also provide more than one LPT number, for example:

        INKLEVEL LPT1 LPT4

     INKLEVEL requires USBPRINT to be installed in memory before it will
     function.  If you do not need or want USBPRINT to be installed in memory
     permanently (for instance, if you have no USB printers), you can set
     yourself up a batch file to show you the ink levels that looks something
     like this:

        USBPRINT               Install USBPRINT into memory
        INKLEVEL               Show ink levels for all printers
        USBPRINT Uninstall     Uninstall USBPRINT from memory

     What INKLEVEL displays will be an identification of the port and printer
     type, followed by a cryptic string, followed by the ink levels of all
     the different ink cartridges both in simple percentages (numbers) and as
     a graph.  The "cryptic string" is the data that INKLEVEL downloads from
     the printer that contains the ink level percentages embedded in it.  It
     would be nice if the printer simply said something like, "Red: 20%", but
     none of them ever do that.  The ink percentages are encoded in some
     special way, unique to the manufacturer, and sometimes to the model, of
     the printer.  INKLEVEL displays the string so that I could see it as I
     was troubleshooting INKLEVEL during development, and I left it in there
     just as an "added feature" so that you could see what's going on behind
     the scenes.

     Every printer I've ever seen that tells you what the ink level is lies
     about it.  As you use the printer, the ink level will go down slowly
     until it reaches 0%, which should mean the printer won't work any more.
     I've been able to print hundreds of pages on every printer I've had,
     even after it told me it didn't have any ink left.  I know part (if not
     all) of this is a marketing ploy to get you to buy more ink than you
     really need (Epson has been sued over this).  The bottom line is no
     matter what the printer tells you (through INKLEVEL), you shouldn't
     necessarily believe it.
















              DOS USB DRIVER INTRODUCTION            Page 177 of 186

     USBSUPT1
     ฤฤฤฤฤฤฤฤ

     Version:     0.07
     Prog Type:   Support
     Source Code: ASM (A386 by Eric Isaacson)
     Status:      In progress, several major items to address
     Environment: None
     Redirection: No
     Purpose:     Translate various USB codes (numbers) to words
     TSR Memory:  0 kB (not a TSR)


     USBSUPT1 is the main support program for this USB software package.
     It's main purpose is to "translate" the various cryptic USB code numbers
     and data structures (of which there are many) into a format that you (as
     a human being) can understand.  While USBSUPT1 can be used as a
     standalone program, it's actually designed to be called by other
     programs, such as the various DOS USB drivers.  USBSUPT1 is able to
     translate many of the things that are common to several USB programs.
     By putting the "common" things that several programs use into one place,
     it makes each individual program smaller and makes it easier to update
     the entire architecture.

     USBSUPT1 does not actually provide all of the support functions itself,
     however.  USBSUPT1 at times itself calls other "sub-support" programs,
     which may be specific to a certain class of USB Device or Interface or
     Vendor, or some specialized function that is complicated or data-
     intensive enough to warrant a separate program.  For example, HIDSUPT1
     (described below, page 180) is a support program specifically dedicated
     to USB Human Interface Devices (mice, keyboard, joysticks, etc.), and
     UNI2ASCI (described below, page 181) translates Unicode strings into
     ASCII.

     USBSUPT1, and the entire set of USB support programs in general, is
     incomplete.  There are many kinds of USB devices that will need
     specialized support programs, assuming DOS device drivers are ever
     developed for them.  For instance, USBSUPT1 currently contains some of
     the translation data it needs for USB Audio Device/Interfaces
     (microphones, speakers, equalizers, etc.), but does not contain all of
     them.  I was actually working on this several months ago, but decided it
     would be better to distribute the USB package as it is (incomplete but
     functional).










              DOS USB DRIVER INTRODUCTION            Page 178 of 186

     Because USBSUPT1 is designed to be called from other programs, it does
     not contain many of the "nice" features that many of the other programs
     have (lengthy lists of Aliases, ErrorLevel tables, environment variable
     support, etc.).  Nonetheless, you can use it as a standalone program to
     translate specific codes or display lengthy tables of data for various
     USB related items.  Playing around with USBSUPT1 should provide lots of
     interesting information to you (assuming you like to play around with
     that sort of thing), but if you're not already pretty familiar with the
     USB architecture and terminology and structure of these DOS USB driver
     programs, it may confuse you more than it helps you.

     Since the main purpose of USBSUPT1 is to translate USB codes (numbers)
     into something understandable, you many times need to provide some sort
     of number (or numbers) to USBSUPT1.  USBSUPT1 will generally accept
     numbers in either decimal or hexadecimal format, with hexadecimal
     numbers indicated by an "h" at the end.  For example, the following are
     equivalent:

        USBSUPT1 Country 10
        USBSUPT1 Country Ah

     Usually, if you don't provide a number at all, USBSUPT1 will display the
     entire list of appropriate codes.  For example, to display the entire
     list of Country codes (rather than a single one), you would do:

        USBSUPT1 Country

     There are certain options where USBSUPT1 does not translate a simple
     code number, but rather translates an entire structure or descriptor or
     set of descriptors that are stored somewhere in memory.  What must be
     provided to USBSUPT1 in this case is a memory address, in Segment:Offset
     format.  When providing a memory address, however, the numbers are
     ALWAYS assumed to be in hexadecimal format, even if they are not
     followed by an "h".  For example, the following are equivalent:

        USBSUPT1 ControlPacket 1234:5678
        USBSUPT1 ControlPacket 1234h:5678h

     We will not list here all of the different types of things that USBSUPT1
     will display.  To display the list, you can simply type "USBSUPT1" at
     the command line with no options at all:

        USBSUPT1










              DOS USB DRIVER INTRODUCTION            Page 179 of 186

     HIDSUPT1
     ฤฤฤฤฤฤฤฤ

     Version:     0.06
     Prog Type:   Support
     Source Code: ASM (A386 by Eric Isaacson)
     Status:      Complete, a few minor tweaks required
     Environment: None
     Redirection: No
     Purpose:     Translate various HID codes to words
     TSR Memory:  0 kB (not a TSR)


     HIDSUPT1 is very similar in concept to USBSUPT1, described directly
     above (page 178).  However, while USBSUPT1 is directed at the "high
     level" USB codes and structures, HIDSUPT1 is specifically directed at
     Human Interface Devices or HID's.  HID's are actually a large class of
     "Devices", which includes mice, keyboards, joysticks, and several other
     items (pretty much anything that has buttons or controls or displays or
     lights that a human being might interact with).

     The USB HID specifications define two types of descriptors: Report
     Descriptors and Physical Descriptors.  All HID's must contain at least
     one Report Descriptor, which enumerates details about how many controls
     and lights and other things that the Human Interface Device has.  The
     Report Descriptor also describes the format of the data packets that are
     sent back and forth between the computer and the HID (which bits and
     bytes correspond to which buttons and keys and LED's and etc.).

     While Report Descriptors are required, Physical Descriptors are optional
     (I have personally never seen a Device with a Physical Descriptor).  The
     intent of a Physical Descriptor is to "describe" in detail exactly where
     each button or LED or whatever is located.  For instance, let's say a
     joystick has 4 buttons on it.  In the Report Descriptor, the buttons
     would simply be numbered from 1 to 4.  Without a Physical Descriptor,
     the only way to find out which button is which is to experiment (with a
     test program like THRUST described above on page 139, for example).  If
     the joystick had a Physical Descriptor, it could tell you that button 1
     is the one you press with your index finger, button 2 with your thumb,
     etc.  HIDSUPT1 is able to decode both Report Descriptors and Physical
     Descriptors.  However, because I have never actually seen a Device with
     a "real" physical descriptor, I do not know if it actually works like it
     should.  If anybody is ever able to test this for me, I would appreciate
     some feedback.









              DOS USB DRIVER INTRODUCTION            Page 180 of 186

     Pretty much all of the cautions and warnings and directions that are
     described above for USBSUPT1 also apply to HIDSUPT1 (numbers can be
     either decimal or hexadecimal, not entering a number displays the whole
     list, etc.).  Therefore, that information will not be repeated again
     here.  Also, like USBSUPT1, you can simply run the program with no
     option switches at all to display the list of exactly what the program
     can show you, as follows:

        HIDSUPT1


     UNI2ASCI
     ฤฤฤฤฤฤฤฤ

     Version:     0.01
     Prog Type:   Support
     Source Code: ASM (A86 by Eric Isaacson)
     Status:      In progress, several major items to address
     Environment: None
     Redirection: No
     Purpose:     Convert Unicode characters to ASCII
     TSR Memory:  0 kB (not a TSR)


     UNI2ASCI is a program that converts Unicode strings into ASCII strings,
     so that they can be viewed and printed in regular DOS programs.  When
     the screen of the computer is in text mode (which is the case for most
     DOS programs), each character that is viewed on the screen must be
     selected from a set of 256 possibilities (8-bit characters).  The entire
     set of 256 possibilities is called a Code Page.  The default Code Page
     that DOS uses is the one for United States English, and is called Code
     Page 437.  There are also several other Code Pages available for DOS,
     and there are various DOS utilities related to changing and controlling
     the Code Pages (NLSFUNC, COUNTRY, CHCP, etc.).

     The ASCII character set is actually limited to 128 characters (7 bits).
     For each Code Page, the first 128 (of 256 possible) characters
     correspond directly to the ASCII characters.  These include various
     control characters (escape, carriage return, form feed, etc.), upper-
     and lower-case letters (a-z), numbers (0-9), and miscellaneous
     punctuation (periods, commas, parentheses, etc.).  The second 128
     characters of each Code Page are different for each Code Page, but
     generally include box-drawing characters, accented letters and numbers
     (characters with acute, grave, diereses, etc.), and miscellaneous other
     characters.  For instance, Code Page 869 is specifically designed for
     the Greek language, and contains the entire upper- and lower-case Greek
     alphabet (Code Page 437 contains a few Greek characters, but not the
     entire Greek alphabet).





              DOS USB DRIVER INTRODUCTION            Page 181 of 186

     The Unicode character set allows 20 bits for each character, for a total
     of 1,048,576 possibilities.  This includes support for all kinds of
     languages that there are no DOS Code Pages for, such as Arabic, Chinese,
     and Cherokee.  20 bits is an unusual number in the programming world, so
     the Unicode organization has come up with three different ways of
     "encoding" Unicode characters: UTF-32, UTF-16, and UTF-8.  UTF-32
     encodes a 20-bit Unicode character into a 32-bit space by simply
     ignoring the upper 12 bits (making them 0).  UTF-16 encodes 20-bit
     characters into 16 bit words by making certain Unicode characters
     require 2 16-bit words instead of just one (that is, the length of a
     single Unicode character is variable).  UTF-8 works in a similar
     fashion, encoding a single 20-bit Unicode character as a variable-length
     string of 8-bit bytes.

     In addition to the UTF-8, UTF-16, and UTF-32 encodings, Unicode
     characters can be encoded either Little-Endian or Big-Endian.  Endian-
     ness comes about because of the way different processors store numbers.
     Intel-compatible CPU's always store things Little-Endian, while certain
     other CPU's (such as Motorola) store them Big-Endian.  With UTF-8,
     Endian-ness does not matter.  With UTF-16 and UTF-32, there are "sub-
     categories": UTF-16 LE, UTF-16 BE, UTF-32 LE, and UTF-32 BE.

     In order to correctly decode a Unicode string, the decoding program (in
     this case, UNI2ASCI) needs to know how the string is encoded (UTF-8,
     UTF-16 LE, UTF-16 BE, UTF-32 LE, or UTF-32 BE), or it will not be able
     to decode it properly.  It is usually not possible for a decoding
     program to determine the encoding scheme automatically.  However, if a
     decoding program knows the number of bits per character in the encoding
     scheme (UTF-8, UTF-16, or UTF-32), the first character in the string can
     (but does not need to) contain a special character that will tell the
     decoding program whether it is Big-Endian or Little-Endian.

     UNI2ASCI takes a Unicode string that is stored in memory somewhere,
     decodes it, and displays it on the screen as well as it can.  That is,
     it will take each Unicode character, and if it is similar to a character
     that can be displayed on the screen using the current DOS Code Page,
     UNI2ASCI will display it on the screen as that character.  If there is
     no Code Page character that is similar to the Unicode character,
     UNI2ASCI will display the character as "{U+####}", where the #### is the
     hexadecimal number of the Unicode character ("U+####" is a standard way
     of expressing Unicode characters in general).  If the Unicode character
     is a Control Character, the hexadecimal number will be displayed along
     with the common acronym used to describe the control (for example,
     "{1B=ESC}" for the Escape character).  The Unicode character set is
     divided into "regions", where certain characters (numbers) are Reserved,
     Private, Illegal, etc.  When UNI2ASCI comes across one of these
     "special" characters, it will display the hexadecimal number of the
     character along with an appropriate description (e.g.,
     "{F603=Private}").  You should review the Unicode specification if you
     want further details on all of this.



              DOS USB DRIVER INTRODUCTION            Page 182 of 186

     There are direct relationships between some of the Unicode characters
     and the Code Page characters.  However, there are also many (in some
     cases, very many) Unicode characters that appear very similar to one of
     the Code Page characters, even though they are technically not the same.
     In such cases, UNI2ASCI will still display the character using the Code
     Page character that it is similar to, rather than simply displaying a
     "{U+####}".  Of course, similarity is in the eye of the beholder, and
     characters that some people believe are "similar" other people may not.
     I have gone through all of the Unicode version 5.0 characters and found
     the Code Page characters from Code Page 437 (United States English) that
     I personally believe they are similar to.  It took many, many days to go
     through all of them, so things that I thought looked similar on one day
     versus another will not necessarily be consistent (depending on how I
     felt at the time, the weather, the lighting in the room, and who knows
     what else).

     In spite of the inconsistencies, I think UNI2ASCI is a pretty good start
     to a "universal" Unicode-to-Code-Page conversion program for DOS.
     However, UNI2ASCI currently only supports UTF-16 LE (which is how all
     USB-related strings are encoded), and will only decode to Code Page 437
     (the Code Page that I use).  Unless I find myself with a LOT of spare
     time on my hands (hah!), I will probably not update UNI2ASCI in any
     significant way, such as supporting other UTF encodings or Code Pages.
     I would strongly encourage someone who is interested to take UNI2ASCI
     and "run with it", updating it to include all sorts of new items, and
     enabling it to be used in all sorts of ways other than USB.

     To use UNI2ASCI, you must simply provide the memory address (hexadecimal
     Segment:Offset format) where the Unicode string (UTF-16 LE) is located.
     The string must end in Unicode character 0.  For example:

        UNI2ASCI 1234:5678

     The USBSUPT1 program (page 178 above) calls UNI2ASCI to display all
     Unicode strings that are downloaded from the USB Devices.


















              DOS USB DRIVER INTRODUCTION            Page 183 of 186

     VENDORID
     ฤฤฤฤฤฤฤฤ

     Version:     0.07
     Prog Type:   Support
     Source Code: ASM (A86 by Eric Isaacson)
     Status:      Complete
     Environment: None
     Redirection: No
     Purpose:     Translate PCI & USB Vendor ID codes to words
     TSR Memory:  0 kB (not a TSR)


     VENDORID is a program that searches for and displays the names of all of
     the known PCI, PNP, or USB Vendor ID's.  PNP (Plug-N-Play) ID's are
     three letter acronyms (for example, ICO = Intel Corporation) assigned by
     Microsoft, and will receive limited discussion here since they do not
     directly apply to USB devices.  In the PCI (Peripheral Component
     Interface) and USB (Universal Serial Bus) architectures, each vendor
     (manufacturer) registers with the appropriate organization, and receives
     a Vendor ID (a number).  Every device that the Vendor manufacturers is
     required to have the ID stored in the firmware of the device, so that
     the device can be identified automatically (using software).  In
     addition to the Vendor ID, PCI and USB Devices also contain a field for
     the Device ID.  While the Vendor ID is assigned by the USB or PCI
     organization (and requires a registration fee), the Device ID's are
     assigned and maintained by the individual Vendor.

     Even though the PCI and USB organizations are the only ones who can
     officially assign Vendor ID's, some Vendors make up their own, "borrow"
     ID's from each other, change their names, get taken over by other
     companies, go out of business, etc.  Therefore, it is very difficult to
     maintain an accurate list of names, since it is a "moving target".  On
     top of that, the PCI and USB organizations are not always willing to
     release their official information freely (even for something as simple
     as the list of Vendor ID's).  Over the years, there have been several
     volunteers that have gathered information about the Vendors and Devices
     for both USB and PCI.  However, you cannot always believe all of the
     information that you find, even if it comes directly from the
     organization itself.

     I have taken the information from several different locations (including
     the USB and PCI organizations where possible), and combined them into
     two sets data, one set for PCI and one for USB.  The VENDORID executable
     file itself (VENDORID.COM) does not actually contain the data, but
     simply allows you to look and search through the data that is in the
     data files (VENDORID.USB, VENDORID.PCI, and VENDORID.PNP).  The data
     files must be in the same directory as the executable file
     (VENDORID.COM).  The data files are in a simple ASCII text format, so
     you can easily look at and modify the data yourself with a simple text
     editor if you are so inclined.


              DOS USB DRIVER INTRODUCTION            Page 184 of 186

     There are four basic functions that VENDORID provides for the data.  The
     first function will tell you where the data came from (which web sites
     the data came from, and the date that the data was downloaded).  For
     example, to see where I got the PCI data from, you would do the
     following:

        VENDORID PCI Source

     Similarly, to see where I got the PNP data from, you would do the
     following:

        VENDORID PNP Source

     The second function that VENDORID provides allows you to discover the
     name of the company associated with a specific Vendor ID (number or
     acronym).  To do this, you must provide VENDORID with the Vendor ID
     number (either in decimal or hexadecimal format), or three-letter
     acronym (case-insensitive).  To indicate a hexadecimal number, you can
     either precede the number with a "0x" (C-style), follow the number with
     an "h", or both.  For example, the following lines will all provide the
     same result:

        VENDORID PCI 0x8086
        VENDORID PCI   8086h
        VENDORID PCI 0x8086h
        VENDORID PCI 32902

     The third function that VENDORID provides allows you to search for
     Vendor ID's by knowing all or part of the vendor's company name.  To do
     this, you provide a string to search for, surrounded by quotes (double
     quotes, left single quotes, or right single quotes).  The search is
     case-insensitive.  For example, the following lines will provide the
     same result:

        VENDORID USB "Intel"
        VENDORID USB 'intel'
        VENDORID USB 'INTEL'

     The results in this case would of course include "Intel Corp", along
     with several other vendors that included "intel" somewhere in their name
     (e.g., "Intelligent", "Intellix", etc.).

     If you want to see the entire list of USB vendors, you would do the
     following:

        VENDORID USB AllVendors







              DOS USB DRIVER INTRODUCTION            Page 185 of 186

     The VENDORID.USB, VENDORID.PCI, and VENDORID.PNP data files store the
     information sorted by Vendor ID (number or acronym) rather than by
     vendor name.  VENDORID does not offer any kind of sorting other than by
     Vendor ID.  If you want the display sorted in some fashion other than by
     Vendor ID (say, by vendor name), or want to filter it some other way
     (say, do a case-sensitive vendor name search), you will need to use an
     external filter.  The standard filters that come with DOS are FIND,
     SORT, and MORE, and if you're very familiar with DOS you should already
     understand them.  There are also several "after market" filters that you
     can obtain.  For example, if you want to sort the entire PCI vendor list
     by vendor name, and pause the screen after each page has been displayed,
     you would do the following:

        VENDORID PCI All | FIND "h " | SORT /+8 | MORE

     The company names as stored and displayed in VENDORID are limited to 40
     characters, so are almost always abbreviated in some fashion (Company is
     always "Co", Incorporated is always "Inc", etc.).  If you edit the data
     files yourself, and make a vendor name longer than 40 characters, the
     name will be truncated to 40 characters when it is displayed by
     VENDORID.COM.

     The format of the data files is fairly self explanatory if you look at
     them.  They can have blank lines and comment lines -- comment lines
     always start with a semicolon (";").  The lines containing the data
     sources start with "Source =".  A line containing a Vendor ID and name
     will start with the Vendor ID (number or acronym), followed by at least
     one space, followed by the vendor name.  VENDORID does not do any
     testing to verify sort order, duplicates, etc., in the data file, but
     rather simply assumes the data file is correct.























              DOS USB DRIVER INTRODUCTION            Page 186 of 186